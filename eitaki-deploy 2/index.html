<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#16A34A">
    <meta name="description" content="Eitaki - Decode what's really inside your products. Scan ingredients and understand what you're consuming.">
    
    <!-- Content Security Policy - Comprehensive configuration for Tesseract.js (WebAssembly + Workers) -->
    <!-- Reference: https://github.com/WebAssembly/content-security-policy -->
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self';
                   script-src 'self' 
                              'unsafe-inline'
                              'wasm-unsafe-eval'
                              https://cdn.jsdelivr.net 
                              https://generativelanguage.googleapis.com;
                   worker-src 'self' 
                              blob: 
                              https://cdn.jsdelivr.net;
                   child-src 'self' 
                             blob:;
                   connect-src 'self'
                               data:
                               blob:
                               https://cdn.jsdelivr.net
                               https://world.openfoodfacts.org 
                               https://generativelanguage.googleapis.com;
                   img-src 'self' 
                           data: 
                           blob: 
                           https:;
                   style-src 'self' 
                             'unsafe-inline';
                   font-src 'self' 
                            data:;
                   media-src 'self' 
                             blob:;">
    
    <title>Eitaki - Decode Every Ingredient</title>
    
    <!--
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    üå± Eitaki - Decode Every Ingredient
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    üí∞ ANALYSIS SOLUTION
    - Google Gemini Flash
    - Open Food Facts: 200K+ products
    - QuaggaJS Barcode
    
    
    üì¶ Features:
    - Barcode + Manual ingredient scanning
    - AI-powered analysis with source citations
    - Health scoring with WHO/FSSAI/FDA/FSSAI badges
    - Multi-language ingredient detection
    - Community verification (Phase 1)
    - Progressive email verification
    - Offline capability (PWA)
    
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    -->
    
    <!-- PWA Manifest: Removed inline manifest due to browser limitations with data URIs.
         Will be added as external manifest.json file in Phase 1.5 for proper PWA support. -->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* BUG #18: Natural Green Color Scheme */
            /* PRIMARY PALETTE */
            --color-brand-primary: #16A34A;  /* Eitaki Green */
            --color-brand-primary-light: #86EFAC;
            --color-brand-primary-dark: #15803D;
            
            /* HEALTH SCORE COLORS */
            --color-score-excellent: #16A34A;  /* 85-100 */
            --color-score-good: #84CC16;       /* 70-84 */
            --color-score-fair: #EAB308;       /* 50-69 */
            --color-score-poor: #F97316;       /* 35-49 */
            --color-score-very-poor: #DC2626;  /* 0-34 */
            
            /* Legacy variables mapped to new scheme */
            --deep-teal: #16A34A;
            --vibrant-coral: #FF6B6B;
            --sunshine-yellow: #FFC93C;
            --pure-white: #FFFFFF;
            --ice-blue: #F0FDF4;
            --slate: #1E293B;
            --light-slate: #64748B;
            
            /* Trust Badges */
            --trust-green: #10B981;
            --caution-yellow: #F59E0B;
            --warning-red: #EF4444;
            
            /* Functional Colors */
            --color-success: #10B981;
            --color-warning: #F59E0B;
            --color-error: #EF4444;
            
            --shadow: rgba(0, 0, 0, 0.1);
            --shadow-lg: rgba(0, 0, 0, 0.15);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--pure-white);
            color: var(--slate);
            overflow-x: hidden;
            line-height: 1.6;
        }

        .app-container {
            max-width: 100%;
            min-height: 100vh;
            padding-bottom: 70px;
        }

        /* Header - Minimal */
        .header {
            background: var(--deep-teal);
            color: white;
            padding: 16px 20px;
            box-shadow: 0 2px 8px var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            font-size: 22px;
            font-weight: 700;
            display: flex;
            flex-direction: column;
            gap: 2px;
            letter-spacing: -0.5px;
        }

        .logo-name {
            font-size: 24px;
        }

        .logo-subtitle {
            font-size: 11px;
            opacity: 0.9;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .icon-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        /* Views */
        .view {
            display: none;
            animation: fadeIn 0.3s;
        }

        .view.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Onboarding */
        .onboarding-container {
            min-height: calc(100vh - 70px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
        }

        .onboarding-screen {
            display: none;
            max-width: 500px;
            width: 100%;
        }

        .onboarding-screen.active {
            display: block;
            animation: fadeIn 0.4s;
        }

        .onboarding-icon {
            font-size: 80px;
            margin-bottom: 24px;
        }

        .onboarding-title {
            font-size: 32px;
            font-weight: 700;
            color: var(--deep-teal);
            margin-bottom: 16px;
        }

        .onboarding-subtitle {
            font-size: 14px;
            color: var(--light-slate);
            margin-bottom: 24px;
            font-style: italic;
        }

        .onboarding-text {
            font-size: 18px;
            color: var(--light-slate);
            margin-bottom: 32px;
            line-height: 1.6;
        }

        .onboarding-list {
            text-align: left;
            margin: 24px 0;
            padding: 0 20px;
        }

        .onboarding-list li {
            font-size: 16px;
            color: var(--slate);
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
        }

        .btn-primary {
            background: var(--deep-teal);
            color: white;
            box-shadow: 0 4px 12px rgba(22, 163, 74, 0.3);
        }

        .btn-primary:hover {
            background: #15803D;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(22, 163, 74, 0.4);
        }

        .btn-secondary {
            background: var(--ice-blue);
            color: var(--deep-teal);
        }

        .btn-secondary:hover {
            background: #E0F2FE;
        }

        /* Home View - Laser Focused */
        .home-hero {
            min-height: calc(100vh - 200px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
        }

        .hero-icon {
            font-size: 120px;
            margin-bottom: 32px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .hero-title {
            font-size: 36px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 16px;
            line-height: 1.2;
        }

        .hero-subtitle {
            font-size: 18px;
            color: var(--light-slate);
            margin-bottom: 40px;
            max-width: 400px;
        }

        .scan-btn-large {
            background: linear-gradient(135deg, var(--deep-teal), #15803D);
            color: white;
            border: none;
            padding: 20px 48px;
            border-radius: 16px;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(22, 163, 74, 0.3);
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 0.5px;
        }

        .scan-btn-large:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 32px rgba(22, 163, 74, 0.4);
        }

        .secondary-action {
            margin-top: 32px;
            color: var(--light-slate);
            font-size: 16px;
        }

        .text-link {
            color: var(--deep-teal);
            text-decoration: none;
            font-weight: 600;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }

        .text-link:hover {
            border-bottom-color: var(--deep-teal);
        }

        .recent-scans {
            margin-top: 48px;
            max-width: 600px;
            width: 100%;
        }

        .recent-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--light-slate);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .recent-items {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
        }

        .recent-item {
            background: var(--ice-blue);
            padding: 12px 20px;
            border-radius: 24px;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .recent-item:hover {
            background: var(--deep-teal);
            color: white;
            transform: translateY(-2px);
        }

        /* Scanner View - Clean */
        .scanner-container {
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
        }

        .scanner-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .scanner-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 8px;
        }

        .scanner-subtitle {
            font-size: 14px;
            color: var(--light-slate);
        }

        /* v1.2.1: Old .scan-mode-toggle and .mode-btn CSS removed - using floating badge */

        .camera-preview {
            position: relative;
            width: 100%;
            aspect-ratio: 3/4;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 0 8px 24px var(--shadow-lg);
        }

        .camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .camera-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            background: linear-gradient(135deg, var(--deep-teal), #15803D);
        }

        .placeholder-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .placeholder-text {
            font-size: 16px;
            opacity: 0.9;
        }

        .placeholder-subtext {
            font-size: 13px;
            opacity: 0.7;
            margin-top: 8px;
        }

        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .scan-guide {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .capture-area {
            border: 3px dashed var(--sunshine-yellow);
            border-radius: 12px;
            height: 200px;
            margin: 20px 0;
        }

        .camera-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 4px solid white;
            background: var(--vibrant-coral);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: white;
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
        }

        .capture-btn:hover {
            transform: scale(1.1);
        }

        .captured-images {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }

        .captured-image {
            position: relative;
            aspect-ratio: 1;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--ice-blue);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .captured-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .remove-image {
            position: absolute;
            top: 4px;
            right: 4px;
            background: var(--vibrant-coral);
            color: white;
            border: none;
            min-width: 44px;  /* BUG-016 FIX: Increased for better touch target */
            min-height: 44px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* BUG-016 FIX: Crop button touch target */
        .crop-image {
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn-full {
            flex: 1;
        }

        /* Analysis View - Clean & Focused */
        .analysis-container {
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        .product-header {
            background: var(--pure-white);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 2px 12px var(--shadow);
            margin-bottom: 20px;
            border-left: 4px solid var(--deep-teal);
        }

        .product-name {
            font-size: 24px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 8px;
        }

        .product-brand {
            font-size: 16px;
            color: var(--light-slate);
            margin-bottom: 20px;
        }

        .health-score-card {
            background: var(--ice-blue);
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .score-main {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 16px;
        }

        .score-circle {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 28px;
            color: white;
            box-shadow: 0 4px 12px var(--shadow);
            flex-shrink: 0;
        }

        .score-label {
            font-size: 11px;
            font-weight: 600;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .score-excellent { background: var(--trust-green); }
        .score-good { background: #93C47D; }
        .score-fair { background: var(--caution-yellow); }
        .score-poor { background: #F6B26B; }
        .score-bad { background: var(--warning-red); }

        .score-details {
            flex: 1;
        }

        .score-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 6px;
            color: var(--slate);
        }

        .score-desc {
            font-size: 14px;
            color: var(--light-slate);
            line-height: 1.6;
        }

        .trust-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .trust-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            background: white;
            box-shadow: 0 2px 6px var(--shadow);
        }

        .trust-badge.verified {
            color: var(--trust-green);
            border: 1.5px solid var(--trust-green);
        }

        .trust-badge.caution {
            color: var(--caution-yellow);
            border: 1.5px solid var(--caution-yellow);
        }

        .trust-badge.warning {
            color: var(--warning-red);
            border: 1.5px solid var(--warning-red);
        }

        .alert-box {
            padding: 16px;
            background: #FEE2E2;
            border: 2px solid var(--warning-red);
            border-radius: 12px;
            color: #991B1B;
            margin: 16px 0;
            font-weight: 600;
        }

        .analysis-section {
            background: var(--pure-white);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 2px 12px var(--shadow);
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--slate);
        }

        .ingredient-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .ingredient-item {
            padding: 16px;
            background: var(--ice-blue);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid var(--deep-teal);
        }

        .ingredient-item:hover {
            background: #E0F2FE;
            transform: translateX(4px);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .ingredient-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .ingredient-name {
            font-weight: 700;
            font-size: 16px;
            color: var(--slate);
        }

        .impact-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .impact-positive {
            background: #D1FAE5;
            color: #065F46;
        }

        .impact-neutral {
            background: #E5E7EB;
            color: #374151;
        }

        .impact-negative {
            background: #FEE2E2;
            color: #991B1B;
        }

        .ingredient-purpose {
            font-size: 14px;
            color: var(--light-slate);
            margin-bottom: 4px;
        }

        .ingredient-detail {
            font-size: 13px;
            color: var(--slate);
            line-height: 1.6;
        }

        /* Donation Card */
        .donation-card {
            background: linear-gradient(135deg, var(--sunshine-yellow), #FFD966);
            padding: 24px;
            border-radius: 16px;
            margin: 20px;
            box-shadow: 0 8px 24px rgba(255, 201, 60, 0.3);
            max-width: 600px;
            margin: 20px auto;
        }

        .donation-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 16px;
        }

        .donation-text {
            font-size: 15px;
            color: var(--slate);
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .donation-benefits {
            margin: 16px 0;
            padding-left: 20px;
        }

        .donation-benefits li {
            font-size: 14px;
            color: var(--slate);
            margin-bottom: 8px;
            list-style-type: disc;
        }

        .donation-amounts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .donation-btn {
            background: white;
            border: 2px solid var(--slate);
            padding: 12px;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .donation-btn:hover {
            background: var(--slate);
            color: white;
            transform: translateY(-2px);
        }

        .donation-footer {
            font-size: 13px;
            color: var(--slate);
            font-style: italic;
            text-align: center;
        }

        /* Settings View */
        .settings-section {
            background: var(--pure-white);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 2px 12px var(--shadow);
            margin-bottom: 20px;
        }

        .settings-item {
            padding: 16px 0;
            border-bottom: 1px solid var(--ice-blue);
        }

        .settings-item:last-child {
            border-bottom: none;
        }

        .settings-label {
            font-weight: 600;
            color: var(--slate);
            margin-bottom: 8px;
        }

        .settings-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--ice-blue);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .settings-input:focus {
            outline: none;
            border-color: var(--deep-teal);
        }

        /* Bottom Navigation - Minimal */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--pure-white);
            border-top: 1px solid var(--ice-blue);
            display: flex;
            justify-content: space-around;
            padding: 12px 0;
            box-shadow: 0 -4px 12px var(--shadow);
            z-index: 100;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 24px;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--light-slate);
            transition: all 0.3s;
            font-size: 12px;
            font-weight: 600;
        }

        .nav-item.active {
            color: var(--deep-teal);
        }

        .nav-icon {
            font-size: 24px;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 300px;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid var(--ice-blue);
            border-top-color: var(--deep-teal);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--slate);
        }

        /* Email Verification Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 32px;
            border-radius: 20px;
            max-width: 450px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 16px;
        }

        .modal-text {
            font-size: 15px;
            color: var(--light-slate);
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .form-input {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--ice-blue);
            border-radius: 12px;
            font-size: 16px;
            margin-bottom: 16px;
            transition: all 0.3s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--deep-teal);
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
        }

        /* Disclaimer */
        .disclaimer {
            background: var(--ice-blue);
            padding: 16px;
            border-radius: 12px;
            font-size: 13px;
            color: var(--light-slate);
            margin-top: 20px;
            border-left: 4px solid var(--deep-teal);
        }

        .disclaimer strong {
            color: var(--slate);
        }

        /* Responsive */
        @media (max-width: 640px) {
            .hero-title {
                font-size: 28px;
            }

            .hero-icon {
                font-size: 80px;
            }

            .scan-btn-large {
                font-size: 18px;
                padding: 18px 36px;
            }

            .onboarding-title {
                font-size: 28px;
            }
        }

        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           V1.2.0 NEW STYLES
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        /* Floating Mode Badge */
        .mode-badge {
            position: fixed;
            top: 80px;
            left: 16px;
            z-index: 200;
            background: rgba(22, 163, 74, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            padding: 10px 16px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(22, 163, 74, 0.3);
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            gap: 8px;
        }
        .mode-badge.visible { display: flex; }
        .mode-badge:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(22, 163, 74, 0.4); }
        .mode-badge.pulsing { animation: modePulse 2s ease-in-out infinite; }
        @keyframes modePulse {
            0%, 100% { box-shadow: 0 4px 12px rgba(22, 163, 74, 0.3); }
            50% { box-shadow: 0 4px 24px rgba(22, 163, 74, 0.6); }
        }
        .mode-badge-arrow { font-size: 10px; transition: transform 0.2s; }
        .mode-badge.menu-open .mode-badge-arrow { transform: rotate(180deg); }
        
        /* Mode Menu */
        .mode-menu {
            position: fixed;
            top: 130px;
            left: 16px;
            z-index: 199;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            padding: 8px 0;
            min-width: 180px;
            opacity: 0;
            transform: translateY(-10px) scale(0.95);
            transition: all 0.2s;
            pointer-events: none;
        }
        .mode-menu.visible { opacity: 1; transform: translateY(0) scale(1); pointer-events: auto; }
        .mode-menu-item { padding: 14px 20px; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.15s; }
        .mode-menu-item:hover { background: #F0FDF4; }
        .mode-menu-item.active { color: #16A34A; font-weight: 600; }
        
        /* Glass Bottom Bar */
        .scanner-bottom-bar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            border-radius: 40px;
            padding: 12px 24px;
            display: none;
            align-items: center;
            gap: 20px;
        }
        .scanner-bottom-bar.visible { display: flex; }
        .bar-btn {
            position: relative;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: none;
            background: #F0FDF4;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            transition: all 0.2s;
        }
        .bar-btn:hover { background: #DCFCE7; transform: scale(1.05); }
        .bar-btn.capture { width: 68px; height: 68px; background: #16A34A; color: white; font-size: 28px; box-shadow: 0 4px 16px rgba(22,163,74,0.4); }
        .bar-btn.capture:hover { background: #15803D; }
        .bar-btn .badge { position: absolute; top: -4px; right: -4px; background: #EF4444; color: white; font-size: 11px; font-weight: 700; min-width: 20px; height: 20px; border-radius: 10px; display: flex; align-items: center; justify-content: center; }
        
        /* Toast */
        .toast-container { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); z-index: 9999; pointer-events: none; }
        .toast { background: rgba(30,41,59,0.95); color: white; padding: 14px 24px; border-radius: 28px; font-size: 14px; font-weight: 500; opacity: 0; transform: translateY(20px); transition: all 0.3s; pointer-events: auto; margin-bottom: 8px; }
        .toast.visible { opacity: 1; transform: translateY(0); }
        .toast.success { background: rgba(16,185,129,0.95); }
        .toast.warning { background: rgba(245,158,11,0.95); color: #1E293B; }
        .toast.error { background: rgba(239,68,68,0.95); }
        
        /* Quality Indicator */
        .quality-indicator { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.75); color: white; padding: 8px 16px; border-radius: 24px; font-size: 12px; font-weight: 600; display: none; align-items: center; gap: 8px; }
        .quality-indicator.visible { display: flex; }
        .quality-dot { width: 8px; height: 8px; border-radius: 50%; }
        .quality-dot.good { background: #10B981; }
        .quality-dot.fair { background: #F59E0B; }
        .quality-dot.poor { background: #EF4444; }
        
        /* Auto-analyze Badge */
        .auto-analyze-badge { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(22,163,74,0.95); color: white; padding: 16px 24px; border-radius: 28px; font-size: 15px; font-weight: 600; display: none; align-items: center; gap: 10px; z-index: 20; }
        .auto-analyze-badge.visible { display: flex; animation: modePulse 1.5s infinite; }
        
        /* Confidence Badge */
        .confidence-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; margin-top: 12px; }
        .confidence-badge.high { background: rgba(16,185,129,0.15); color: #059669; }
        .confidence-badge.medium { background: rgba(245,158,11,0.15); color: #D97706; }
        .confidence-badge.low { background: rgba(239,68,68,0.15); color: #DC2626; }
        
        /* Safety Levels */
        .safety-level { display: inline-flex; align-items: center; gap: 4px; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; }
        .safety-level.safe { background: rgba(16,185,129,0.15); color: #059669; }
        .safety-level.moderate { background: rgba(245,158,11,0.15); color: #D97706; }
        .safety-level.limit { background: rgba(249,115,22,0.15); color: #EA580C; }
        .safety-level.avoid { background: rgba(239,68,68,0.15); color: #DC2626; }
        
        /* Score Explainer */
        .score-explainer { margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(0,0,0,0.1); }
        .explainer-toggle { background: none; border: none; color: #16A34A; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 4px; padding: 0; }
        .explainer-content { margin-top: 16px; padding: 16px; background: white; border-radius: 8px; display: none; }
        .explainer-content.visible { display: block; }
        .pillar-item { display: flex; align-items: center; gap: 16px; margin-bottom: 12px; }
        .pillar-weight { width: 40px; height: 40px; border-radius: 8px; background: #F0FDF4; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 700; color: #16A34A; flex-shrink: 0; }
        .pillar-name { font-size: 14px; font-weight: 600; color: #1E293B; }
        .pillar-desc { font-size: 12px; color: #64748B; }
        
        /* v1.2.2: Crop Modal */
        .crop-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            flex-direction: column;
        }
        .crop-modal.active { display: flex; }
        .crop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: rgba(0,0,0,0.5);
        }
        .crop-header h3 { color: white; margin: 0; font-size: 18px; }
        .crop-header button {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 8px;
        }
        .crop-header button:hover { background: rgba(255,255,255,0.1); }
        .crop-header .crop-done { background: #16A34A; font-weight: 600; }
        .crop-header .crop-done:hover { background: #15803D; }
        .crop-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        .crop-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            touch-action: none;
        }
        .crop-overlay {
            position: absolute;
            border: 2px dashed #16A34A;
            background: rgba(22, 163, 74, 0.1);
            pointer-events: none;
        }
        .crop-instructions {
            padding: 12px;
            text-align: center;
            color: #94A3B8;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
        }
        
        /* v1.2.2: Mini Recent Scans on Scanner Page */
        .scanner-mini-history {
            position: fixed;
            bottom: 100px;
            left: 16px;
            right: 16px;
            z-index: 140;
            display: none;
        }
        .scanner-mini-history.visible { display: block; }
        .mini-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px 12px 0 0;
        }
        .mini-history-header span { color: white; font-size: 12px; font-weight: 600; }
        .mini-history-toggle {
            background: none;
            border: none;
            color: #16A34A;
            font-size: 12px;
            cursor: pointer;
        }
        .mini-history-list {
            display: flex;
            gap: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border-radius: 0 0 12px 12px;
            overflow-x: auto;
        }
        .mini-history-item {
            flex-shrink: 0;
            width: 80px;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
        }
        .mini-history-item:hover { background: rgba(255,255,255,0.2); }
        .mini-history-score {
            font-size: 18px;
            font-weight: 700;
            color: white;
        }
        .mini-history-name {
            font-size: 10px;
            color: #94A3B8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    
    </style>
    
    <!-- BUG-001 FIX: Add Tesseract.js for OCR (ingredient scanning) -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    
    <!-- BUG-002 FIX: Add QuaggaJS for barcode scanning -->
    <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2/dist/quagga.min.js"></script>
</head>
<body>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-name">üå± Eitaki</div>
                    <div class="logo-subtitle">Decode Every Ingredient</div>
                </div>
                <div>
                    <button class="icon-btn" onclick="app.showView('settings')" aria-label="Settings">
                        ‚öôÔ∏è
                    </button>
                </div>
            </div>
        </header>

        <!-- Onboarding - v1.2.1: Single screen -->
        <div id="view-onboarding" class="view active">
            <div class="onboarding-container">
                <div class="onboarding-screen active" id="onboarding-1">
                    <div class="onboarding-icon">üå±</div>
                    <h1 class="onboarding-title">Welcome to Eitaki</h1>
                    <p class="onboarding-text">
                        Decode ingredients in everyday products.
                    </p>
                    
                    <div style="text-align: left; margin: 24px 0; padding: 16px; background: rgba(22, 163, 74, 0.1); border-radius: 12px;">
                        <div style="margin-bottom: 12px; display: flex; align-items: center; gap: 12px;">
                            <span style="font-size: 24px;">üì∏</span>
                            <span>Scan barcode or ingredient list</span>
                        </div>
                        <div style="margin-bottom: 12px; display: flex; align-items: center; gap: 12px;">
                            <span style="font-size: 24px;">üî¨</span>
                            <span>Get AI-powered analysis</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span style="font-size: 24px;">üíö</span>
                            <span>Make informed choices</span>
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" onclick="app.completeOnboarding()" style="width: 100%; font-size: 18px; padding: 16px;">
                        Start Scanning ‚Üí
                    </button>
                </div>
            </div>
        </div>

        <!-- Home View - Laser Focused -->
        <div id="view-home" class="view">
            <div style="background: linear-gradient(135deg, #F0FDF4, #DCFCE7); padding: 12px 20px; text-align: center; font-size: 14px; font-weight: 600; color: #166534; border-bottom: 2px solid #86EFAC;">
                üß™ Beta Testing Phase - Help us improve! <a href="https://forms.gle/vnhGDgAVUUeid1SY8" style="color: #16A34A; text-decoration: underline;">Share Feedback</a>
            </div>
            <div class="home-hero">
                <div class="hero-icon" role="img" aria-label="Plant seedling">üå±</div>
                <h1 class="hero-title">
                    Decode Every<br>Ingredient
                </h1>
                <p class="hero-subtitle">
                    Scan any product and decode complex ingredients in seconds
                </p>
                <button class="scan-btn-large" onclick="app.showView('scanner')" aria-label="Start scanning products">
                    üì∏ SCAN PRODUCT
                </button>
                <!-- v1.2.1: Search link removed - Phase 1.5 feature -->
                
                <div class="recent-scans" id="recent-scans-container" style="display: none;">
                    <div class="recent-title">Recent Scans</div>
                    <div class="recent-items" id="recent-items"></div>
                </div>
            </div>

            <!-- Donation Card - Hidden in Beta -->
            <div class="donation-card" style="display: none;">
                <h3 class="donation-title">üíö Help Us Decode More Products</h3>
                <p class="donation-text">
                    Every day, families trust us to decode what's really inside their food, shampoo, and baby products.
                </p>
                <div class="donation-text" style="margin-top: 12px;">
                    <strong>Your support means:</strong>
                </div>
                <ul class="donation-benefits">
                    <li>1,000+ more products analyzed monthly</li>
                    <li>Faster scans for everyone</li>
                </ul>
                <div class="donation-amounts">
                    <button class="donation-btn" onclick="app.donate(20)">‚Çπ20<br><small>One chai</small></button>
                    <button class="donation-btn" onclick="app.donate(50)">‚Çπ50<br><small>Samosa party</small></button>
                    <button class="donation-btn" onclick="app.donate(100)">‚Çπ100<br><small>Full meal</small></button>
                    <button class="donation-btn" onclick="app.donateCustom()">Custom</button>
                </div>
                <div class="donation-footer">
                    Made with üíö by people who believe you deserve to know what you're consuming
                </div>
            </div>
        </div>

        <!-- Scanner View -->
        <div id="view-scanner" class="view">
            <!-- v1.2.1: X close button -->
            <button onclick="app.showView('home')" style="position: fixed; top: 16px; right: 16px; z-index: 200; width: 40px; height: 40px; border-radius: 50%; border: none; background: rgba(0,0,0,0.5); color: white; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                ‚úï
            </button>
            
            <!-- Floating Mode Badge (v1.2.0) -->
            <button class="mode-badge visible" id="mode-badge" onclick="app.toggleModeMenu()" aria-label="Toggle scan mode menu" aria-expanded="false">
                <span id="mode-badge-icon">üìã</span>
                <span id="mode-badge-text">Ingredients</span>
                <span class="mode-badge-arrow">‚ñº</span>
            </button>
            <div class="mode-menu" id="mode-menu">
                <div class="mode-menu-item active" id="menu-ingredients" onclick="app.selectMode('ingredients')">üìã Ingredients</div>
                <div class="mode-menu-item" id="menu-barcode" onclick="app.selectMode('barcode')">üìä Barcode</div>
            </div>

            <div class="scanner-container">
                <div class="scanner-header">
                    <h2 class="scanner-title">Scan Product</h2>
                    <p class="scanner-subtitle" id="scanner-subtitle">Point at ingredient list</p>
                </div>

                <!-- v1.2.1: Old tabs removed - using floating badge only -->

                <div class="camera-preview">
                    <video id="camera-video" class="camera-video" autoplay playsinline style="display:none;" aria-label="Camera preview"></video>
                    <div id="camera-placeholder" class="camera-placeholder">
                        <div class="placeholder-icon">üì∏</div>
                        <div class="placeholder-text">Camera will start automatically</div>
                        <div class="placeholder-subtext">Or tap Gallery below to upload</div>
                    </div>
                    
                    <div class="quality-indicator" id="quality-indicator">
                        <span class="quality-dot" id="quality-dot"></span>
                        <span id="quality-text">Checking...</span>
                    </div>
                    <div class="auto-analyze-badge" id="auto-analyze-badge">‚ú® Auto-analyzing...</div>
                    <div class="camera-overlay" style="display:none;" id="camera-overlay">
                        <div class="scan-guide" role="status" aria-live="polite" id="scan-guide-text">
                            üìã Point at ingredient list
                        </div>
                        <div class="capture-area" aria-hidden="true"></div>
                    </div>
                </div>

                <div class="captured-images" id="captured-images" role="list" aria-label="Captured images"></div>

                <!-- BUG #2: Hidden file input for gallery fallback -->
                <input type="file" id="file-input-fallback" accept="image/*" style="display: none;" onchange="app.handleGalleryUpload(event)">

                <!-- BUG #3: Scanner result area for quality feedback and errors -->
                <div id="scanner-result" style="display: none;"></div>

                <!-- v1.2.0: Old action buttons removed - using glass morphism bottom bar instead -->
            </div>
        
            <!-- Glass Morphism Bottom Bar (v1.2.0) -->
            <div class="scanner-bottom-bar" id="scanner-bottom-bar">
                <button class="bar-btn" onclick="app.openGallery()" aria-label="Gallery">üñºÔ∏è<span class="badge" id="photo-count-badge" style="display:none;">0</span></button>
                <button class="bar-btn capture" id="capture-btn-main" onclick="app.capturePhoto()" aria-label="Capture">üì∑</button>
                <button class="bar-btn" id="analyze-btn-bar" onclick="app.analyzeProduct()" aria-label="Analyze" disabled>‚úì</button>
            </div>
            
            <!-- v1.2.2: Mini Recent Scans -->
            <div class="scanner-mini-history" id="scanner-mini-history">
                <div class="mini-history-header">
                    <span>üìú Recent Scans</span>
                    <button class="mini-history-toggle" onclick="app.toggleMiniHistory()">Hide</button>
                </div>
                <div class="mini-history-list" id="mini-history-list">
                    <!-- Populated dynamically -->
                </div>
            </div>

        </div>
        
        <!-- v1.2.2: Crop Modal -->
        <div class="crop-modal" id="crop-modal">
            <div class="crop-header">
                <button onclick="app.cancelCrop()">Cancel</button>
                <h3>Crop Image</h3>
                <button class="crop-done" onclick="app.applyCrop()">Done</button>
            </div>
            <div class="crop-container" id="crop-container">
                <img id="crop-image" class="crop-image" src="" alt="Image to crop">
                <div class="crop-overlay" id="crop-overlay"></div>
            </div>
            <div class="crop-instructions">
                Pinch to zoom ‚Ä¢ Drag to position ‚Ä¢ Focus on ingredient list
            </div>
        </div>

        <!-- Analysis View -->
        <div id="view-analysis" class="view">
            <div class="analysis-container" id="analysis-content" role="main">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Settings View - BUG #11: Simplified Profile -->
        <div id="view-settings" class="view">
            <div class="analysis-container">
                <h2 class="section-title">‚öôÔ∏è Settings</h2>
                
                <!-- BUG #11: Simplified Profile Section -->
                <div class="settings-section">
                    <h3 style="margin-bottom: 16px;">üì∏ Profile</h3>
                    <div class="settings-item">
                        <div class="settings-label">Name</div>
                        <input type="text" class="settings-input" id="setting-name" placeholder="Your name">
                    </div>
                    <div class="settings-item">
                        <div class="settings-label">Food Allergies</div>
                        <input type="text" class="settings-input" id="setting-allergies" placeholder="e.g., peanuts, dairy, gluten">
                        <p style="font-size: 12px; color: var(--light-slate); margin-top: 4px;">
                            Separate multiple allergies with commas
                        </p>
                    </div>
                    <button class="btn btn-primary" onclick="app.saveSettings()" style="margin-top: 16px; width: 100%;">
                        Save Settings
                    </button>
                </div>

                <!-- Scan History (Simplified) -->
                <div class="settings-section">
                    <h3 style="margin-bottom: 16px;">üìú Scan History</h3>
                    <div id="scan-history-list" style="max-height: 200px; overflow-y: auto;">
                        <p style="color: var(--light-slate); font-size: 14px;">Your recent scans will appear here.</p>
                    </div>
                </div>

                <!-- BUG #13: About & Legal Section -->
                <div class="settings-section">
                    <h3 style="margin-bottom: 16px;">‚ÑπÔ∏è About & Legal</h3>
                    <div style="background: #F0FDF4; padding: 12px; border-radius: 8px; margin-bottom: 16px; border-left: 4px solid #16A34A;">
                        <strong>üß™ Beta Version</strong><br>
                        Testing with early users. Community features launching soon!
                    </div>
                    <p style="line-height: 1.8; color: var(--slate); margin-bottom: 16px;">
                        Eitaki helps you decode what's really inside the products you use every day. From Delhi to Dubai, Mumbai to Manhattan‚Äîwe believe everyone deserves food transparency.
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <a href="#" onclick="app.showAbout(); return false;" style="color: #16A34A;">üå± About Eitaki</a>
                        <a href="#" onclick="app.showMethodology(); return false;" style="color: #16A34A;">üî¨ How We Calculate Scores</a>
                        <a href="#" onclick="app.showPrivacyPolicy(); return false;" style="color: #16A34A;">üîí Privacy Policy</a>
                        <a href="#" onclick="app.showTerms(); return false;" style="color: #16A34A;">üìã Terms of Service</a>
                    </div>
                </div>

                <div class="settings-section">
                    <h3 style="margin-bottom: 16px;">üîí Data & Privacy</h3>
                    <p style="line-height: 1.8; color: var(--slate); margin-bottom: 16px;">
                        ‚Ä¢ Your personal information is never sold or shared<br>
                        ‚Ä¢ We use industry-standard security practices<br>
                        ‚Ä¢ Analytics are anonymous and used only to improve the app<br>
                        ‚Ä¢ You control your data‚Äîdelete anytime below
                    </p>
                    <button class="btn btn-secondary" onclick="app.clearAllData()" style="width: 100%;">
                        Clear My Data
                    </button>
                </div>
            </div>
        </div>

        <!-- BUG #13: About Us Page -->
        <div id="view-about" class="view">
            <div class="analysis-container">
                <div style="max-width: 600px; margin: 0 auto; line-height: 1.8;">
                    <h1 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: #111827;">
                        About Eitaki
                    </h1>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            üå± Our Mission
                        </h2>
                        <p style="color: #374151; margin-bottom: 12px;">
                            Everyone who consumes packaged products deserves to understand what's inside them.
                        </p>
                        <p style="color: #374151; margin-bottom: 12px;">
                            Ingredient lists can be confusing‚Äîlong chemical names, unfamiliar codes, and tiny print make it hard to know what you're really eating.
                        </p>
                        <p style="color: #374151;">
                            From Delhi to Dubai, Mumbai to Manhattan, Bangalore to Boston‚ÄîEitaki helps you decode ingredients, make intelligent choices, and keep your family safe.
                        </p>
                    </section>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            üíö Why We Exist
                        </h2>
                        <p style="color: #374151;">
                            Reading ingredient labels shouldn't require a chemistry degree. We believe transparency should be accessible to everyone‚Äîwhether you're shopping at a local store or browsing online from your couch.
                        </p>
                    </section>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            üî¨ How It Works
                        </h2>
                        <ol style="padding-left: 20px; color: #374151;">
                            <li style="margin-bottom: 8px;"><strong>Scan</strong>: Point your camera at any ingredient list</li>
                            <li style="margin-bottom: 8px;"><strong>Learn</strong>: Get instant analysis of what's inside</li>
                            <li style="margin-bottom: 8px;"><strong>Decide</strong>: Make informed choices for your family</li>
                            <li><strong>Contribute</strong>: (Optional) Help others by adding products</li>
                        </ol>
                    </section>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            ü§ù Our Values
                        </h2>
                        <div style="margin-bottom: 12px;">
                            <strong style="color: #111827;">üå± Built for Everyone, Everywhere</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">Free ingredient transparency for all</span>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <strong style="color: #111827;">üíö Honest & Transparent</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">We share sources, admit limitations, and never hide our methods</span>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <strong style="color: #111827;">ü§ù Community-Powered</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">Built by people who care, for people who care</span>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <strong style="color: #111827;">üìö Educational, Not Judgmental</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">We provide facts, you make choices</span>
                        </div>
                        <div>
                            <strong style="color: #111827;">üî¨ Evidence-Based</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">Every rating backed by WHO, FSSAI, and peer-reviewed research</span>
                        </div>
                    </section>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            ‚öôÔ∏è The Technology
                        </h2>
                        <p style="color: #374151; margin-bottom: 12px;">
                            Eitaki uses AI technology to read ingredient lists and cross-reference them with health and safety databases.
                        </p>
                        <p style="color: #374151; font-style: italic; font-size: 14px;">
                            Remember: AI accuracy depends on photo quality. Clear photos help us deliver reliable results.
                        </p>
                    </section>
                    
                    <section>
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            üì¨ Get in Touch
                        </h2>
                        <p style="color: #374151; margin-bottom: 12px;">
                            Questions? Feedback? We'd love to hear from you!
                        </p>
                        <a href="https://forms.gle/vnhGDgAVUUeid1SY8" style="color: #16A34A; text-decoration: underline;">
                            Share Feedback
                        </a>
                    </section>
                </div>
                
                <div style="text-align: center; margin-top: 32px;">
                    <button class="btn btn-secondary" onclick="app.showView('home')">‚Üê Back to Home</button>
                </div>
            </div>
        </div>

        <!-- BUG #19: Footer with Legal Disclaimer (shown in analysis view) -->
        <footer id="app-footer" style="display: none; background: #F9FAFB; padding: 24px; text-align: center; border-top: 1px solid #E5E7EB; margin-bottom: 70px;">
            <div style="max-width: 600px; margin: 0 auto;">
                <div style="background: #FEF3C7; border-left: 4px solid #F59E0B; padding: 16px; border-radius: 8px; text-align: left; margin-bottom: 20px;">
                    <strong style="color: #92400E; display: block; margin-bottom: 8px;">
                        ‚ö†Ô∏è IMPORTANT DISCLAIMER
                    </strong>
                    <p style="font-size: 13px; color: #78350F; margin: 0; line-height: 1.6;">
                        Eitaki provides educational information about food ingredients based on publicly available research and regulatory data. This information is NOT medical advice and should not replace consultation with a qualified healthcare professional. By using Eitaki, you acknowledge that you use this information at your own risk.
                    </p>
                </div>
                
                <div style="font-size: 13px; color: #6B7280; margin-bottom: 16px;">
                    <a href="#" onclick="app.showAbout(); return false;" style="color: #16A34A; margin: 0 12px;">About</a>
                    <a href="#" onclick="app.showPrivacyPolicy(); return false;" style="color: #16A34A; margin: 0 12px;">Privacy</a>
                    <a href="#" onclick="app.showTerms(); return false;" style="color: #16A34A; margin: 0 12px;">Terms</a>
                </div>
                
                <div style="font-size: 12px; color: #9CA3AF;">
                    Made with üíö by people who believe you deserve to know what you're consuming
                </div>
            </div>
        </footer>

        <!-- Bottom Navigation -->
        <nav class="bottom-nav" role="navigation" aria-label="Main navigation">
            <button class="nav-item" onclick="app.showView('home')" aria-label="Home">
                <span class="nav-icon" aria-hidden="true">üè†</span>
                <span>Home</span>
            </button>
            <button class="nav-item" onclick="app.showView('scanner')" aria-label="Scan product">
                <span class="nav-icon" aria-hidden="true">üì∏</span>
                <span>Scan</span>
            </button>
            <button class="nav-item" onclick="app.showView('settings')" aria-label="Settings">
                <span class="nav-icon" aria-hidden="true">‚öôÔ∏è</span>
                <span>Settings</span>
            </button>
        </nav>

        
        <!-- Toast Container (v1.2.0) -->
        <div class="toast-container" id="toast-container"></div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loading-overlay" role="alert" aria-live="assertive">
            <div class="loading-content">
                <div class="spinner" aria-hidden="true"></div>
                <div class="loading-text" id="loading-message">Analyzing product...</div>
            </div>
        </div>

        <!-- v1.2.1: Email Verification Modal removed - Phase 1.5 feature -->
    </div>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BUG #2 & #4: Error Codes System for actionable error messages
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const ERROR_CODES = {
            CAMERA_DENIED: {
                code: 'ERR_001',
                title: 'üì∑ Camera Access Needed',
                message: 'Eitaki needs camera access to scan products. Camera permission was previously denied.',
                // Additional Fix #4: Instructions will be set dynamically in showError() based on device
                actions: [], // Populated dynamically by showError() using getCameraPermissionInstructions()
                fallback: 'Or upload a photo from your gallery instead',
                showSettingsButton: true // Additional Fix #4: Show settings redirect button
            },
            CAMERA_UNAVAILABLE: {
                code: 'ERR_002',
                title: 'üì∑ Camera Not Available',
                message: 'Your device camera couldn\'t be accessed.',
                actions: [
                    'Check if another app is using the camera',
                    'Try closing other camera apps',
                    'Restart your browser'
                ],
                fallback: 'You can upload a photo from gallery'
            },
            ANALYSIS_FAILED: {
                code: 'ERR_005',
                title: 'üî¨ Analysis Failed',
                message: 'We couldn\'t analyze this image.',
                actions: [
                    'Check your internet connection',
                    'Try taking a clearer photo',
                    'Make sure the ingredient list is visible'
                ],
                fallback: 'Try uploading from gallery'
            },
            BARCODE_NOT_FOUND: {
                code: 'ERR_003',
                title: 'üìä Product Not Found',
                message: 'This barcode isn\'t in our database yet.',
                actions: [
                    'Try scanning the ingredient list instead',
                    'Help by adding this product later'
                ],
                fallback: 'switchToIngredients',  // v1.2.0: Auto-switch action
                fallbackText: 'üìã Scan Ingredients Instead'
            },
            OCR_NOT_LOADED: {
                code: 'ERR_OCR_INIT',
                title: '‚ö†Ô∏è Scanner Not Ready',
                message: 'The text recognition system is still loading. Please wait a moment and try again.',
                actions: [
                    'Wait 10 seconds for scanner to initialize',
                    'Refresh the page if problem persists',
                    'Check your internet connection (scanner needs to download first time)'
                ],
                fallback: 'If this keeps happening, please contact support with error code ERR_OCR_INIT'
            },
            NETWORK_ERROR: {
                code: 'ERR_NETWORK',
                title: 'üì° Connection Lost',
                message: 'We couldn\'t reach our servers. Check your internet connection.',
                actions: [
                    'Verify you\'re connected to WiFi or mobile data',
                    'Try switching networks',
                    'Restart your browser'
                ],
                fallback: 'Try again when your connection is stable'
            }
        };

        const app = {
            currentView: 'onboarding',
            onboardingStep: 1,
            cameraActive: false,
            cameraPermissionDenied: false, // C2: Cache permission denial
            capturedImages: [],
            stream: null,
            scanCount: 0,
            recentScans: [],
            scanMode: 'ingredients',  // v1.2.0: Default to ingredients mode (our differentiator)
            userSettings: {},
            lastAnalysisConfidence: 100,  // BUG #5: Track confidence for display
            // v1.2.2: Crop state
            cropImageData: null,
            cropScale: 1,
            cropX: 0,
            cropY: 0,
            miniHistoryVisible: true,
            debugMode: true, // DEBUG MODE: Always enabled for troubleshooting
            // Fix #1: Operation guards to prevent concurrent async operations
            isAnalyzing: false,
            isInitializingBarcode: false,
            // Fix #2: Quagga handler cleanup to prevent duplicate event listeners
            quaggaInitialized: false,
            quaggaDetectedHandler: null,
            // Fix #3: Timer tracking to cancel pending operations on navigation
            autoAnalyzeTimer: null,
            cameraStartTimer: null,
            // Additional fixes: Request cancellation
            currentAbortController: null, // For API request cancellation
            ocrCancelled: false, // For OCR cancellation

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // ANALYTICS MODULE - Phase 1 Anonymous Tracking
            // Implemented: 2024-12-19 (Auth Strategy v1.1)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            /**
             * Generates a UUID v4 for anonymous user identification
             * @returns {string} UUID in format xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
             */
            generateUserId() {
                // Use crypto API if available (more secure), fallback to Math.random
                if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                    return crypto.randomUUID();
                }
                // Fallback for older browsers
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            },

            /**
             * Gets or creates the anonymous user profile
             * @returns {Object} User profile with eitaki_uid and metadata
             */
            getUserProfile() {
                try {
                    const stored = localStorage.getItem('eitaki_user_profile');
                    if (stored) {
                        const profile = JSON.parse(stored);
                        // Update last_active on each access
                        profile.last_active = new Date().toISOString();
                        this.safeLocalStorageSet('eitaki_user_profile', JSON.stringify(profile));
                        return profile;
                    }
                    
                    // Create new profile for first-time users
                    const newProfile = {
                        eitaki_uid: this.generateUserId(),
                        created_at: new Date().toISOString(),
                        last_active: new Date().toISOString(),
                        app_version: '1.0.0',  // Update with each release
                        device_category: this.detectDeviceCategory(),
                        scan_count: 0,
                        onboarding_completed: false,
                        // Migration preparation
                        migrated_to_firebase: false,
                        firebase_uid: null
                    };
                    
                    this.safeLocalStorageSet('eitaki_user_profile', JSON.stringify(newProfile));
                    console.log('Created new anonymous user:', newProfile.eitaki_uid);
                    return newProfile;
                    
                } catch (e) {
                    console.error('Failed to get/create user profile:', e);
                    this.logError('ERR_PROFILE', { error: e.message });
                    // Return minimal profile to prevent app crashes
                    return {
                        eitaki_uid: 'error-' + Date.now(),
                        created_at: new Date().toISOString(),
                        last_active: new Date().toISOString(),
                        app_version: '1.0.0',
                        device_category: 'unknown',
                        scan_count: 0,
                        onboarding_completed: false
                    };
                }
            },

            /**
             * Detects device category for analytics
             * @returns {string} 'mobile' | 'tablet' | 'desktop'
             */
            detectDeviceCategory() {
                const ua = navigator.userAgent.toLowerCase();
                if (/mobile|android|iphone|ipod|blackberry|windows phone/i.test(ua)) {
                    return 'mobile';
                }
                if (/ipad|tablet/i.test(ua)) {
                    return 'tablet';
                }
                return 'desktop';
            },

            /**
             * Updates user profile with new data
             * @param {Object} updates - Key-value pairs to update
             */
            updateUserProfile(updates) {
                try {
                    const profile = this.getUserProfile();
                    Object.assign(profile, updates, { last_active: new Date().toISOString() });
                    this.safeLocalStorageSet('eitaki_user_profile', JSON.stringify(profile));
                } catch (e) {
                    console.error('Failed to update user profile:', e);
                    this.logError('ERR_PROFILE_UPDATE', { error: e.message });
                }
            },

            /**
             * Tracks user events for analytics and retention insights
             * Events are stored in FIFO queue (max 100 events)
             * @param {string} eventName - Event identifier
             * @param {Object} metadata - Optional event-specific data
             */
            trackEvent(eventName, metadata = {}) {
                try {
                    const events = this.getEvents();
                    
                    const event = {
                        event: eventName,
                        timestamp: new Date().toISOString(),
                        session_id: this.getSessionId(),
                        metadata: metadata
                    };
                    
                    events.push(event);
                    
                    // FIFO: Keep only last 100 events to manage storage
                    const trimmedEvents = events.slice(-100);
                    
                    this.safeLocalStorageSet('eitaki_events', JSON.stringify(trimmedEvents));
                    
                    // Debug logging (remove in production)
                    if (this.debugMode) {
                        console.log('Event tracked:', eventName, metadata);
                    }
                    
                } catch (e) {
                    console.error('Failed to track event:', e);
                    // Don't call logError here to avoid infinite loop if logError uses trackEvent
                }
            },

            /**
             * Gets all stored events
             * @returns {Array} Array of event objects
             */
            getEvents() {
                try {
                    const stored = localStorage.getItem('eitaki_events');
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    console.error('Failed to get events:', e);
                    return [];
                }
            },

            /**
             * Gets or creates session ID for grouping events
             * Session expires after 30 minutes of inactivity
             * @returns {string} Session identifier
             */
            getSessionId() {
                const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
                
                try {
                    const stored = sessionStorage.getItem('eitaki_session');
                    if (stored) {
                        const session = JSON.parse(stored);
                        const now = Date.now();
                        
                        // Check if session is still valid
                        if (now - session.last_activity < SESSION_TIMEOUT) {
                            session.last_activity = now;
                            sessionStorage.setItem('eitaki_session', JSON.stringify(session));
                            return session.id;
                        }
                    }
                    
                    // Create new session
                    const newSession = {
                        id: 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        started_at: Date.now(),
                        last_activity: Date.now()
                    };
                    sessionStorage.setItem('eitaki_session', JSON.stringify(newSession));
                    
                    // Track session start
                    this.safeLocalStorageSet('eitaki_last_session', new Date().toISOString());
                    
                    return newSession.id;
                    
                } catch (e) {
                    // Fallback if sessionStorage fails
                    return 'sess_' + Date.now();
                }
            },

            /**
             * Predefined event types for consistency
             * Use these constants when calling trackEvent()
             */
            ANALYTICS_EVENTS: {
                // Onboarding
                ONBOARDING_START: 'onboarding_start',
                ONBOARDING_COMPLETE: 'onboarding_complete',
                ONBOARDING_SKIP: 'onboarding_skip',
                
                // Scanning
                SCAN_START: 'scan_start',
                SCAN_COMPLETE: 'scan_complete',
                SCAN_ERROR: 'scan_error',
                SCAN_MODE_CHANGE: 'scan_mode_change',
                
                // Features
                VIEW_CHANGE: 'view_change',
                SETTINGS_SAVE: 'settings_save',
                HISTORY_VIEW: 'history_view',
                METHODOLOGY_VIEW: 'methodology_view',
                
                // Engagement
                APP_OPEN: 'app_open',
                APP_BACKGROUND: 'app_background',
                SHARE_ATTEMPT: 'share_attempt',
                
                // Errors
                ERROR_CAMERA: 'error_camera',
                ERROR_NETWORK: 'error_network',
                ERROR_ANALYSIS: 'error_analysis'
            },

            async init() {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 1: Initialize Analytics (NEW - Auth Strategy v1.1)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // Get or create anonymous user profile
                const profile = this.getUserProfile();
                console.log('Eitaki initialized for user:', profile.eitaki_uid);
                
                // Track app open event
                this.trackEvent(this.ANALYTICS_EVENTS.APP_OPEN, {
                    returning_user: profile.scan_count > 0,
                    device: profile.device_category
                });
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // EXISTING INIT CODE (preserved)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // BUG-008 FIX: Wait for libraries to load
                await this.checkLibrariesReady();
                
                // Check if onboarding already completed
                const onboardingComplete = localStorage.getItem('onboarding_complete');
                if (onboardingComplete === 'true') {
                    this.completeOnboarding();
                    
                    // Track returning user who completed onboarding
                    if (!profile.onboarding_completed) {
                        this.updateUserProfile({ onboarding_completed: true });
                    }
                } else {
                    // Track onboarding start for new users
                    this.trackEvent(this.ANALYTICS_EVENTS.ONBOARDING_START);
                }
                
                this.scanCount = parseInt(localStorage.getItem('scan_count') || '0');
                this.loadRecentScans();
                this.loadSettings();
                this.setupEventListeners();
                this.updateScanHistoryDisplay();  // BUG #11: Show scan history
                this.miniHistoryVisible = localStorage.getItem('miniHistoryVisible') !== 'false';
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 1: Load enhanced scan history (NEW)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // Migrate legacy scan history if needed
                this.migrateLegacyScanHistory();
                
                // Generate initial insights (for debugging)
                if (this.debugMode) {
                    const insights = this.getInsights();
                    console.log('User insights:', insights);
                }
            },

            setupEventListeners() {
                // BUG-012 FIX: Use capturePhoto() directly instead of legacy alias
                document.getElementById('capture-btn')?.addEventListener('click', () => this.capturePhoto());
            },

            loadSettings() {
                try {
                    const saved = localStorage.getItem('user_settings');
                    if (saved) {
                        this.userSettings = JSON.parse(saved);
                        // Populate form fields - BUG #11: Removed email and dietary preferences
                        if (document.getElementById('setting-name')) {
                            document.getElementById('setting-name').value = this.userSettings.name || '';
                            document.getElementById('setting-allergies').value = this.userSettings.allergies || '';
                        }
                    }
                } catch (e) {
                    console.error('Failed to load settings:', e);
                    this.userSettings = {};
                }
            },


            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // V1.2.0 NEW FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            QUALITY_THRESHOLDS: { AUTO_ANALYZE: 95, GOOD: 85, ACCEPTABLE: 80, MARGINAL: 75 },
            photoAttempts: 0,
            maxPhotos: 3,
            
            // BUG-008 FIX: Check if scanning libraries are loaded
            async checkLibrariesReady() {
                const maxWait = 10000; // 10 seconds timeout
                const startTime = Date.now();
                
                // Show loading indicator
                this.showToast('Loading scanning tools...', 'info', 10000);
                
                while (Date.now() - startTime < maxWait) {
                    if (typeof Tesseract !== 'undefined' && typeof Quagga !== 'undefined') {
                        this.showToast('Scanner ready! üì∏', 'success');
                        return true;
                    }
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Timeout - libraries didn't load
                // Additional Fix #3: Improved timeout message with clear action
                this.showToast('Scanner tools are taking longer than expected. Please refresh the page to try again.', 'warning', 8000);
                this.logError('ERR_LIB_TIMEOUT', { tesseract: typeof Tesseract, quagga: typeof Quagga });
                
                // Show more detailed error to help user
                setTimeout(() => {
                    this.showError('OCR_NOT_LOADED', {
                        message: 'Scanner libraries failed to load within 10 seconds. This usually means a slow internet connection.',
                        action: 'Please refresh the page (pull down to refresh on mobile) and wait for libraries to load.'
                    });
                }, 2000);
                
                return false;
            },
            
            toggleModeMenu() {
                const menu = document.getElementById('mode-menu');
                const badge = document.getElementById('mode-badge');
                const isVisible = menu?.classList.toggle('visible');
                badge?.classList.toggle('menu-open');
                
                // BUG-015 FIX: Update ARIA state for accessibility
                badge?.setAttribute('aria-expanded', isVisible);
                
                if (!localStorage.getItem('mode_badge_discovered')) {
                    this.safeLocalStorageSet('mode_badge_discovered', 'true');
                    badge?.classList.remove('pulsing');
                }
            },
            
            selectMode(mode) {
                this.scanMode = mode;
                this.safeLocalStorageSet('scan_mode', mode);
                this.updateModeUI();
                document.getElementById('mode-menu')?.classList.remove('visible');
                document.getElementById('mode-badge')?.classList.remove('menu-open');
                this.showToast(`Switched to ${mode === 'barcode' ? 'Barcode' : 'Ingredients'} mode`);
            },
            
            updateModeUI() {
                const icon = document.getElementById('mode-badge-icon');
                const text = document.getElementById('mode-badge-text');
                if (this.scanMode === 'ingredients') {
                    if (icon) icon.textContent = 'üìã';
                    if (text) text.textContent = 'Ingredients';
                    document.getElementById('menu-ingredients')?.classList.add('active');
                    document.getElementById('menu-barcode')?.classList.remove('active');
                } else {
                    if (icon) icon.textContent = 'üìä';
                    if (text) text.textContent = 'Barcode';
                    document.getElementById('menu-barcode')?.classList.add('active');
                    document.getElementById('menu-ingredients')?.classList.remove('active');
                }
            },
            
            showToast(message, type = 'info', duration = 3000) {
                const container = document.getElementById('toast-container');
                if (!container) return;
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                container.appendChild(toast);
                requestAnimationFrame(() => toast.classList.add('visible'));
                setTimeout(() => { toast.classList.remove('visible'); setTimeout(() => toast.remove(), 300); }, duration);
            },
            
            async checkPhotoQuality(imageData) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const scale = Math.min(200 / img.width, 200 / img.height);
                        canvas.width = img.width * scale;
                        canvas.height = img.height * scale;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                        let totalBrightness = 0;
                        for (let i = 0; i < data.length; i += 4) totalBrightness += (0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2]);
                        const avgBrightness = totalBrightness / (data.length / 4);
                        const brightnessScore = Math.min(100, (avgBrightness / 128) * 100);
                        let sumSquares = 0;
                        for (let i = 0; i < data.length; i += 4) { const lum = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2]; sumSquares += Math.pow(lum - avgBrightness, 2); }
                        const contrastScore = Math.min(100, (Math.sqrt(sumSquares / (data.length / 4)) / 50) * 100);
                        let laplacianSum = 0;
                        for (let y = 1; y < canvas.height - 1; y++) for (let x = 1; x < canvas.width - 1; x++) { const idx = (y * canvas.width + x) * 4; laplacianSum += Math.abs(4*data[idx] - data[idx-4] - data[idx+4] - data[idx-canvas.width*4] - data[idx+canvas.width*4]); }
                        const sharpnessScore = Math.min(100, (laplacianSum / ((canvas.width-2) * (canvas.height-2))) * 2);
                        resolve({ score: Math.round(0.4*sharpnessScore + 0.3*brightnessScore + 0.3*contrastScore) });
                    };
                    img.src = imageData;
                });
            },
            
            async handleQualityResult(quality, imageData) {
                this.photoAttempts++;
                const T = this.QUALITY_THRESHOLDS;
                if (quality.score >= T.AUTO_ANALYZE) { 
                    this.capturedImages.push(imageData); 
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    this.autoAnalyze(); 
                }
                else if (quality.score >= T.GOOD) { 
                    this.capturedImages.push(imageData); 
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    this.showToast('Great photo! üì∏', 'success'); 
                }
                else if (quality.score >= T.ACCEPTABLE) { 
                    this.capturedImages.push(imageData); 
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                }
                else if (quality.score >= T.MARGINAL && this.photoAttempts > 1) { 
                    if (confirm('Photo quality is marginal. Continue anyway?')) { 
                        this.capturedImages.push(imageData); 
                        this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                        this.showToast('Photo added with warning', 'warning'); 
                    } 
                }
                else { 
                    this.showToast('Photo too blurry. Please retake.', 'error'); 
                }
            },
            
            autoAnalyze() {
                // Fix #1: Prevent concurrent analysis operations
                if (this.isAnalyzing) {
                    console.log('Analysis already in progress, skipping auto-analyze');
                    return;
                }
                // Fix #3: Clear any existing auto-analyze timer before setting new one
                if (this.autoAnalyzeTimer) {
                    clearTimeout(this.autoAnalyzeTimer);
                    this.autoAnalyzeTimer = null;
                }
                const badge = document.getElementById('auto-analyze-badge');
                badge?.classList.add('visible');
                // Fix #3: Store timer ID so we can cancel it if user navigates away
                this.autoAnalyzeTimer = setTimeout(() => {
                    badge?.classList.remove('visible');
                    this.autoAnalyzeTimer = null; // Clear reference after execution
                    this.analyzeProduct();
                }, 800);
            },
            
            updatePhotoCountBadge() {
                const badge = document.getElementById('photo-count-badge');
                if (badge) { badge.textContent = this.capturedImages.length; badge.style.display = this.capturedImages.length > 0 ? 'flex' : 'none'; }
            },
            
            // Fix #4: Centralized function to update capturedImages state and sync all UI elements
            updateCapturedImagesState() {
                // Update the visual display of images
                this.renderCapturedImages();
                
                // Update photo count badge
                this.updatePhotoCountBadge();
                
                // Update analyze button state - enabled if photos exist, disabled if empty
                const analyzeBtn = document.getElementById('analyze-btn-bar');
                if (analyzeBtn) {
                    analyzeBtn.disabled = this.capturedImages.length === 0;
                }
            },
            
            openGallery() {
                const input = document.createElement('input');
                input.type = 'file'; input.accept = 'image/*';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            if (this.capturedImages.length < this.maxPhotos) {
                                this.capturedImages.push(ev.target.result);
                                this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                                this.showToast('Photo added', 'success');
                            } else { this.showToast('Maximum 3 photos', 'warning'); }
                        };
                        reader.readAsDataURL(file);
                    }
                };
                input.click();
            },
            
            toggleExplainer() { document.getElementById('score-explainer')?.classList.toggle('visible'); },
            
            saveSettings() {
                // BUG #11: Simplified profile - removed email and dietary preferences
                this.userSettings = {
                    name: document.getElementById('setting-name').value,
                    allergies: document.getElementById('setting-allergies').value
                };
                this.safeLocalStorageSet('user_settings', JSON.stringify(this.userSettings));
                this.showToast('Settings saved! ‚úì', 'success');
            },

            clearAllData() {
                if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                    localStorage.clear();
                    this.showToast('All data cleared. Reloading...', 'success');
                    setTimeout(() => location.reload(), 1500);
                }
            },

            // Onboarding Flow
            nextOnboarding() {
                const currentScreen = document.getElementById(`onboarding-${this.onboardingStep}`);
                currentScreen.classList.remove('active');
                
                this.onboardingStep++;
                const nextScreen = document.getElementById(`onboarding-${this.onboardingStep}`);
                nextScreen.classList.add('active');
            },

            completeOnboarding() {
                this.safeLocalStorageSet('onboarding_complete', 'true');
                
                // Track onboarding completion (NEW - Auth Strategy v1.1)
                this.trackEvent(this.ANALYTICS_EVENTS.ONBOARDING_COMPLETE);
                this.updateUserProfile({ onboarding_completed: true });
                
                this.showView('home');
            },

            // View Management
            showView(viewName) {
                // Fix #3: Cancel pending timers before switching views
                if (this.autoAnalyzeTimer) {
                    clearTimeout(this.autoAnalyzeTimer);
                    this.autoAnalyzeTimer = null;
                }
                if (this.cameraStartTimer) {
                    clearTimeout(this.cameraStartTimer);
                    this.cameraStartTimer = null;
                }
                
                // Additional Fix #1: Cancel in-flight API requests if user navigates away
                if (this.currentAbortController) {
                    this.currentAbortController.abort();
                    this.currentAbortController = null;
                }
                
                // Additional Fix #2: Cancel OCR processing if user navigates away
                if (this.isAnalyzing) {
                    this.ocrCancelled = true;
                }
                
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                
                const view = document.getElementById(`view-${viewName}`);
                if (view) {
                    view.classList.add('active');
                }
                
                const navItem = document.querySelector(`.nav-item[onclick*="${viewName}"]`);
                if (navItem) {
                    navItem.classList.add('active');
                }
                
                this.currentView = viewName;
                
                // Scanner view specific logic (v1.2.0)
                if (viewName === 'scanner') {
                    document.getElementById('mode-badge')?.classList.add('visible');
                    document.getElementById('scanner-bottom-bar')?.classList.add('visible');
                    this.updateModeUI();
                    this.photoAttempts = 0;
                    this.capturedImages = []; // Reset captured images
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    // v1.2.0: Auto-start camera (removed Start Camera button)
                    // Fix #3: Store timer ID so we can cancel it if user navigates away quickly
                    this.cameraStartTimer = setTimeout(() => {
                        this.cameraStartTimer = null; // Clear reference after execution
                        this.startCamera();
                    }, 300);
                    // v1.2.2: Show mini history on scanner page
                    this.updateMiniHistory();
                } else {
                    document.getElementById('mode-badge')?.classList.remove('visible');
                    document.getElementById('mode-menu')?.classList.remove('visible');
                    document.getElementById('scanner-bottom-bar')?.classList.remove('visible');
                    document.getElementById('scanner-mini-history')?.classList.remove('visible');
                    // Stop camera when leaving scanner
                    this.stopCamera();
                }
                
                // Load settings when viewing settings page
                if (viewName === 'settings') {
                    this.loadSettings();
                }
                
                // Track view change event (NEW - Auth Strategy v1.1)
                this.trackEvent(this.ANALYTICS_EVENTS.VIEW_CHANGE, {
                    from: this.currentView,
                    to: viewName
                });
            },

            // v1.2.1: setScanMode() removed - using selectMode() only

            // v1.2.0: Camera Functions - Auto-start, no toggle button
            async startCamera() {
                // Fix #5: Check if camera is already active
                if (this.cameraActive) return; // Already running
                
                // Fix #5: Verify we're still in scanner view before starting camera
                // This prevents camera from starting if user navigated away during the setTimeout delay
                if (this.currentView !== 'scanner') {
                    console.log('Not in scanner view, cancelling camera start');
                    return;
                }
                
                // C2: Check if permission was previously denied
                if (this.cameraPermissionDenied) {
                    this.showError('CAMERA_DENIED');
                    return;
                }
                
                const video = document.getElementById('camera-video');
                const placeholder = document.getElementById('camera-placeholder');
                const overlay = document.getElementById('camera-overlay');

                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } } 
                    });
                    
                    // Fix #5: Double-check we're still in scanner view after async getUserMedia completes
                    // User might have navigated away during the permission prompt or camera initialization
                    if (this.currentView !== 'scanner') {
                        console.log('User navigated away during camera start, cleaning up');
                        // Clean up the stream we just got
                        if (this.stream) {
                            this.stream.getTracks().forEach(track => track.stop());
                            this.stream = null;
                        }
                        return;
                    }
                    
                    video.srcObject = this.stream;
                    video.style.display = 'block';
                    placeholder.style.display = 'none';
                    overlay.style.display = 'flex';
                    
                    // Fix #5: Only set cameraActive if we're still in scanner view
                    this.cameraActive = true;
                    this.hideError();  // Clear any previous errors
                    
                    // Start barcode detection if in barcode mode
                    if (this.scanMode === 'barcode') {
                        this.startBarcodeDetection();
                    }
                    
                    // Update scan guide based on mode
                    const guideText = document.getElementById('scan-guide-text');
                    if (guideText) {
                        guideText.textContent = this.scanMode === 'barcode' 
                            ? 'üìä Point at barcode for instant lookup'
                            : 'üìã Point at ingredient list';
                    }
                } catch (err) {
                    // Fix #5: Ensure cameraActive is explicitly false on error
                    this.cameraActive = false;
                    
                    // BUG #2: Show actionable error instead of generic alert
                    this.logError('CAMERA_ERROR', { name: err.name, message: err.message });
                    if (err.name === 'NotAllowedError') {
                        this.cameraPermissionDenied = true; // C2: Cache denial
                        this.showError('CAMERA_DENIED');
                    } else if (err.name === 'NotFoundError') {
                        this.showError('CAMERA_UNAVAILABLE');
                    } else {
                        this.showError('CAMERA_UNAVAILABLE');
                    }
                    console.error('Camera error:', err);
                }
            },

            // Additional Fix #4: Detect device and get camera permission instructions
            getCameraPermissionInstructions() {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                
                if (isIOS) {
                    return [
                        '1. Open iPhone Settings app',
                        '2. Scroll down and tap "Safari" (or your browser)',
                        '3. Tap "Camera" under Permissions',
                        '4. Enable camera access for Eitaki',
                        '5. Return to Eitaki and try again'
                    ];
                } else if (isAndroid) {
                    return [
                        '1. Open your phone Settings app',
                        '2. Go to "Apps" or "App permissions"',
                        '3. Find your browser (Chrome, etc.)',
                        '4. Tap "Permissions" ‚Üí "Camera"',
                        '5. Enable camera access',
                        '6. Return to Eitaki and try again'
                    ];
                } else {
                    // Desktop/other browsers
                    return [
                        '1. Tap your browser settings (‚ãÆ)',
                        '2. Find "Site settings" or "Permissions"',
                        '3. Enable Camera for this site',
                        '4. Refresh and try again'
                    ];
                }
            },
            
            // Additional Fix #4: Open device settings (works on some mobile browsers)
            openDeviceSettings() {
                // Try to open settings - this works on some mobile browsers
                // iOS Safari: Can't programmatically open Settings, but we show instructions
                // Android Chrome: May work in some cases
                if (/Android/.test(navigator.userAgent)) {
                    // Android - try to open app settings
                    try {
                        // Some Android browsers support this
                        window.location.href = 'intent://settings#Intent;scheme=android-app;end';
                    } catch(e) {
                        // Fallback: Show instructions
                        this.showToast('Please open Settings manually and enable camera permission for your browser', 'info', 6000);
                    }
                } else {
                    // iOS or desktop - show instructions
                    this.showToast('Please open Settings manually using the instructions above', 'info', 6000);
                }
            },
            
            // BUG #2: Error display function
            // v1.2.0: Enhanced error display with auto-switch support
            // DEBUG MODE: Shows detailed error info
            showError(errorType, debugInfo = null) {
                const error = ERROR_CODES[errorType];
                if (!error) {
                    console.error('Unknown error type:', errorType);
                    return;
                }
                
                // Additional Fix #4: Get device-specific instructions for camera permission
                const errorWithActions = { ...error };
                if (errorType === 'CAMERA_DENIED') {
                    errorWithActions.actions = this.getCameraPermissionInstructions();
                }
                
                // Log error
                this.logError(error.code, { type: errorType, debugInfo });
                
                // DEBUG INFO: Build debug section if available
                let debugSection = '';
                if (debugInfo) {
                    const debugDetails = typeof debugInfo === 'string' ? debugInfo : JSON.stringify(debugInfo, null, 2);
                    debugSection = `
                        <details style="text-align: left; margin: 16px 0; padding: 12px; background: #FEF3C7; border-radius: 8px; border: 1px solid #FCD34D;">
                            <summary style="cursor: pointer; font-weight: 600; color: #92400E; margin-bottom: 8px;">
                                üîç Debug Info (Tap to expand)
                            </summary>
                            <pre style="font-size: 11px; color: #78350F; white-space: pre-wrap; word-wrap: break-word; margin: 8px 0 0 0; font-family: monospace; background: white; padding: 8px; border-radius: 4px; overflow-x: auto;">${debugDetails}</pre>
                            <button onclick="app.copyDebugInfo('${debugDetails.replace(/'/g, "\\'")}'); event.stopPropagation();" style="margin-top: 8px; padding: 6px 12px; background: #F59E0B; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                                üìã Copy Debug Info
                            </button>
                        </details>
                    `;
                }
                
                // Determine fallback button based on error type
                let fallbackButton = '';
                if (errorWithActions.fallback === 'switchToIngredients') {
                    // v1.2.0: Auto-switch to ingredients mode
                    fallbackButton = `
                        <button class="btn btn-secondary" onclick="app.switchToIngredientsMode()" style="margin-bottom: 12px; width: 100%;">
                            ${errorWithActions.fallbackText || 'üìã Scan Ingredients Instead'}
                        </button>
                    `;
                } else if (errorWithActions.fallback) {
                    fallbackButton = `
                        <p style="font-size: 14px; color: #64748B; margin-bottom: 16px;">
                            ${errorWithActions.fallback}
                        </p>
                        <button class="btn btn-secondary" onclick="app.useGalleryFallback()" style="margin-bottom: 12px; width: 100%;">
                            üìÅ Upload from Gallery
                        </button>
                    `;
                }
                
                const html = `
                    <div style="padding: 24px; text-align: center; max-width: 400px; margin: 20px auto;">
                        <div style="font-size: 48px; margin-bottom: 16px;">${errorWithActions.title.split(' ')[0]}</div>
                        <h3 style="font-size: 20px; font-weight: 700; color: #1E293B; margin-bottom: 12px;">
                            ${errorWithActions.title.substring(errorWithActions.title.indexOf(' ') + 1)}
                        </h3>
                        <p style="color: #64748B; margin-bottom: 24px; line-height: 1.6;">
                            ${errorWithActions.message}
                        </p>
                        
                        <div style="background: #F0FDF4; padding: 16px; border-radius: 12px; margin-bottom: 20px; text-align: left;">
                            <strong style="color: #16A34A; display: block; margin-bottom: 8px;">How to fix:</strong>
                            <ul style="margin: 0; padding-left: 20px; color: #475569;">
                                ${errorWithActions.actions.map(action => `<li style="margin: 6px 0;">${action}</li>`).join('')}
                            </ul>
                        </div>
                        
                        ${debugSection}
                        
                        ${fallbackButton}
                        
                        ${errorType === 'CAMERA_DENIED' ? `
                        <button class="btn btn-primary" onclick="app.openDeviceSettings()" style="width: 100%; margin-bottom: 12px; background: #16A34A;">
                            ‚öôÔ∏è Open Settings
                        </button>
                        ` : ''}
                        
                        <button class="btn btn-primary" onclick="app.retryCamera()" style="width: 100%;">
                            üîÑ Try Again
                        </button>
                        
                        <p style="font-size: 12px; color: #94A3B8; margin-top: 16px;">
                            Error Code: ${errorWithActions.code}
                        </p>
                    </div>
                `;
                
                const resultContainer = document.getElementById('scanner-result');
                resultContainer.innerHTML = html;
                resultContainer.style.display = 'block';
            },

            // v1.2.0: Switch to ingredients mode (called from barcode not found error)
            switchToIngredientsMode() {
                this.hideError();
                this.selectMode('ingredients');
                this.showToast('Switched to Ingredients mode. Point at ingredient list.', 'success');
                // Camera is already running, just update the guide
                const guideText = document.getElementById('scan-guide-text');
                if (guideText) {
                    guideText.textContent = 'üìã Point at ingredient list - any language';
                }
            },

            hideError() {
                const resultContainer = document.getElementById('scanner-result');
                if (resultContainer) {
                    resultContainer.style.display = 'none';
                    resultContainer.innerHTML = '';
                }
            },

            retryCamera() {
                this.hideError();
                
                // Additional Fix #4: On iOS, once permission is denied, OS won't allow asking again
                // On Android, browser may allow asking again, but for consistency, we'll try once more
                // If it fails again, user must go to Settings
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                
                if (isIOS && this.cameraPermissionDenied) {
                    // iOS: Can't ask again, must go to Settings
                    this.showError('CAMERA_DENIED');
                    this.showToast('On iOS, you must enable camera in Settings. Tap "Open Settings" above.', 'info', 6000);
                } else {
                    // Android or first attempt: Try asking again
                    this.cameraPermissionDenied = false;
                    this.startCamera();
                }
            },

            // BUG #2: Gallery fallback handler
            useGalleryFallback() {
                this.hideError();
                document.getElementById('file-input-fallback').click();
            },
            
            // DEBUG MODE: Copy debug info to clipboard
            copyDebugInfo(debugText) {
                try {
                    // Try modern clipboard API
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(debugText).then(() => {
                            this.showToast('Debug info copied! üìã', 'success', 2000);
                        }).catch(() => {
                            // Fallback for iOS Safari
                            this.fallbackCopy(debugText);
                        });
                    } else {
                        this.fallbackCopy(debugText);
                    }
                } catch (e) {
                    console.error('Copy failed:', e);
                    this.showToast('Could not copy. Please screenshot instead.', 'warning', 3000);
                }
            },
            
            // Fallback copy method for iOS
            fallbackCopy(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    this.showToast('Debug info copied! üìã', 'success', 2000);
                } catch (err) {
                    this.showToast('Could not copy. Please screenshot instead.', 'warning', 3000);
                }
                document.body.removeChild(textArea);
            },

            handleGalleryUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Check max photos limit
                if (this.capturedImages.length >= 3) {
                    this.showToast('Maximum 3 photos allowed', 'warning');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    // v1.2.2: Open crop modal instead of adding directly
                    this.openCropModal(e.target.result);
                };
                reader.onerror = () => {
                    this.showToast('Failed to load image', 'error');
                };
                reader.readAsDataURL(file);
            },
            
            // v1.2.2: Crop Modal Functions
            openCropModal(imageData) {
                this.cropImageData = imageData;
                this.cropScale = 1;
                this.cropX = 0;
                this.cropY = 0;
                
                const modal = document.getElementById('crop-modal');
                const img = document.getElementById('crop-image');
                
                img.src = imageData;
                modal.classList.add('active');
                
                // Setup touch handlers for pinch-zoom and drag
                this.setupCropHandlers();
            },
            
            setupCropHandlers() {
                const container = document.getElementById('crop-container');
                const img = document.getElementById('crop-image');
                
                let startDistance = 0;
                let startScale = 1;
                let startX = 0;
                let startY = 0;
                let isDragging = false;
                
                // Touch start
                container.ontouchstart = (e) => {
                    if (e.touches.length === 2) {
                        // Pinch start
                        startDistance = Math.hypot(
                            e.touches[0].pageX - e.touches[1].pageX,
                            e.touches[0].pageY - e.touches[1].pageY
                        );
                        startScale = this.cropScale;
                    } else if (e.touches.length === 1) {
                        // Drag start
                        isDragging = true;
                        startX = e.touches[0].pageX - this.cropX;
                        startY = e.touches[0].pageY - this.cropY;
                    }
                };
                
                // Touch move
                container.ontouchmove = (e) => {
                    e.preventDefault();
                    if (e.touches.length === 2) {
                        // Pinch zoom
                        const distance = Math.hypot(
                            e.touches[0].pageX - e.touches[1].pageX,
                            e.touches[0].pageY - e.touches[1].pageY
                        );
                        this.cropScale = Math.max(0.5, Math.min(3, startScale * (distance / startDistance)));
                        this.updateCropTransform();
                    } else if (e.touches.length === 1 && isDragging) {
                        // Drag
                        this.cropX = e.touches[0].pageX - startX;
                        this.cropY = e.touches[0].pageY - startY;
                        this.updateCropTransform();
                    }
                };
                
                // Touch end
                container.ontouchend = () => {
                    isDragging = false;
                };
                
                // Mouse support for desktop
                let isMouseDown = false;
                container.onmousedown = (e) => {
                    isMouseDown = true;
                    startX = e.pageX - this.cropX;
                    startY = e.pageY - this.cropY;
                };
                container.onmousemove = (e) => {
                    if (isMouseDown) {
                        this.cropX = e.pageX - startX;
                        this.cropY = e.pageY - startY;
                        this.updateCropTransform();
                    }
                };
                container.onmouseup = () => { isMouseDown = false; };
                container.onmouseleave = () => { isMouseDown = false; };
                
                // Mouse wheel for zoom
                container.onwheel = (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.cropScale = Math.max(0.5, Math.min(3, this.cropScale * delta));
                    this.updateCropTransform();
                };
            },
            
            updateCropTransform() {
                const img = document.getElementById('crop-image');
                img.style.transform = `translate(${this.cropX}px, ${this.cropY}px) scale(${this.cropScale})`;
            },
            
            cancelCrop() {
                document.getElementById('crop-modal').classList.remove('active');
                this.cropImageData = null;
            },
            
            applyCrop() {
                // Delegate to the unified function
                this.applyCropForEdit();
            },
            
            // v1.2.2: Mini History Functions
            updateMiniHistory() {
                const container = document.getElementById('scanner-mini-history');
                const list = document.getElementById('mini-history-list');
                
                if (!container || !list) return;
                
                // Only show if there are scans and user hasn't hidden it
                if (this.recentScans.length === 0 || !this.miniHistoryVisible) {
                    container.classList.remove('visible');
                    return;
                }
                
                container.classList.add('visible');
                
                // Show last 3 scans
                const recentThree = this.recentScans.slice(0, 3);
                list.innerHTML = recentThree.map((scan, idx) => `
                    <div class="mini-history-item" onclick="app.viewScanFromHistory(${idx})">
                        <div class="mini-history-score">${scan.score || '?'}</div>
                        <div class="mini-history-name">${scan.name || 'Unknown'}</div>
                    </div>
                `).join('');
            },
            
            toggleMiniHistory() {
                this.miniHistoryVisible = !this.miniHistoryVisible;
                this.safeLocalStorageSet('miniHistoryVisible', this.miniHistoryVisible);
                
                const container = document.getElementById('scanner-mini-history');
                const toggle = container?.querySelector('.mini-history-toggle');
                
                if (this.miniHistoryVisible) {
                    container?.classList.add('visible');
                    if (toggle) toggle.textContent = 'Hide';
                } else {
                    container?.classList.remove('visible');
                    if (toggle) toggle.textContent = 'Show';
                }
            },
            
            viewScanFromHistory(index) {
                const scan = this.recentScans[index];
                if (scan && scan.analysis) {
                    this.stopCamera();
                    this.showAnalysis(scan.analysis);
                    this.showView('analysis');
                } else {
                    this.showToast('Scan details not available', 'warning');
                }
            },
            
            // v1.2.2: Crop an already captured image
            cropExistingImage(index) {
                if (index >= 0 && index < this.capturedImages.length) {
                    this.cropEditIndex = index;
                    this.openCropModal(this.capturedImages[index]);
                }
            },
            
            // Modified applyCrop to handle editing existing images
            applyCropForEdit() {
                // Same as applyCrop but replaces instead of adds
                const img = document.getElementById('crop-image');
                const container = document.getElementById('crop-container');
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const containerRect = container.getBoundingClientRect();
                canvas.width = containerRect.width;
                canvas.height = containerRect.height;
                
                const tempImg = new Image();
                tempImg.onload = () => {
                    const imgRect = img.getBoundingClientRect();
                    
                    const sx = (containerRect.left - imgRect.left) / this.cropScale;
                    const sy = (containerRect.top - imgRect.top) / this.cropScale;
                    const sw = containerRect.width / this.cropScale;
                    const sh = containerRect.height / this.cropScale;
                    
                    ctx.drawImage(tempImg, 
                        Math.max(0, sx), Math.max(0, sy), 
                        Math.min(tempImg.width, sw), Math.min(tempImg.height, sh),
                        0, 0, canvas.width, canvas.height
                    );
                    
                    const croppedData = canvas.toDataURL('image/jpeg', 0.9);
                    
                    // Replace the existing image
                    if (this.cropEditIndex !== undefined && this.cropEditIndex >= 0) {
                        this.capturedImages[this.cropEditIndex] = croppedData;
                        this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                        this.showToast('Photo cropped! ‚úÇÔ∏è', 'success');
                        this.cropEditIndex = undefined;
                    } else {
                        // Add as new
                        this.capturedImages.push(croppedData);
                        this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                        this.showToast(`Photo ${this.capturedImages.length} cropped & added! ‚úÇÔ∏è`, 'success');
                    }
                    
                    this.cancelCrop();
                };
                tempImg.src = this.cropImageData;
            },

            stopCamera() {
                const video = document.getElementById('camera-video');
                const placeholder = document.getElementById('camera-placeholder');
                const overlay = document.getElementById('camera-overlay');
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                if (video) video.style.display = 'none';
                if (placeholder) placeholder.style.display = 'flex';
                if (overlay) overlay.style.display = 'none';
                this.cameraActive = false;
                
                // Fix #2: Cleanup Quagga handlers before stopping
                if (window.Quagga) {
                    // Remove the onDetected handler if it exists
                    if (this.quaggaDetectedHandler) {
                        try {
                            Quagga.offDetected(this.quaggaDetectedHandler);
                        } catch(e) {
                            console.warn('Failed to remove Quagga handler:', e);
                        }
                        this.quaggaDetectedHandler = null;
                    }
                    // Stop Quagga
                    try {
                        Quagga.stop();
                    } catch(e) {
                        console.warn('Failed to stop Quagga:', e);
                    }
                    this.quaggaInitialized = false;
                }
            },

            startBarcodeDetection() {
                if (!window.Quagga) return;
                
                // Fix #1: Prevent concurrent Quagga initialization
                if (this.isInitializingBarcode) {
                    console.log('Barcode detection already initializing, skipping');
                    return;
                }
                
                // Fix #7: Prevent re-initialization if Quagga is already initialized and running
                // This coordinates with Fix #2 - only re-initialize if we need to (e.g., after cleanup)
                if (this.quaggaInitialized) {
                    // Check if Quagga is actually running by verifying handler exists
                    if (this.quaggaDetectedHandler) {
                        console.log('Quagga already initialized and running, skipping re-initialization');
                        return;
                    }
                    // If initialized but no handler, something went wrong - cleanup and re-init
                    try {
                        Quagga.stop();
                    } catch(e) {
                        console.warn('Failed to stop Quagga during cleanup:', e);
                    }
                    this.quaggaInitialized = false;
                }
                
                // Fix #2: Cleanup existing handlers before re-initializing (if we get here, we need to re-init)
                if (this.quaggaDetectedHandler) {
                    try {
                        Quagga.offDetected(this.quaggaDetectedHandler);
                        Quagga.stop();
                    } catch(e) {
                        console.warn('Failed to cleanup existing Quagga instance:', e);
                    }
                    this.quaggaDetectedHandler = null;
                    this.quaggaInitialized = false;
                }
                
                this.isInitializingBarcode = true;
                
                Quagga.init({
                    inputStream: {
                        type: "LiveStream",
                        target: document.querySelector('#camera-video'),
                        constraints: {
                            facingMode: "environment"
                        }
                    },
                    decoder: {
                        readers: ["ean_reader", "ean_8_reader", "upc_reader"]
                    },
                    locate: true
                }, (err) => {
                    if (!err) {
                        Quagga.start();
                        this.isInitializingBarcode = false; // Fix #1: Reset flag after successful init
                        this.quaggaInitialized = true; // Fix #2: Mark as initialized
                    } else {
                        this.isInitializingBarcode = false; // Fix #1: Reset flag on error
                        this.quaggaInitialized = false; // Fix #2: Ensure flag is false on error
                    }
                });

                // Fix #2: Store handler reference so we can remove it later
                this.quaggaDetectedHandler = async (result) => {
                    const barcode = result.codeResult.code;
                    console.log("Barcode detected:", barcode);
                    
                    // Stop camera and barcode detection
                    this.stopCamera();
                    
                    // Try Open Food Facts first
                    this.showLoading('Looking up product...');
                    
                    try {
                        // Additional Fix #1: Create AbortController for barcode lookup
                        this.currentAbortController = new AbortController();
                        const offData = await this.queryOpenFoodFacts(barcode, this.currentAbortController.signal);
                        this.currentAbortController = null; // Clear after request completes
                        
                        if (offData && offData.found) {
                            this.hideLoading();
                            const analysis = this.convertOFFToAnalysis(offData);
                            this.showAnalysis(analysis);
                            this.addToRecentScans(analysis);
                        } else {
                            this.hideLoading();
                            // BUG #4: Better error message for product not found
                            this.showError('BARCODE_NOT_FOUND');
                        }
                    } catch (error) {
                        // Additional Fix #1: Handle cancellation silently
                        if (error.name === 'AbortError') {
                            console.log('Barcode lookup cancelled - user navigated away');
                            this.hideLoading();
                            this.currentAbortController = null;
                            return;
                        }
                        // Re-throw other errors
                        this.hideLoading();
                        throw error;
                    }
                };
                
                // Fix #2: Register the stored handler
                Quagga.onDetected(this.quaggaDetectedHandler);
            },

            // v1.2.1: New capturePhoto() function with quality check and max limit
            capturePhoto() {
                // D3: Enforce 3-photo max
                if (this.capturedImages.length >= 3) {
                    this.showToast('Maximum 3 photos allowed', 'warning');
                    return;
                }
                
                const video = document.getElementById('camera-video');
                
                // Check video is fully ready
                if (!video || !this.cameraActive) {
                    this.showToast('Camera not ready. Please wait...', 'error');
                    return;
                }
                
                // Check video has actual content (not just a black frame)
                if (video.videoWidth === 0 || video.videoHeight === 0) {
                    this.showToast('Camera still loading...', 'warning');
                    return;
                }
                
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    
                    const imageData = canvas.toDataURL('image/jpeg', 0.9);
                    
                    // Verify we got actual image data (not empty)
                    if (imageData.length < 1000) {
                        this.showToast('Capture failed. Please try again.', 'error');
                        return;
                    }
                    
                    this.capturedImages.push(imageData);
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    this.showToast(`Photo ${this.capturedImages.length} captured! üì∏`, 'success');
                } catch (e) {
                    console.error('Capture error:', e);
                    this.showToast('Capture failed. Please try again.', 'error');
                }
            },

            // BUG-012 FIX: Removed legacy captureImage() alias - use capturePhoto() directly

            renderCapturedImages() {
                const container = document.getElementById('captured-images');
                container.innerHTML = this.capturedImages.map((img, idx) => {
                    // BUG-009 FIX: Add quality indicator
                    const quality = this.checkPhotoQuality(img);
                    const qualityColor = quality.score >= 85 ? '#10B981' : quality.score >= 75 ? '#F59E0B' : '#EF4444';
                    const qualityIcon = quality.score >= 85 ? '‚úì' : quality.score >= 75 ? '‚ö†' : '‚úó';
                    const qualityLabel = quality.score >= 85 ? 'Good quality' : quality.score >= 75 ? 'Acceptable' : 'Poor quality';
                    
                    return `
                        <div class="captured-image" role="listitem">
                            <img src="${img}" alt="Captured image ${idx + 1}">
                            
                            <!-- Quality indicator dot -->
                            <div title="${qualityLabel} (${quality.score}%)" style="position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; border-radius: 50%; background: ${qualityColor}; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2); cursor: help;">
                                ${qualityIcon}
                            </div>
                            
                            <button class="crop-image" onclick="app.cropExistingImage(${idx})" aria-label="Crop image ${idx + 1}" style="position:absolute; bottom:4px; left:4px; border-radius:50%; border:none; background:rgba(22,163,74,0.9); color:white; font-size:12px; cursor:pointer;">‚úÇÔ∏è</button>
                            <button class="remove-image" onclick="app.removeImage(${idx})" aria-label="Remove image ${idx + 1}">√ó</button>
                        </div>
                    `;
                }).join('');
                
                // Update badge
                const badge = document.getElementById('photo-count-badge');
                if (badge) {
                    badge.textContent = this.capturedImages.length;
                    badge.style.display = this.capturedImages.length > 0 ? 'flex' : 'none';
                }
            },

            removeImage(index) {
                this.capturedImages.splice(index, 1);
                this.updateCapturedImagesState(); // Fix #4: Use centralized state update
            },

            // Analysis Functions
            async analyzeProduct() {
                // Fix #1: Prevent concurrent analysis operations
                if (this.isAnalyzing) {
                    this.showToast('Analysis already in progress. Please wait...', 'warning');
                    return;
                }
                
                // A3: Validate photos exist
                if (this.capturedImages.length === 0) {
                    this.showToast('Please capture at least one photo first', 'error');
                    return;
                }
                
                // Fix #1: Set flag and disable button to prevent concurrent operations
                this.isAnalyzing = true;
                const analyzeBtn = document.getElementById('analyze-btn-bar');
                if (analyzeBtn) {
                    analyzeBtn.disabled = true;
                }
                
                this.showLoading('Extracting text from images...');
                
                // Additional Fix #2: Reset OCR cancellation flag
                this.ocrCancelled = false;

                try {
                    let extractedText = '';
                    for (let i = 0; i < this.capturedImages.length; i++) {
                        // Additional Fix #2: Check if OCR was cancelled (user navigated away)
                        if (this.ocrCancelled || this.currentView !== 'scanner') {
                            console.log('OCR cancelled - user navigated away');
                            this.hideLoading();
                            this.isAnalyzing = false;
                            return;
                        }
                        
                        this.updateLoadingMessage(`Processing image ${i + 1} of ${this.capturedImages.length}...`);
                        const result = await Tesseract.recognize(this.capturedImages[i], 'eng+hin', {
                            logger: m => console.log(m)
                        });
                        extractedText += result.data.text + '\n\n';
                    }
                    
                    // Additional Fix #2: Check again after OCR loop
                    if (this.ocrCancelled || this.currentView !== 'scanner') {
                        console.log('OCR cancelled after processing - user navigated away');
                        this.hideLoading();
                        this.isAnalyzing = false;
                        return;
                    }
                    
                    // A4: Validate text was extracted
                    if (!extractedText || extractedText.trim().length < 10) {
                        this.hideLoading();
                        this.isAnalyzing = false; // Fix #1: Reset flag on early return
                        const analyzeBtn = document.getElementById('analyze-btn-bar');
                        if (analyzeBtn && this.capturedImages.length > 0) {
                            analyzeBtn.disabled = false; // Re-enable if images still exist
                        }
                        // Fix #6: Preserve capturedImages array on early return (don't clear) so user can retry
                        this.showToast('Could not read any text. Please retake with clearer photo.', 'error');
                        return;
                    }

                    this.updateLoadingMessage('Analyzing with AI...');
                    
                    // Additional Fix #1: Create AbortController for API request cancellation
                    this.currentAbortController = new AbortController();
                    const analysis = await this.analyzeWithGemini(extractedText, this.scanMode, this.currentAbortController.signal);
                    
                    // Additional Fix #1: Clear abort controller after successful request
                    this.currentAbortController = null;
                    
                    this.hideLoading();
                    this.showAnalysis(analysis);
                    this.addToRecentScans(analysis);
                    this.incrementScanCount();
                    
                    // Reset
                    this.capturedImages = [];
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    this.stopCamera();
                    
                    // Fix #1: Reset flag after successful analysis
                    this.isAnalyzing = false;

                } catch (error) {
                    // Additional Fix #1: Don't show error if request was cancelled (user navigated away)
                    if (error.name === 'AbortError') {
                        console.log('Analysis cancelled - user navigated away');
                        this.currentAbortController = null;
                        return; // Silently exit, user already navigated away
                    }
                    
                    // Additional Fix #2: Don't show error if OCR was cancelled
                    if (this.ocrCancelled) {
                        console.log('Analysis cancelled - OCR was cancelled');
                        this.hideLoading();
                        this.isAnalyzing = false;
                        this.ocrCancelled = false;
                        return;
                    }
                    
                    // Fix #6: Error recovery - ensure all state is reset properly
                    this.hideLoading();
                    
                    // Fix #1: Reset flag and re-enable button on error
                    this.isAnalyzing = false;
                    const analyzeBtn = document.getElementById('analyze-btn-bar');
                    if (analyzeBtn && this.capturedImages.length > 0) {
                        analyzeBtn.disabled = false; // Re-enable if images still exist
                    }
                    
                    // Additional Fix #1: Clear abort controller on error
                    this.currentAbortController = null;
                    
                    // Fix #6: Preserve capturedImages array on error (don't clear) so user can retry
                    // Fix #6: Don't stop camera on error - allow user to retry with same camera session
                    
                    // Build debug info for troubleshooting
                    const debugInfo = {
                        errorMessage: error.message,
                        errorStack: error.stack ? error.stack.substring(0, 500) : 'No stack trace',
                        timestamp: new Date().toISOString(),
                        userAgent: navigator.userAgent,
                        capturedImagesCount: this.capturedImages.length,
                        scanMode: this.scanMode
                    };
                    
                    // BUG-006 FIX: Better error detection with debug info
                    if (error.message && error.message.includes('Tesseract')) {
                        this.showError('OCR_NOT_LOADED', this.debugMode ? debugInfo : null);
                    } else if (error.message && (error.message.includes('network') || error.message.includes('fetch'))) {
                        this.showError('NETWORK_ERROR', this.debugMode ? debugInfo : null);
                    } else {
                        this.showError('ANALYSIS_FAILED', this.debugMode ? debugInfo : null);
                    }
                    
                    console.error('Analysis error:', error);
                    this.logError('ERR_ANALYSIS', { message: error.message, stack: error.stack });
                }
            },

            async queryOpenFoodFacts(barcode, signal = null) {
                try {
                    // Additional Fix #1: Support request cancellation
                    const response = await fetch(
                        `https://world.openfoodfacts.org/api/v0/product/${barcode}.json`,
                        { signal }
                    );
                    const data = await response.json();
                    
                    if (data.status === 1) {
                        return {
                            found: true,
                            name: data.product.product_name,
                            brand: data.product.brands,
                            ingredients: data.product.ingredients_text,
                            nutriScore: data.product.nutriscore_grade,
                            nutrition: data.product.nutriments,
                            category: data.product.categories,
                            image: data.product.image_url
                        };
                    }
                } catch (error) {
                    // Additional Fix #1: Don't log error if request was cancelled
                    if (error.name === 'AbortError') {
                        throw error; // Re-throw so caller knows request was cancelled
                    }
                    console.error('Open Food Facts error:', error);
                }
                
                return { found: false };
            },

            convertOFFToAnalysis(offData) {
                const scoreMap = { 'a': 85, 'b': 70, 'c': 55, 'd': 40, 'e': 25 };
                const score = scoreMap[offData.nutriScore?.toLowerCase()] || 50;
                
                return {
                    productName: offData.name || 'Unknown Product',
                    brand: offData.brand || 'Unknown Brand',
                    healthScore: score,
                    scoreCategory: this.getScoreCategory(score),
                    scoreReason: `Based on Nutri-Score ${offData.nutriScore?.toUpperCase() || 'Unknown'}`,
                    allergyWarnings: this.checkAllergies(offData.ingredients),
                    macros: {
                        calories: `${offData.nutrition?.['energy-kcal_100g'] || 0} kcal`,
                        protein: `${offData.nutrition?.proteins_100g || 0}g`,
                        carbs: `${offData.nutrition?.carbohydrates_100g || 0}g`,
                        fat: `${offData.nutrition?.fat_100g || 0}g`,
                        fiber: `${offData.nutrition?.fiber_100g || 0}g`,
                        sugar: `${offData.nutrition?.sugars_100g || 0}g`
                    },
                    ingredients: this.parseIngredientsFromOFF(offData.ingredients),
                    certifications: ['Open Food Facts Verified'],
                    alternatives: [],
                    image: offData.image
                };
            },

            parseIngredientsFromOFF(ingredientsText) {
                if (!ingredientsText) return [];
                
                const ingredients = ingredientsText.split(',').slice(0, 5).map(ing => ({
                    name: ing.trim(),
                    purpose: 'Main ingredient',
                    healthImpact: 'neutral',
                    details: 'Part of product formulation',
                    source: 'Product label'
                }));
                
                return ingredients;
            },

            checkAllergies(ingredientsText) {
                if (!this.userSettings.allergies || !ingredientsText) return [];
                
                const allergyList = this.userSettings.allergies.toLowerCase().split(',').map(a => a.trim());
                const foundAllergens = [];
                
                allergyList.forEach(allergen => {
                    if (ingredientsText.toLowerCase().includes(allergen)) {
                        foundAllergens.push(allergen);
                    }
                });
                
                return foundAllergens;
            },

            // v1.2.0: Improved Gemini prompt with compound ingredient handling
            async analyzeWithGemini(extractedText, mode, signal = null) {
                const GEMINI_API_KEY = 'AIzaSyBRU_8O1QXJaYnx1liyf7j3lhQwpj1fuEU';
                
                const basePrompt = mode === 'ingredients' 
                    ? `You are analyzing a food product ingredient list for consumer health education.

EXTRACTED TEXT FROM IMAGE:
${extractedText}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
CRITICAL EXTRACTION RULES - READ CAREFULLY
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

1. ONLY extract from the "Ingredients:" section
2. Ingredients are separated by: COMMAS (,) SEMICOLONS (;) BULLETS (‚Ä¢) or NEWLINES
3. KEEP COMPOUND INGREDIENTS TOGETHER AS ONE UNIT:
   ‚úì "Sodium Benzoate" ‚Üí "Sodium Benzoate" (NOT "Sodium" + "Benzoate")
   ‚úì "Palm Oil" ‚Üí "Palm Oil" (NOT "Palm" + "Oil")
   ‚úì "Citric Acid" ‚Üí "Citric Acid"
   ‚úì "Monosodium Glutamate" ‚Üí "Monosodium Glutamate"
   ‚úì "Modified Corn Starch" ‚Üí "Modified Corn Starch"

4. STOP extraction when you see ANY of these:
   - "Contains:", "Allergens:", "May Contain:"
   - "Nutrition Facts", "Nutritional Information"
   - "Net Weight", "Net Wt", "Net Contents"
   - "Best Before", "Expiry", "Use By", "Mfg Date"
   - "Storage:", "Directions:", "Instructions:"
   - "Manufactured by:", "Packed by:", "Marketed by:"

5. KNOWN COMPOUND INGREDIENTS (keep together):
   - Preservatives: Sodium Benzoate, Potassium Sorbate, Calcium Propionate
   - Acids: Citric Acid, Ascorbic Acid, Tartaric Acid, Malic Acid, Lactic Acid
   - Oils: Palm Oil, Sunflower Oil, Coconut Oil, Vegetable Oil, Soybean Oil, Rice Bran Oil
   - Starches: Modified Starch, Corn Starch, Tapioca Starch, Modified Corn Starch
   - Flavors: Natural Flavors, Artificial Flavors, Nature Identical Flavoring
   - Additives: Raising Agent, Emulsifying Agent, Stabilizer, Thickener
   - E-numbers: E621, E320, E330 (keep code with name if both present)
   - INS codes: INS 621, INS 320 (keep code with name if both present)

6. COMPLETELY IGNORE:
   - Numbers alone (200g, 500ml, %)
   - Dates in any format
   - Brand names, company names
   - Nutrition values (calories, protein, etc.)
   - Serving size information

Respond ONLY with valid JSON:
{
  "detectedLanguage": "English/Hindi/Tamil/Telugu/Other",
  "productName": "Unknown (Ingredient Scan)",
  "category": "food",
  "healthScore": 0-100,
  "scoreCategory": "excellent/good/fair/poor/bad",
  "scoreReason": "Brief 1-2 sentence explanation",
  "confidence": "high/medium/low",
  "allergyWarnings": ["list of common allergens detected"],
  "ingredients": [
    {
      "name": "Ingredient Name (keep compound names together)",
      "purpose": "What this ingredient does",
      "healthImpact": "positive/neutral/negative",
      "safetyLevel": "generally-safe/use-sparingly/limit-intake/avoid-if-sensitive",
      "details": "2-3 sentence explanation in simple language",
      "source": "Natural/Synthetic/Processed"
    }
  ],
  "trustBadges": [
    {"type": "verified/caution/warning", "text": "Badge text", "standard": "WHO/FSSAI/FDA/EFSA"}
  ],
  "overallVerdict": "Brief recommendation"
}

CONFIDENCE RULES:
- "high": Clear image, all ingredients readable, standard format
- "medium": Some text unclear, most ingredients detected
- "low": Poor quality, many ingredients may be missed

HEALTH SCORE RULES:
- 80-100 (excellent): Minimal processing, no concerning additives
- 60-79 (good): Some processing, minor additives
- 40-59 (fair): Moderate processing, some concerning ingredients
- 20-39 (poor): Highly processed, multiple concerning additives
- 0-19 (bad): Many harmful additives, very low nutritional value

Be accurate and educational. Avoid alarmist language.`
                    : `Analyze this food product label for Indian consumers.

Text from product label:
${extractedText}

CRITICAL: Keep compound ingredient names together (e.g., "Sodium Benzoate" not "Sodium" + "Benzoate").

Respond ONLY with valid JSON:
{
  "productName": "Product name",
  "brand": "Brand name",
  "category": "food",
  "healthScore": 0-100,
  "scoreCategory": "excellent/good/fair/poor/bad",
  "scoreReason": "Brief explanation",
  "confidence": "high/medium/low",
  "allergyWarnings": ["allergens found"],
  "macros": {
    "calories": "value per 100g or null",
    "protein": "value or null",
    "carbs": "value or null",
    "fat": "value or null",
    "fiber": "value or null",
    "sugar": "value or null"
  },
  "ingredients": [
    {
      "name": "ingredient name",
      "purpose": "what it does",
      "healthImpact": "positive/neutral/negative",
      "safetyLevel": "generally-safe/use-sparingly/limit-intake/avoid-if-sensitive",
      "details": "explanation in simple language",
      "source": "Natural/Synthetic/Processed"
    }
  ],
  "certifications": ["FSSAI", "organic", etc],
  "trustBadges": [
    {"type": "verified/caution/warning", "text": "badge text", "standard": "WHO/FSSAI/FDA"}
  ]
}`;

                try {
                    if (GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY_HERE') {
                        throw new Error('API key not set');
                    }
                    
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: basePrompt }] }],
                                generationConfig: {
                                    temperature: 0.7,
                                    maxOutputTokens: 4096
                                }
                            }),
                            signal: signal // Additional Fix #1: Pass abort signal
                        }
                    );
                    
                    // Check for network/API errors
                    if (!response.ok) {
                        const errorText = await response.text().catch(() => 'Could not read error response');
                        let errorDetails;
                        try {
                            errorDetails = JSON.parse(errorText);
                        } catch {
                            errorDetails = errorText;
                        }
                        
                        console.error('API response not ok:', response.status, errorDetails);
                        
                        // Provide specific error messages based on status code
                        if (response.status === 429) {
                            throw new Error(`API_QUOTA_EXCEEDED: Rate limit or quota exceeded. Status: ${response.status}. Details: ${JSON.stringify(errorDetails).substring(0, 200)}`);
                        } else if (response.status === 403) {
                            throw new Error(`API_AUTH_FAILED: Invalid API key or permission denied. Status: ${response.status}. Details: ${JSON.stringify(errorDetails).substring(0, 200)}`);
                        } else if (response.status === 400) {
                            throw new Error(`API_BAD_REQUEST: Invalid request format. Status: ${response.status}. Details: ${JSON.stringify(errorDetails).substring(0, 200)}`);
                        } else {
                            throw new Error(`API_ERROR_${response.status}: ${JSON.stringify(errorDetails).substring(0, 300)}`);
                        }
                    }
                    
                    const data = await response.json();
                    
                    // Check for valid response structure
                    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                        console.error('Invalid API response structure:', data);
                        throw new Error(`INVALID_API_RESPONSE: ${JSON.stringify(data).substring(0, 300)}`);
                    }
                    
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    
                    if (jsonMatch) {
                        const rawAnalysis = JSON.parse(jsonMatch[0]);
                        // v1.2.0: Post-processing validation
                        return this.validateAndCleanAnalysis(rawAnalysis);
                    }
                    
                    throw new Error('Could not parse response');
                } catch (error) {
                    console.error('Gemini API error:', error);
                    this.logError('ERR_API', { message: error.message });
                    // v1.2.1: Throw detailed error for debugging
                    throw error; // Preserve the detailed error message
                }
            },

            // v1.2.0: Post-processing validation for AI results
            validateAndCleanAnalysis(analysis) {
                // Clean ingredients
                if (analysis.ingredients && Array.isArray(analysis.ingredients)) {
                    analysis.ingredients = this.cleanIngredients(analysis.ingredients);
                }
                
                // Validate health score
                if (typeof analysis.healthScore === 'number') {
                    analysis.healthScore = Math.max(0, Math.min(100, Math.round(analysis.healthScore)));
                } else {
                    analysis.healthScore = 50; // Default if missing
                }
                
                // Ensure score category matches score
                analysis.scoreCategory = this.getScoreCategory(analysis.healthScore);
                
                // Validate confidence
                if (!['high', 'medium', 'low'].includes(analysis.confidence)) {
                    analysis.confidence = 'medium';
                }
                
                // Validate macros (all-or-nothing)
                if (analysis.macros) {
                    if (!this.hasCompleteNutrition(analysis.macros)) {
                        analysis.macros = null; // Remove incomplete nutrition
                    }
                }
                
                // Ensure arrays exist
                analysis.allergyWarnings = analysis.allergyWarnings || [];
                analysis.trustBadges = analysis.trustBadges || [];
                
                return analysis;
            },

            // v1.2.0: Clean and validate ingredients list
            cleanIngredients(ingredients) {
                // Patterns to exclude (non-ingredients)
                const excludePatterns = [
                    /^net\s*(weight|wt|contents?)/i,
                    /^best\s*before/i,
                    /^(mfg|exp|use\s*by)\s*date/i,
                    /^batch/i,
                    /^lot/i,
                    /^\d+\s*(g|ml|kg|l|kcal|cal)$/i,
                    /^\d+%$/,
                    /^contains?:?$/i,
                    /^allergen/i,
                    /^ingredients?:?$/i,
                    /^nutrition/i,
                    /^storage/i,
                    /^directions?/i,
                    /^manufactured/i,
                    /^packed\s*by/i,
                    /^marketed\s*by/i
                ];
                
                return ingredients
                    .filter(ing => {
                        if (!ing || !ing.name) return false;
                        const name = ing.name.trim();
                        if (name.length < 2) return false;
                        // Check against exclude patterns
                        return !excludePatterns.some(pattern => pattern.test(name));
                    })
                    .map(ing => ({
                        name: this.mergeCompoundIngredient(ing.name.trim()),
                        purpose: ing.purpose || 'Ingredient',
                        healthImpact: ing.healthImpact || 'neutral',
                        safetyLevel: ing.safetyLevel || 'generally-safe',
                        details: ing.details || 'Part of product formulation',
                        source: ing.source || 'Unknown'
                    }));
            },

            // v1.2.0: Merge compound ingredients that may have been split
            mergeCompoundIngredient(name) {
                // Known compound prefixes and their common pairs
                const compounds = {
                    'sodium': ['benzoate', 'chloride', 'bicarbonate', 'citrate', 'lactate', 'phosphate'],
                    'potassium': ['sorbate', 'chloride', 'citrate', 'benzoate'],
                    'calcium': ['carbonate', 'chloride', 'phosphate', 'propionate', 'sulfate'],
                    'citric': ['acid'],
                    'ascorbic': ['acid'],
                    'lactic': ['acid'],
                    'malic': ['acid'],
                    'tartaric': ['acid'],
                    'palm': ['oil'],
                    'sunflower': ['oil'],
                    'coconut': ['oil'],
                    'vegetable': ['oil'],
                    'soybean': ['oil'],
                    'rice': ['bran oil', 'flour'],
                    'corn': ['starch', 'syrup', 'flour'],
                    'modified': ['starch', 'corn starch', 'tapioca starch'],
                    'wheat': ['flour', 'gluten'],
                    'natural': ['flavors', 'flavours', 'color', 'colours'],
                    'artificial': ['flavors', 'flavours', 'color', 'colours']
                };
                
                // Already looks compound, return as-is
                if (name.includes(' ')) return name;
                
                // Check if this is a prefix that needs a suffix
                const lower = name.toLowerCase();
                if (compounds[lower]) {
                    // This is incomplete - but we can't fix without context
                    // Just return as-is
                }
                
                return name;
            },

            // v1.2.0: Check if nutrition data is complete (all-or-nothing)
            hasCompleteNutrition(macros) {
                if (!macros) return false;
                
                // Require all 4 core macros to display nutrition section
                const required = ['calories', 'protein', 'carbs', 'fat'];
                return required.every(key => {
                    const value = macros[key];
                    if (!value) return false;
                    if (value === 'null' || value === 'N/A' || value === '-') return false;
                    // Must have a number
                    return /\d/.test(value);
                });
            },

            // v1.2.0: Get score category from numeric score
            getScoreCategory(score) {
                if (score >= 80) return 'excellent';
                if (score >= 60) return 'good';
                if (score >= 40) return 'fair';
                if (score >= 20) return 'poor';
                return 'bad';
            },

            // v1.2.0: Error logging to localStorage
            logError(code, details = {}) {
                try {
                    const errors = JSON.parse(localStorage.getItem('eitaki_error_log') || '[]');
                    errors.push({
                        code,
                        details,
                        timestamp: Date.now(),
                        url: window.location.href
                    });
                    // Keep only last 50 errors
                    this.safeLocalStorageSet('eitaki_error_log', JSON.stringify(errors.slice(-50)));
                } catch (e) {
                    console.error('Failed to log error:', e);
                }
            },

            // v1.2.1: getDemoAnalysis() removed - no fake results

            showAnalysis(analysis) {
                const container = document.getElementById('analysis-content');
                const scoreClass = `score-${analysis.scoreCategory || 'fair'}`;

                // BUG #5: Calculate and display confidence
                // AI returns "high/medium/low", convert to numeric for display
                let confidenceValue = analysis.confidence;
                let confidencePercent, confidenceColor, confidenceLabel;
                
                if (typeof confidenceValue === 'string') {
                    // Convert string to percent
                    if (confidenceValue === 'high') {
                        confidencePercent = 90;
                        confidenceColor = '#10B981';
                        confidenceLabel = 'High';
                    } else if (confidenceValue === 'medium') {
                        confidencePercent = 75;
                        confidenceColor = '#F59E0B';
                        confidenceLabel = 'Medium';
                    } else {
                        confidencePercent = 60;
                        confidenceColor = '#EF4444';
                        confidenceLabel = 'Low';
                    }
                } else if (typeof confidenceValue === 'number') {
                    confidencePercent = confidenceValue;
                    confidenceColor = confidenceValue >= 85 ? '#10B981' : confidenceValue >= 75 ? '#F59E0B' : '#EF4444';
                    confidenceLabel = confidenceValue >= 85 ? 'High' : confidenceValue >= 75 ? 'Medium' : 'Low';
                } else {
                    // Default
                    confidencePercent = 75;
                    confidenceColor = '#F59E0B';
                    confidenceLabel = 'Medium';
                }

                let trustBadgesHTML = '';
                if (analysis.trustBadges && analysis.trustBadges.length > 0) {
                    trustBadgesHTML = `
                        <div class="trust-badges" style="margin-top: 16px;">
                            ${analysis.trustBadges.map(badge => `
                                <span class="trust-badge ${badge.type}">
                                    ${badge.type === 'verified' ? '‚úì' : badge.type === 'caution' ? '‚ö†' : '‚ö†'}
                                    ${badge.text}
                                </span>
                            `).join('')}
                        </div>
                    `;
                }

                let allergiesHTML = '';
                if (analysis.allergyWarnings && analysis.allergyWarnings.length > 0) {
                    allergiesHTML = `
                        <div class="alert-box" role="alert">
                            <strong>‚ö†Ô∏è Allergy Alert:</strong> Contains ${analysis.allergyWarnings.join(', ')}
                        </div>
                    `;
                }

                // BUG #5: Confidence badge HTML
                const confidenceBadgeHTML = `
                    <div style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: white; border-radius: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); margin-top: 12px;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: ${confidenceColor};"></div>
                        <span style="font-size: 13px; font-weight: 600; color: #1E293B;">
                            ${confidenceLabel} Confidence (${confidencePercent}%)
                        </span>
                    </div>
                `;

                // BUG #5: Low confidence disclaimer
                const confidenceDisclaimerHTML = confidencePercent < 80 ? `
                    <div style="background: #FEF3C7; border-left: 4px solid #F59E0B; padding: 12px; border-radius: 8px; margin-top: 16px;">
                        <strong style="color: #92400E;">‚ö†Ô∏è Note:</strong>
                        <span style="color: #78350F; font-size: 14px;">
                            Some ingredients may not have been detected clearly. Double-check the packaging.
                        </span>
                    </div>
                ` : '';

                let macrosHTML = '';
                if (analysis.macros) {
                    macrosHTML = `
                        <div class="analysis-section">
                            <h2 class="section-title">üìä Nutrition Facts</h2>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                                ${Object.entries(analysis.macros).map(([key, value]) => `
                                    <div style="background: var(--ice-blue); padding: 12px; border-radius: 8px; text-align: center;">
                                        <div style="font-size: 18px; font-weight: 700; color: var(--slate);">${value}</div>
                                        <div style="font-size: 12px; color: var(--light-slate); text-transform: capitalize;">${key}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                let verdictHTML = '';
                if (analysis.overallVerdict) {
                    verdictHTML = `
                        <div style="background: var(--ice-blue); padding: 20px; border-radius: 12px; text-align: center; font-size: 18px; font-weight: 700; margin-bottom: 20px;">
                            ${analysis.overallVerdict}
                        </div>
                    `;
                }

                // BUG #6: Score explanation section
                const scoreExplanationHTML = `
                    <div style="margin-top: 16px;">
                        <button class="btn btn-secondary" onclick="app.toggleScoreDetails()" style="width: 100%; font-size: 14px;">
                            üìä Why this score? (Tap to expand)
                        </button>
                        
                        <div id="score-details" style="display: none; margin-top: 16px; background: #F0FDF4; padding: 16px; border-radius: 12px;">
                            <h4 style="font-size: 16px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                                Score Breakdown
                            </h4>
                            
                            <div style="margin-bottom: 16px;">
                                <strong style="color: #16A34A; display: block; margin-bottom: 8px;">üìä How we calculate:</strong>
                                <ul style="margin: 0; padding-left: 20px; color: #475569; font-size: 14px;">
                                    <li>Processing Level (20%)</li>
                                    <li>Nutrient Quality (35%)</li>
                                    <li>Ingredient Quality (30%)</li>
                                    <li>Transparency (15%)</li>
                                </ul>
                            </div>
                            
                            <div style="background: white; padding: 12px; border-radius: 8px; font-size: 13px; color: #64748B;">
                                <strong style="color: #1E293B;">Sources:</strong> WHO, FSSAI, FDA, peer-reviewed research.
                                <a href="#" onclick="app.showMethodology(); return false;" style="color: #16A34A; text-decoration: underline;">
                                    View full methodology
                                </a>
                            </div>
                        </div>
                    </div>
                `;

                // v1.2.1: Save to My Scans prompt (localStorage, no Firebase)
                const savePromptHTML = `
                    <div style="background: linear-gradient(135deg, #16A34A, #14B8A6); padding: 24px; border-radius: 16px; margin-top: 20px; color: white; text-align: center;">
                        <h3 style="font-size: 18px; font-weight: 700; margin-bottom: 12px;">
                            üíæ Save This Scan?
                        </h3>
                        <p style="font-size: 14px; margin-bottom: 20px; opacity: 0.9;">
                            Keep this analysis in your personal scan history for quick access later.
                        </p>
                        
                        <div style="display: flex; gap: 12px; justify-content: center;">
                            <button class="btn" onclick="app.saveToMyScans()" style="background: white; color: #16A34A; flex: 1; max-width: 150px;">
                                üíæ Save
                            </button>
                            <button class="btn" onclick="app.skipSave()" style="background: rgba(255,255,255,0.2); color: white; flex: 1; max-width: 150px;">
                                Skip
                            </button>
                        </div>
                    </div>
                `;

                // BUG #9: Healthier alternatives (only if score < 50)
                const alternativesHTML = analysis.healthScore < 50 ? `
                    <div style="background: linear-gradient(135deg, #F0FDF4, #DCFCE7); padding: 20px; border-radius: 16px; margin-top: 24px;">
                        <h3 style="font-size: 18px; font-weight: 700; color: #166534; margin-bottom: 16px;">
                            üíö Looking for Healthier Options?
                        </h3>
                        <p style="font-size: 14px; color: #15803D; margin-bottom: 16px;">
                            Consider products with fewer processed ingredients and lower sodium/sugar content.
                        </p>
                        <p style="font-size: 12px; color: #15803D; font-style: italic;">
                            Feature coming soon: We'll suggest specific alternatives based on community data.
                        </p>
                    </div>
                ` : '';

                container.innerHTML = `
                    <div class="product-header">
                        ${analysis.image ? `<img src="${analysis.image}" alt="${analysis.productName}" style="width: 100%; max-height: 200px; object-fit: contain; margin-bottom: 16px; border-radius: 8px;">` : ''}
                        <h1 class="product-name">${analysis.productName}</h1>
                        ${analysis.brand ? `<p class="product-brand">${analysis.brand}</p>` : ''}
                        ${analysis.detectedLanguage ? `<p class="product-brand">Detected language: ${analysis.detectedLanguage}</p>` : ''}
                        
                        ${confidenceDisclaimerHTML}
                        
                        <div class="health-score-card">
                            <div class="score-main">
                                <div class="score-circle ${scoreClass}">
                                    ${analysis.healthScore}
                                    <div class="score-label">${analysis.scoreCategory}</div>
                                </div>
                                <div class="score-details">
                                    <div class="score-title">Health Score</div>
                                    <p class="score-desc">${analysis.scoreReason}</p>
                                </div>
                            </div>
                            ${confidenceBadgeHTML}
                            ${trustBadgesHTML}
                            ${scoreExplanationHTML}
                        </div>

                        ${allergiesHTML}
                        ${verdictHTML}
                    </div>

                    ${macrosHTML}

                    <div class="analysis-section">
                        <h2 class="section-title">üî¨ Ingredients Deep Dive</h2>
                        <div class="ingredient-list">
                            ${(analysis.ingredients || []).map(ing => `
                                <div class="ingredient-item">
                                    <div class="ingredient-header">
                                        <span class="ingredient-name">${ing.name}</span>
                                        <span class="impact-badge impact-${ing.healthImpact}">
                                            ${ing.healthImpact === 'positive' ? '‚úì Good' : ing.healthImpact === 'negative' ? '‚ö† Caution' : 'Neutral'}
                                        </span>
                                    </div>
                                    ${ing.readabilityIssue ? `<div class="alert-box" style="margin: 8px 0; font-size: 12px; padding: 8px;">‚ö†Ô∏è ${ing.readabilityIssue}</div>` : ''}
                                    <div class="ingredient-purpose"><strong>Purpose:</strong> ${ing.purpose}</div>
                                    <div class="ingredient-detail">${ing.details}</div>
                                    <div style="font-size: 12px; color: var(--light-slate); margin-top: 8px;">
                                        <strong>Source:</strong> ${ing.source}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    ${analysis.certifications && analysis.certifications.length > 0 ? `
                        <div class="analysis-section">
                            <h2 class="section-title">‚úì Certifications & Standards</h2>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                ${analysis.certifications.map(cert => `
                                    <span style="background: var(--ice-blue); padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 600;">
                                        ${cert}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}

                    ${alternativesHTML}
                    ${savePromptHTML}

                    <div class="disclaimer">
                        <strong>‚ö†Ô∏è Important Disclaimer:</strong> This analysis is for educational purposes only and should not be considered medical advice. 
                        Information is based on detected ${this.scanMode === 'ingredients' ? 'ingredients' : 'product data'} and may not be 100% accurate. 
                        Always verify ingredients on the actual product packaging. May miss allergens if not clearly visible in scan. 
                        We are not liable for errors in detection or analysis. Consult healthcare professionals for specific dietary needs.
                        <br><br>
                        <strong>Data Sources:</strong> ${analysis.image ? 'Open Food Facts, ' : ''}AI analysis (Gemini), WHO, FSSAI, peer-reviewed research.
                        Last analyzed: ${new Date().toLocaleDateString()}
                    </div>

                    <div style="text-align: center; margin-top: 24px;">
                        <button class="btn btn-primary" onclick="app.showView('home')" style="margin-right: 12px;">
                            üè† Home
                        </button>
                        <button class="btn btn-secondary" onclick="app.showView('scanner')">
                            üì∏ Scan Another
                        </button>
                    </div>
                `;

                this.showView('analysis');
                
                // Show footer with disclaimer
                document.getElementById('app-footer').style.display = 'block';
            },

            // BUG #6: Toggle score details
            toggleScoreDetails() {
                const details = document.getElementById('score-details');
                if (details) {
                    details.style.display = details.style.display === 'none' ? 'block' : 'none';
                }
            },

            // BUG #8: Contribution handlers
            // v1.2.1: Save to My Scans (localStorage only, no Firebase)
            saveToMyScans() {
                try {
                    // Get the current analysis from the displayed content
                    const productName = document.querySelector('.product-name')?.textContent || 'Unknown Product';
                    const healthScore = document.querySelector('.score-circle')?.textContent?.trim() || '??';
                    const scoreCategory = document.querySelector('.score-label')?.textContent || 'unknown';
                    
                    const scan = {
                        id: Date.now(),
                        name: productName,
                        score: parseInt(healthScore) || 0,
                        category: scoreCategory,
                        date: new Date().toISOString(),
                        mode: this.scanMode
                    };
                    
                    // Save to localStorage
                    let savedScans = JSON.parse(localStorage.getItem('my_saved_scans') || '[]');
                    savedScans.unshift(scan);
                    savedScans = savedScans.slice(0, 20); // Keep last 20
                    this.safeLocalStorageSet('my_saved_scans', JSON.stringify(savedScans));
                    
                    this.showToast('Saved to My Scans! üíæ', 'success');
                    
                    // Navigate home after brief delay
                    setTimeout(() => this.showView('home'), 1500);
                } catch (e) {
                    console.error('Failed to save scan:', e);
                    this.showToast('Failed to save. Please try again.', 'error');
                }
            },

            skipSave() {
                // Simply go home - no guilt
                this.showView('home');
            },

            // v1.2.1: promptSignupIfContributing removed - not needed without Firebase

            // BUG #11: Update scan history display
            updateScanHistoryDisplay() {
                const historyContainer = document.getElementById('scan-history-list');
                if (!historyContainer) return;
                
                if (this.recentScans.length === 0) {
                    // BUG-013 FIX: Encouraging empty state with CTA button
                    historyContainer.innerHTML = `
                        <div style="text-align: center; padding: 24px;">
                            <div style="font-size: 48px; margin-bottom: 12px;">üì∏</div>
                            <h3 style="font-size: 18px; font-weight: 700; color: #1E293B; margin-bottom: 8px;">
                                No Scans Yet
                            </h3>
                            <p style="color: #64748B; font-size: 14px; margin-bottom: 20px;">
                                Scan your first product to see what's really inside!
                            </p>
                            <button class="btn btn-primary" onclick="app.showView('scanner')" style="width: 100%;">
                                üì∏ Start Scanning
                            </button>
                        </div>
                    `;
                    return;
                }
                
                historyContainer.innerHTML = this.recentScans.map(scan => `
                    <div style="background: var(--ice-blue); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: var(--slate);">${scan.name}</div>
                        <div style="font-size: 12px; color: var(--light-slate);">
                            Score: ${scan.score} ‚Ä¢ ${new Date(scan.timestamp).toLocaleDateString()}
                        </div>
                    </div>
                `).join('');
            },

            // BUG #13: Show About page
            showAbout() {
                this.showView('about');
            },

            // BUG #6: Show methodology modal
            showMethodology() {
                const modal = `
                    <div class="modal active" id="methodology-modal" onclick="if(event.target === this) app.closeMethodologyModal()">
                        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                            <h3 class="modal-title">üî¨ How We Calculate Health Scores</h3>
                            <div style="font-size: 14px; line-height: 1.8; color: #374151;">
                                <p style="margin-bottom: 16px;">
                                    Our health scores are based on a <strong>4-pillar framework</strong> developed using WHO, FSSAI, and peer-reviewed research:
                                </p>
                                
                                <div style="background: #F0FDF4; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
                                    <strong style="color: #16A34A;">üìä Score Breakdown:</strong>
                                    <ul style="margin: 12px 0 0 20px;">
                                        <li><strong>Processing Level (20%)</strong>: How processed is the food?</li>
                                        <li><strong>Nutrient Quality (35%)</strong>: Good vs bad nutrients</li>
                                        <li><strong>Ingredient Quality (30%)</strong>: Safety of individual ingredients</li>
                                        <li><strong>Transparency (15%)</strong>: Label clarity and certifications</li>
                                    </ul>
                                </div>
                                
                                <div style="background: #FEF3C7; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
                                    <strong style="color: #92400E;">‚ö†Ô∏è Important Notes:</strong>
                                    <ul style="margin: 12px 0 0 20px;">
                                        <li>Scores are educational, not medical advice</li>
                                        <li>Individual health needs vary</li>
                                        <li>Always consult healthcare professionals</li>
                                    </ul>
                                </div>
                                
                                <p style="font-size: 13px; color: #6B7280;">
                                    <strong>Sources:</strong> WHO guidelines, FSSAI standards, FDA regulations, EFSA opinions, peer-reviewed research (PubMed)
                                </p>
                            </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <button class="btn btn-primary" onclick="app.closeMethodologyModal()">Got it!</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modal);
            },

            closeMethodologyModal() {
                const modal = document.getElementById('methodology-modal');
                if (modal) modal.remove();
            },

            // Legal page placeholders
            showPrivacyPolicy() {
                const modal = `
                    <div class="modal active" id="privacy-modal" onclick="if(event.target === this) app.closePrivacyModal()">
                        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                            <h3 class="modal-title">üîí Privacy Policy</h3>
                            <div style="font-size: 14px; line-height: 1.8; color: #374151;">
                                <ul style="margin: 16px 0 0 20px;">
                                    <li style="margin-bottom: 12px;">We respect your privacy</li>
                                    <li style="margin-bottom: 12px;">No personal data collection</li>
                                    <li style="margin-bottom: 12px;">No data sharing with third parties</li>
                                    <li style="margin-bottom: 12px;">Anonymous analytics only</li>
                                </ul>
                                <p style="font-size: 13px; color: #6B7280; margin-top: 20px;">
                                    Full privacy policy coming soon!
                                </p>
                            </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <button class="btn btn-primary" onclick="app.closePrivacyModal()">Got it!</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modal);
            },

            closePrivacyModal() {
                const modal = document.getElementById('privacy-modal');
                if (modal) modal.remove();
            },

            showTerms() {
                const modal = `
                    <div class="modal active" id="terms-modal" onclick="if(event.target === this) app.closeTermsModal()">
                        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                            <h3 class="modal-title">üìã Terms of Service</h3>
                            <div style="font-size: 14px; line-height: 1.8; color: #374151;">
                                <ul style="margin: 16px 0 0 20px;">
                                    <li style="margin-bottom: 12px;">Eitaki is for educational purposes only</li>
                                    <li style="margin-bottom: 12px;">Not medical advice</li>
                                    <li style="margin-bottom: 12px;">Use at your own risk</li>
                                    <li style="margin-bottom: 12px;">Always verify with product packaging</li>
                                </ul>
                                <p style="font-size: 13px; color: #6B7280; margin-top: 20px;">
                                    Full terms coming soon!
                                </p>
                            </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <button class="btn btn-primary" onclick="app.closeTermsModal()">Got it!</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modal);
            },

            closeTermsModal() {
                const modal = document.getElementById('terms-modal');
                if (modal) modal.remove();
            },

            // Utility Functions
            
            // BUG-018 FIX: Safe localStorage wrapper with quota handling
            safeLocalStorageSet(key, value) {
                try {
                    localStorage.setItem(key, value);
                    return true;
                } catch (e) {
                    if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                        this.showToast('Storage full. Please clear old scans in Settings.', 'warning', 5000);
                        this.logError('ERR_STORAGE_FULL', { key, size: value.length });
                        return false;
                    } else {
                        console.error('localStorage error:', e);
                        this.logError('ERR_STORAGE', { error: e.message });
                        return false;
                    }
                }
            },
            
            incrementScanCount() {
                this.scanCount++;
                this.safeLocalStorageSet('scan_count', this.scanCount.toString());
                
                // Check if should prompt for email verification (after 5 scans)
                if (this.scanCount === 5 && !this.emailVerified) {
                    // Could show email modal here, but keeping it progressive for now
                }
            },

            /**
             * Migrates legacy scan history to enhanced format
             * Run once per user - handles users who upgrade
             */
            migrateLegacyScanHistory() {
                try {
                    // Check if migration already done
                    if (localStorage.getItem('eitaki_history_migrated') === 'true') {
                        return;
                    }
                    
                    // Check for legacy data
                    const legacyScans = localStorage.getItem('recent_scans');
                    if (!legacyScans) {
                        localStorage.setItem('eitaki_history_migrated', 'true');
                        return;
                    }
                    
                    // Check if new format already exists
                    const newHistory = localStorage.getItem('eitaki_scan_history');
                    if (newHistory) {
                        localStorage.setItem('eitaki_history_migrated', 'true');
                        return;
                    }
                    
                    // Migrate legacy scans
                    const legacy = JSON.parse(legacyScans);
                    const migrated = legacy.map((scan, index) => ({
                        id: 'migrated_' + index + '_' + Date.now(),
                        timestamp: new Date(scan.timestamp).toISOString(),
                        name: scan.name || 'Unknown Product',
                        brand: scan.brand || null,
                        barcode: null,
                        health_score: scan.score || null,
                        score_category: this.getScoreCategory(scan.score),
                        scan_mode: 'unknown',
                        categories: [],
                        flagged_ingredients: [],
                        product_hash: 'legacy_' + index,
                        scan_count: 1,
                        last_scanned: new Date(scan.timestamp).toISOString()
                    }));
                    
                    this.safeLocalStorageSet('eitaki_scan_history', JSON.stringify(migrated));
                    this.updateScanAggregates(migrated);
                    localStorage.setItem('eitaki_history_migrated', 'true');
                    
                    console.log('Migrated', migrated.length, 'legacy scans to enhanced format');
                    
                } catch (e) {
                    console.error('Failed to migrate legacy scan history:', e);
                    // Don't block app if migration fails
                    localStorage.setItem('eitaki_history_migrated', 'true');
                }
            },

            /**
             * Gets full scan history (enhanced format)
             * @returns {Array} Array of scan records
             */
            getFullScanHistory() {
                try {
                    const stored = localStorage.getItem('eitaki_scan_history');
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    console.error('Failed to get scan history:', e);
                    return [];
                }
            },

            /**
             * Categorizes health score for aggregation
             * @param {number} score - Health score 0-100
             * @returns {string} Category name
             */
            getScoreCategory(score) {
                if (score === null || score === undefined) return 'unknown';
                if (score >= 85) return 'excellent';
                if (score >= 70) return 'good';
                if (score >= 50) return 'fair';
                if (score >= 35) return 'poor';
                return 'very_poor';
            },

            /**
             * Extracts concerning ingredients for tracking
             * @param {Object} analysis - Analysis result
             * @returns {Array} Array of flagged ingredient names
             */
            extractFlaggedIngredients(analysis) {
                const flagged = [];
                if (analysis.ingredients) {
                    analysis.ingredients.forEach(ing => {
                        if (ing.concern === 'high' || ing.concern === 'moderate') {
                            flagged.push(ing.name);
                        }
                    });
                }
                return flagged.slice(0, 10); // Limit to top 10
            },

            /**
             * Generates hash for product deduplication
             * @param {Object} analysis - Analysis result
             * @returns {string} Hash string
             */
            generateProductHash(analysis) {
                const key = (analysis.barcode || '') + '|' + 
                            (analysis.productName || '').toLowerCase().trim() + '|' +
                            (analysis.brand || '').toLowerCase().trim();
                // Simple hash function
                let hash = 0;
                for (let i = 0; i < key.length; i++) {
                    const char = key.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return 'ph_' + Math.abs(hash).toString(36);
            },

            /**
             * Updates aggregate statistics from scan history
             * @param {Array} history - Full scan history
             */
            updateScanAggregates(history) {
                try {
                    const now = new Date();
                    const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
                    
                    const aggregates = {
                        total_scans: history.length,
                        unique_products: new Set(history.map(h => h.product_hash)).size,
                        
                        // Score distribution
                        score_distribution: {
                            excellent: 0,
                            good: 0,
                            fair: 0,
                            poor: 0,
                            very_poor: 0,
                            unknown: 0
                        },
                        
                        // Time-based metrics
                        scans_this_week: history.filter(h => new Date(h.timestamp) > weekAgo).length,
                        
                        // Ingredient concerns frequency
                        top_concerns: {},
                        
                        // Average health score
                        avg_health_score: null,
                        
                        // Last updated
                        updated_at: now.toISOString()
                    };
                    
                    // Calculate distributions
                    let scoreSum = 0;
                    let scoreCount = 0;
                    
                    history.forEach(scan => {
                        // Score distribution
                        if (scan.score_category) {
                            aggregates.score_distribution[scan.score_category]++;
                        }
                        
                        // Average score
                        if (scan.health_score !== null) {
                            scoreSum += scan.health_score;
                            scoreCount++;
                        }
                        
                        // Concern frequency
                        if (scan.flagged_ingredients) {
                            scan.flagged_ingredients.forEach(ing => {
                                aggregates.top_concerns[ing] = (aggregates.top_concerns[ing] || 0) + 1;
                            });
                        }
                    });
                    
                    // Calculate average
                    aggregates.avg_health_score = scoreCount > 0 ? Math.round(scoreSum / scoreCount) : null;
                    
                    // Sort and limit concerns
                    const sortedConcerns = Object.entries(aggregates.top_concerns)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10);
                    aggregates.top_concerns = Object.fromEntries(sortedConcerns);
                    
                    this.safeLocalStorageSet('eitaki_scan_aggregates', JSON.stringify(aggregates));
                    
                } catch (e) {
                    console.error('Failed to update scan aggregates:', e);
                }
            },

            /**
             * Gets user insights based on scan history and behavior
             * This is the foundation of the "Continuous Value Engine"
             * @returns {Object} Insights object with recommendations
             */
            getInsights() {
                try {
                    const profile = this.getUserProfile();
                    const history = this.getFullScanHistory();
                    const aggregates = JSON.parse(localStorage.getItem('eitaki_scan_aggregates') || '{}');
                    const events = this.getEvents();
                    
                    const insights = {
                        // User engagement tier
                        engagement_tier: this.calculateEngagementTier(profile, history, events),
                        
                        // Inferred health concerns
                        inferred_concerns: this.inferHealthConcerns(history, aggregates),
                        
                        // Usage patterns
                        usage_patterns: this.analyzeUsagePatterns(events),
                        
                        // Retention signals
                        retention_signals: this.calculateRetentionSignals(profile, history, events),
                        
                        // Recommendations
                        recommendations: [],
                        
                        // Generated timestamp
                        generated_at: new Date().toISOString()
                    };
                    
                    // Generate recommendations based on insights
                    insights.recommendations = this.generateRecommendations(insights, profile, history);
                    
                    return insights;
                    
                } catch (e) {
                    console.error('Failed to generate insights:', e);
                    return { error: e.message };
                }
            },

            /**
             * Calculates user engagement tier
             * @returns {string} 'new' | 'casual' | 'regular' | 'power'
             */
            calculateEngagementTier(profile, history, events) {
                const daysSinceCreation = (Date.now() - new Date(profile.created_at).getTime()) / (1000 * 60 * 60 * 24);
                const totalScans = history.length;
                const scansPerDay = daysSinceCreation > 0 ? totalScans / daysSinceCreation : totalScans;
                
                if (daysSinceCreation < 7) return 'new';
                if (scansPerDay >= 1) return 'power';
                if (scansPerDay >= 0.3) return 'regular';  // ~2 scans/week
                return 'casual';
            },

            /**
             * Infers health concerns from scan patterns
             * @returns {Array} Array of concern objects
             */
            inferHealthConcerns(history, aggregates) {
                const concerns = [];
                
                // Analyze top flagged ingredients
                if (aggregates.top_concerns) {
                    const topConcerns = Object.entries(aggregates.top_concerns)
                        .slice(0, 3)
                        .map(([ingredient, count]) => ({
                            ingredient,
                            frequency: count,
                            inferred_concern: this.mapIngredientToConcern(ingredient)
                        }));
                    concerns.push(...topConcerns);
                }
                
                // Analyze score patterns
                if (aggregates.avg_health_score !== null) {
                    if (aggregates.avg_health_score < 50) {
                        concerns.push({
                            type: 'score_pattern',
                            message: 'Many scanned products have low health scores',
                            inferred_concern: 'general_health'
                        });
                    }
                }
                
                return concerns;
            },

            /**
             * Maps ingredient to health concern category
             */
            mapIngredientToConcern(ingredient) {
                const lowerIng = ingredient.toLowerCase();
                
                if (/sugar|glucose|fructose|sucrose/i.test(lowerIng)) return 'sugar_intake';
                if (/sodium|salt/i.test(lowerIng)) return 'sodium_intake';
                if (/msg|monosodium/i.test(lowerIng)) return 'additives';
                if (/artificial|color|dye/i.test(lowerIng)) return 'artificial_additives';
                if (/palm oil|trans fat|hydrogenated/i.test(lowerIng)) return 'unhealthy_fats';
                if (/preservative|bha|bht|nitrate/i.test(lowerIng)) return 'preservatives';
                
                return 'general';
            },

            /**
             * Analyzes usage patterns from events
             */
            analyzeUsagePatterns(events) {
                const patterns = {
                    preferred_scan_mode: 'unknown',
                    active_hours: [],
                    feature_usage: {}
                };
                
                if (events.length === 0) return patterns;
                
                // Analyze scan mode preference
                const modeEvents = events.filter(e => e.event === 'scan_complete');
                const modeCounts = { barcode: 0, ingredients: 0 };
                modeEvents.forEach(e => {
                    if (e.metadata?.mode) {
                        modeCounts[e.metadata.mode]++;
                    }
                });
                patterns.preferred_scan_mode = modeCounts.barcode > modeCounts.ingredients ? 'barcode' : 'ingredients';
                
                // Analyze active hours
                const hourCounts = new Array(24).fill(0);
                events.forEach(e => {
                    const hour = new Date(e.timestamp).getHours();
                    hourCounts[hour]++;
                });
                
                // Get top 3 active hours
                const sortedHours = hourCounts
                    .map((count, hour) => ({ hour, count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3)
                    .filter(h => h.count > 0)
                    .map(h => h.hour);
                
                patterns.active_hours = sortedHours;
                
                return patterns;
            },

            /**
             * Calculates retention signals
             */
            calculateRetentionSignals(profile, history, events) {
                const now = Date.now();
                const daysSinceLastActive = (now - new Date(profile.last_active).getTime()) / (1000 * 60 * 60 * 24);
                const daysSinceLastScan = history.length > 0 
                    ? (now - new Date(history[0].timestamp).getTime()) / (1000 * 60 * 60 * 24)
                    : null;
                
                return {
                    days_since_last_active: Math.round(daysSinceLastActive * 10) / 10,
                    days_since_last_scan: daysSinceLastScan !== null ? Math.round(daysSinceLastScan * 10) / 10 : null,
                    total_sessions: events.filter(e => e.event === 'app_open').length,
                    churn_risk: daysSinceLastActive > 14 ? 'high' : daysSinceLastActive > 7 ? 'medium' : 'low'
                };
            },

            /**
             * Generates actionable recommendations
             */
            generateRecommendations(insights, profile, history) {
                const recommendations = [];
                
                // For new users
                if (insights.engagement_tier === 'new') {
                    recommendations.push({
                        type: 'onboarding',
                        message: 'Try scanning a product you regularly buy',
                        priority: 'high'
                    });
                }
                
                // For users with health concerns
                if (insights.inferred_concerns.length > 0) {
                    const topConcern = insights.inferred_concerns[0];
                    if (topConcern.inferred_concern === 'sugar_intake') {
                        recommendations.push({
                            type: 'health_tip',
                            message: 'Looking for lower sugar alternatives? Try scanning similar products to compare.',
                            priority: 'medium'
                        });
                    }
                }
                
                // For at-risk users
                if (insights.retention_signals.churn_risk === 'high') {
                    recommendations.push({
                        type: 'engagement',
                        message: 'We miss you! Scan a product today to stay on top of your health goals.',
                        priority: 'high'
                    });
                }
                
                // For power users (premium candidates)
                if (insights.engagement_tier === 'power' && history.length > 30) {
                    recommendations.push({
                        type: 'premium_signal',
                        message: 'Power user identified - candidate for premium features',
                        priority: 'low',
                        internal_only: true
                    });
                }
                
                return recommendations;
            },

            addToRecentScans(analysis) {
                // C1: Don't save ingredients-only scans to history
                if (this.scanMode === 'ingredients' || 
                    analysis.productName?.includes('Unknown') ||
                    analysis.productName?.includes('ingredients only')) {
                    console.log('Ingredients-only scan - not saving to history');
                    
                    // Still track the event for analytics (NEW - Auth Strategy v1.1)
                    this.trackEvent(this.ANALYTICS_EVENTS.SCAN_COMPLETE, {
                        mode: 'ingredients',
                        saved_to_history: false
                    });
                    return;
                }
                
                // Enhanced scan record with analytics metadata (NEW - Auth Strategy v1.1)
                const scanRecord = {
                    id: 'scan_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6),
                    timestamp: new Date().toISOString(),
                    
                    // Product info
                    name: analysis.productName || 'Unknown Product',
                    brand: analysis.brand || null,
                    barcode: analysis.barcode || null,
                    
                    // Health data
                    health_score: analysis.healthScore || null,
                    score_category: this.getScoreCategory(analysis.healthScore),
                    
                    // Scan context
                    scan_mode: this.scanMode,
                    
                    // Extracted insights (for future recommendations)
                    categories: analysis.categories || [],
                    flagged_ingredients: this.extractFlaggedIngredients(analysis),
                    
                    // For deduplication and repeat tracking
                    product_hash: this.generateProductHash(analysis)
                };
                
                // Load existing history
                let scanHistory = this.getFullScanHistory();
                
                // Check for duplicate (same product scanned again)
                const existingIndex = scanHistory.findIndex(s => s.product_hash === scanRecord.product_hash);
                if (existingIndex !== -1) {
                    // Update existing record instead of adding duplicate
                    scanHistory[existingIndex].last_scanned = scanRecord.timestamp;
                    scanHistory[existingIndex].scan_count = (scanHistory[existingIndex].scan_count || 1) + 1;
                    // Move to top of list
                    const existing = scanHistory.splice(existingIndex, 1)[0];
                    scanHistory.unshift(existing);
                } else {
                    scanRecord.scan_count = 1;
                    scanRecord.last_scanned = scanRecord.timestamp;
                    scanHistory.unshift(scanRecord);
                }
                
                // Limit to 100 scans for storage efficiency
                scanHistory = scanHistory.slice(0, 100);
                
                // Save enhanced history
                this.safeLocalStorageSet('eitaki_scan_history', JSON.stringify(scanHistory));
                
                // Update legacy format for backward compatibility
                this.recentScans = scanHistory.slice(0, 5).map(s => ({
                    name: s.name,
                    brand: s.brand,
                    score: s.health_score,
                    timestamp: new Date(s.timestamp).getTime()
                }));
                this.safeLocalStorageSet('recent_scans', JSON.stringify(this.recentScans));
                
                // Update user profile scan count (NEW - Auth Strategy v1.1)
                this.updateUserProfile({ scan_count: scanHistory.length });
                
                // Update aggregate stats (NEW - Auth Strategy v1.1)
                this.updateScanAggregates(scanHistory);
                
                // Track event (NEW - Auth Strategy v1.1)
                this.trackEvent(this.ANALYTICS_EVENTS.SCAN_COMPLETE, {
                    mode: this.scanMode,
                    health_score: scanRecord.health_score,
                    is_repeat_scan: existingIndex !== -1,
                    saved_to_history: true
                });
                
                // Update UI
                this.renderRecentScans();
                this.updateScanHistoryDisplay();
            },

            loadRecentScans() {
                try {
                    const saved = localStorage.getItem('recent_scans');
                    if (saved) {
                        this.recentScans = JSON.parse(saved);
                        this.renderRecentScans();
                    }
                } catch (e) {
                    console.error('Failed to load recent scans:', e);
                    this.recentScans = [];
                }
            },

            renderRecentScans() {
                if (this.recentScans.length === 0) return;
                
                const container = document.getElementById('recent-scans-container');
                const itemsContainer = document.getElementById('recent-items');
                
                if (!container || !itemsContainer) return; // Null check
                
                container.style.display = 'block';
                itemsContainer.innerHTML = this.recentScans.map(scan => `
                    <div class="recent-item">
                        ${scan.name || 'Unknown Product'}
                    </div>
                `).join('');
            },

            // Donation Functions
            donate(amount) {
                this.showToast(`Thank you for your support! ‚Çπ${amount} donation feature coming soon. For now, you can support us by sharing Eitaki with friends! üíö`, 'success', 5000);
            },

            donateCustom() {
                const amount = prompt('Enter donation amount (‚Çπ):');
                if (amount && !isNaN(amount)) {
                    this.donate(amount);
                }
            },

            // Modal Functions
            closeModal() {
                document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
            },

            // v1.2.1: showSearchModal(), showEmailModal(), sendVerificationCode() removed - Phase 1.5 features

            // Loading Functions
            showLoading(message) {
                document.getElementById('loading-message').textContent = message;
                document.getElementById('loading-overlay').classList.add('active');
            },

            updateLoadingMessage(message) {
                document.getElementById('loading-message').textContent = message;
            },

            hideLoading() {
                document.getElementById('loading-overlay').classList.remove('active');
            }
        };

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });

        // Service worker registration removed - will be implemented in Phase 1.5 with Firebase
    </script>
</body>
</html>
