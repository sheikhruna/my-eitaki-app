<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#16A34A">
    <meta name="description" content="Eitaki - Decode what's really inside your products. Scan ingredients and understand what you're consuming.">
    
    <!-- Content Security Policy - Comprehensive configuration for Tesseract.js (WebAssembly + Workers) -->
    <!-- Reference: https://github.com/WebAssembly/content-security-policy -->
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self';
                   script-src 'self' 
                              'unsafe-inline'
                              'wasm-unsafe-eval'
                              https://cdn.jsdelivr.net;
                   worker-src 'self' 
                              blob: 
                              https://cdn.jsdelivr.net;
                   child-src 'self' 
                             blob:;
                   connect-src 'self'
                               data:
                               blob:
                               https://cdn.jsdelivr.net
                               https://tessdata.projectnaptha.com
                               https://world.openfoodfacts.org;
                   img-src 'self' 
                           data: 
                           blob: 
                           https:;
                   style-src 'self' 
                             'unsafe-inline'
                             https://cdn.jsdelivr.net;
                   font-src 'self' 
                            data:;
                   media-src 'self' 
                             blob:;">
    
    <title>Eitaki - Decode Every Ingredient</title>
    
    <!--
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    üå± Eitaki - Decode Every Ingredient
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    üí∞ ANALYSIS SOLUTION
    - Google Gemini Flash
    - Open Food Facts: 200K+ products
    - QuaggaJS Barcode
    
    
    üì¶ Features:
    - Barcode + Manual ingredient scanning
    - AI-powered analysis with source citations
    - Health scoring with WHO/FSSAI/FDA/FSSAI badges
    - Multi-language ingredient detection
    - Community verification (Phase 1)
    - Progressive email verification
    - Offline capability (PWA)
    
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    -->
    
    <!-- PWA Manifest: Removed inline manifest due to browser limitations with data URIs.
         Will be added as external manifest.json file in Phase 1.5 for proper PWA support. -->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* BUG #18: Natural Green Color Scheme */
            /* PRIMARY PALETTE */
            --color-brand-primary: #16A34A;  /* Eitaki Green */
            --color-brand-primary-light: #86EFAC;
            --color-brand-primary-dark: #15803D;
            
            /* HEALTH SCORE COLORS */
            --color-score-excellent: #16A34A;  /* 85-100 */
            --color-score-good: #84CC16;       /* 70-84 */
            --color-score-fair: #EAB308;       /* 50-69 */
            --color-score-poor: #F97316;       /* 35-49 */
            --color-score-very-poor: #DC2626;  /* 0-34 */
            
            /* Legacy variables mapped to new scheme */
            --deep-teal: #16A34A;
            --vibrant-coral: #FF6B6B;
            --sunshine-yellow: #FFC93C;
            --pure-white: #FFFFFF;
            --ice-blue: #F0FDF4;
            --slate: #1E293B;
            --light-slate: #64748B;
            
            /* Trust Badges */
            --trust-green: #10B981;
            --caution-yellow: #F59E0B;
            --warning-red: #EF4444;
            
            /* Functional Colors */
            --color-success: #10B981;
            --color-warning: #F59E0B;
            --color-error: #EF4444;
            
            --shadow: rgba(0, 0, 0, 0.1);
            --shadow-lg: rgba(0, 0, 0, 0.15);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #F8F9FA;
            color: #1A2E35;
            overflow-x: hidden;
            line-height: 1.6;
        }

        .app-container {
            max-width: 100%;
            min-height: 100vh;
            padding-bottom: 70px;
        }

        /* Header - v1.3 Global styling: white header, dark text */
        .header {
            background: #FFFFFF;
            color: #1A2E35;
            padding: 16px 20px;
            box-shadow: 0 2px 8px var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            font-size: 22px;
            font-weight: 700;
            display: flex;
            flex-direction: column;
            gap: 2px;
            letter-spacing: -0.5px;
        }

        .logo-name {
            font-size: 24px;
        }

        .logo-subtitle {
            font-size: 10px;
            color: #1A2E35;
            opacity: 0.85;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .logo-name { color: #1A2E35; }

        .icon-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        /* Views */
        .view {
            display: none;
            animation: fadeIn 0.3s;
        }

        .view.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Onboarding */
        .onboarding-container {
            min-height: calc(100vh - 70px);
            min-height: calc(100dvh - 70px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 24px 20px;
            text-align: center;
            box-sizing: border-box;
        }

        .onboarding-screen {
            display: none;
            max-width: 500px;
            width: 100%;
        }

        .onboarding-screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: fadeIn 0.4s;
        }

        .onboarding-icon {
            font-size: 64px;
            margin-bottom: 16px;
            flex-shrink: 0;
        }

        .onboarding-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--deep-teal);
            margin-bottom: 12px;
            line-height: 1.25;
        }

        .onboarding-subtitle {
            font-size: 14px;
            color: var(--light-slate);
            margin-bottom: 24px;
            font-style: italic;
        }

        .onboarding-text {
            font-size: 16px;
            color: var(--light-slate);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .onboarding-features {
            text-align: left;
            margin: 0 0 20px 0;
            padding: 14px 16px;
            background: rgba(22, 163, 74, 0.1);
            border-radius: 12px;
            width: 100%;
            box-sizing: border-box;
        }

        .onboarding-feature-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 10px;
            font-size: 15px;
            color: var(--slate);
            line-height: 1.4;
        }

        .onboarding-feature-item:last-child {
            margin-bottom: 0;
        }

        .onboarding-feature-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .onboarding-cta {
            width: 100%;
            font-size: 17px;
            padding: 14px 20px;
            box-sizing: border-box;
        }

        .onboarding-list {
            text-align: left;
            margin: 24px 0;
            padding: 0 20px;
        }

        .onboarding-list li {
            font-size: 16px;
            color: var(--slate);
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        /* Onboarding: fit small viewports (e.g. iPhone with browser chrome) */
        @media (max-height: 700px) {
            .onboarding-container {
                padding: 16px 20px;
                justify-content: flex-start;
                padding-top: 20px;
            }
            .onboarding-icon {
                font-size: 48px;
                margin-bottom: 12px;
            }
            .onboarding-title {
                font-size: 24px;
                margin-bottom: 8px;
            }
            .onboarding-text {
                font-size: 15px;
                margin-bottom: 14px;
            }
            .onboarding-features {
                padding: 12px 14px;
                margin-bottom: 14px;
            }
            .onboarding-feature-item {
                font-size: 14px;
                margin-bottom: 8px;
            }
            .onboarding-feature-icon {
                font-size: 18px;
            }
            .onboarding-cta {
                font-size: 16px;
                padding: 12px 16px;
            }
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
        }

        .btn-primary {
            background: var(--deep-teal);
            color: white;
            box-shadow: 0 4px 12px rgba(22, 163, 74, 0.3);
        }

        .btn-primary:hover {
            background: #15803D;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(22, 163, 74, 0.4);
        }

        .btn-secondary {
            background: var(--ice-blue);
            color: var(--deep-teal);
        }

        .btn-secondary:hover {
            background: #E0F2FE;
        }

        /* Home View - Laser Focused */
        .home-hero {
            min-height: calc(100vh - 200px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
        }

        .hero-icon {
            font-size: 120px;
            margin-bottom: 32px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .hero-title {
            font-size: 36px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 16px;
            line-height: 1.2;
        }

        .hero-subtitle {
            font-size: 18px;
            color: var(--light-slate);
            margin-bottom: 40px;
            max-width: 400px;
        }

        .scan-btn-large {
            background: linear-gradient(135deg, var(--deep-teal), #15803D);
            color: white;
            border: none;
            padding: 20px 48px;
            border-radius: 16px;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(22, 163, 74, 0.3);
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 0.5px;
        }

        .scan-btn-large:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 32px rgba(22, 163, 74, 0.4);
        }

        .secondary-action {
            margin-top: 32px;
            color: var(--light-slate);
            font-size: 16px;
        }

        .text-link {
            color: var(--deep-teal);
            text-decoration: none;
            font-weight: 600;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }

        .text-link:hover {
            border-bottom-color: var(--deep-teal);
        }

        .recent-scans {
            margin-top: 48px;
            max-width: 600px;
            width: 100%;
        }

        .recent-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--light-slate);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .recent-items {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 8px;
        }

        .recent-item {
            background: var(--ice-blue);
            padding: 12px 20px;
            border-radius: 24px;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .recent-item:hover {
            background: var(--deep-teal);
            color: white;
            transform: translateY(-2px);
        }

        /* Scanner View - Clean */
        .scanner-container {
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
        }

        .scanner-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .scanner-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 8px;
        }

        .scanner-subtitle {
            font-size: 14px;
            color: var(--light-slate);
        }

        /* v1.2.1: Old .scan-mode-toggle and .mode-btn CSS removed - using floating badge */

        .camera-preview {
            position: relative;
            width: 100%;
            aspect-ratio: 3/4;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 0 8px 24px var(--shadow-lg);
        }
        /* Optional faint scan-frame (Bug 4 UI spec) */
        .camera-preview::after {
            content: '';
            position: absolute;
            inset: 16px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            pointer-events: none;
        }

        .camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .camera-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            background: linear-gradient(135deg, var(--deep-teal), #15803D);
        }

        .placeholder-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .placeholder-text {
            font-size: 16px;
            opacity: 0.9;
        }

        .placeholder-subtext {
            font-size: 13px;
            opacity: 0.7;
            margin-top: 8px;
        }

        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .scan-guide {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .capture-area {
            border: 3px dashed var(--sunshine-yellow);
            border-radius: 12px;
            height: 200px;
            margin: 20px 0;
        }

        .camera-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 4px solid white;
            background: var(--vibrant-coral);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: white;
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
        }

        .capture-btn:hover {
            transform: scale(1.1);
        }

        .captured-images {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }

        .captured-image {
            position: relative;
            aspect-ratio: 1;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--ice-blue);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .captured-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .remove-image {
            position: absolute;
            top: 4px;
            right: 4px;
            background: var(--vibrant-coral);
            color: white;
            border: none;
            min-width: 44px;  /* BUG-016 FIX: Increased for better touch target */
            min-height: 44px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* BUG-016 FIX: Crop button touch target */
        .crop-image {
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn-full {
            flex: 1;
        }

        /* Analysis View - Clean & Focused */
        .analysis-container {
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        .product-header {
            background: var(--pure-white);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 2px 12px var(--shadow);
            margin-bottom: 20px;
            border-left: 4px solid var(--deep-teal);
        }

        .product-name {
            font-size: 24px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 8px;
        }

        .product-brand {
            font-size: 16px;
            color: var(--light-slate);
            margin-bottom: 20px;
        }

        .health-score-card {
            background: var(--ice-blue);
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .score-main {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 16px;
        }

        .score-circle {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 28px;
            color: white;
            box-shadow: 0 4px 12px var(--shadow);
            flex-shrink: 0;
        }

        .score-label {
            font-size: 11px;
            font-weight: 600;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .score-excellent { background: var(--trust-green); }
        .score-good { background: #93C47D; }
        .score-fair { background: var(--caution-yellow); }
        .score-poor { background: #F6B26B; }
        .score-bad { background: var(--warning-red); }

        .score-details {
            flex: 1;
        }

        .score-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 6px;
            color: var(--slate);
        }

        .score-desc {
            font-size: 14px;
            color: var(--light-slate);
            line-height: 1.6;
        }

        .trust-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .trust-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            background: white;
            box-shadow: 0 2px 6px var(--shadow);
        }

        .trust-badge.verified {
            color: var(--trust-green);
            border: 1.5px solid var(--trust-green);
        }

        .trust-badge.caution {
            color: var(--caution-yellow);
            border: 1.5px solid var(--caution-yellow);
        }

        .trust-badge.warning {
            color: var(--warning-red);
            border: 1.5px solid var(--warning-red);
        }

        .alert-box {
            padding: 16px;
            background: #FEE2E2;
            border: 2px solid var(--warning-red);
            border-radius: 12px;
            color: #991B1B;
            margin: 16px 0;
            font-weight: 600;
        }

        .analysis-section {
            background: var(--pure-white);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 2px 12px var(--shadow);
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--slate);
        }

        .ingredient-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .ingredient-item {
            padding: 16px;
            background: var(--ice-blue);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid var(--deep-teal);
        }

        .ingredient-item:hover {
            background: #E0F2FE;
            transform: translateX(4px);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .ingredient-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .ingredient-name {
            font-weight: 700;
            font-size: 16px;
            color: var(--slate);
        }

        .impact-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .impact-positive {
            background: #D1FAE5;
            color: #065F46;
        }

        .impact-neutral {
            background: #E5E7EB;
            color: #374151;
        }

        .impact-negative {
            background: #FEE2E2;
            color: #991B1B;
        }

        .ingredient-purpose {
            font-size: 14px;
            color: var(--light-slate);
            margin-bottom: 4px;
        }

        .ingredient-detail {
            font-size: 13px;
            color: var(--slate);
            line-height: 1.6;
        }

        /* Donation Card */
        .donation-card {
            background: linear-gradient(135deg, var(--sunshine-yellow), #FFD966);
            padding: 24px;
            border-radius: 16px;
            margin: 20px;
            box-shadow: 0 8px 24px rgba(255, 201, 60, 0.3);
            max-width: 600px;
            margin: 20px auto;
        }

        .donation-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 16px;
        }

        .donation-text {
            font-size: 15px;
            color: var(--slate);
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .donation-benefits {
            margin: 16px 0;
            padding-left: 20px;
        }

        .donation-benefits li {
            font-size: 14px;
            color: var(--slate);
            margin-bottom: 8px;
            list-style-type: disc;
        }

        .donation-amounts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .donation-btn {
            background: white;
            border: 2px solid var(--slate);
            padding: 12px;
            border-radius: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .donation-btn:hover {
            background: var(--slate);
            color: white;
            transform: translateY(-2px);
        }

        .donation-footer {
            font-size: 13px;
            color: var(--slate);
            font-style: italic;
            text-align: center;
        }

        /* Settings View */
        .settings-section {
            background: var(--pure-white);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 2px 12px var(--shadow);
            margin-bottom: 20px;
        }

        .settings-item {
            padding: 16px 0;
            border-bottom: 1px solid var(--ice-blue);
        }

        .settings-item:last-child {
            border-bottom: none;
        }

        .settings-label {
            font-weight: 600;
            color: var(--slate);
            margin-bottom: 8px;
        }

        .settings-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--ice-blue);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .settings-input:focus {
            outline: none;
            border-color: var(--deep-teal);
        }

        /* Bottom Navigation - Minimal */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--pure-white);
            border-top: 1px solid var(--ice-blue);
            display: flex;
            justify-content: space-around;
            padding: 12px 0;
            box-shadow: 0 -4px 12px var(--shadow);
            z-index: 100;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 24px;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--light-slate);
            transition: all 0.3s;
            font-size: 12px;
            font-weight: 600;
        }

        .nav-item.active {
            color: var(--deep-teal);
        }

        .nav-icon {
            font-size: 24px;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 300px;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid var(--ice-blue);
            border-top-color: var(--deep-teal);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--slate);
        }

        /* Email Verification Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 32px;
            border-radius: 20px;
            max-width: 450px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--slate);
            margin-bottom: 16px;
        }

        .modal-text {
            font-size: 15px;
            color: var(--light-slate);
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .form-input {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--ice-blue);
            border-radius: 12px;
            font-size: 16px;
            margin-bottom: 16px;
            transition: all 0.3s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--deep-teal);
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
        }

        /* Disclaimer */
        .disclaimer {
            background: var(--ice-blue);
            padding: 16px;
            border-radius: 12px;
            font-size: 13px;
            color: var(--light-slate);
            margin-top: 20px;
            border-left: 4px solid var(--deep-teal);
        }

        .disclaimer strong {
            color: var(--slate);
        }

        /* Responsive */
        @media (max-width: 640px) {
            .hero-title {
                font-size: 28px;
            }

            .hero-icon {
                font-size: 80px;
            }

            .scan-btn-large {
                font-size: 18px;
                padding: 18px 36px;
            }

            .onboarding-title {
                font-size: 28px;
            }
        }

        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           V1.2.0 NEW STYLES
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        /* Floating Mode Badge */
        .mode-badge {
            position: fixed;
            top: 80px;
            left: 16px;
            z-index: 200;
            background: rgba(22, 163, 74, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            padding: 10px 16px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(22, 163, 74, 0.3);
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            gap: 8px;
        }
        .mode-badge.visible { display: flex; }
        .mode-badge:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(22, 163, 74, 0.4); }
        .mode-badge.pulsing { animation: modePulse 2s ease-in-out infinite; }
        @keyframes modePulse {
            0%, 100% { box-shadow: 0 4px 12px rgba(22, 163, 74, 0.3); }
            50% { box-shadow: 0 4px 24px rgba(22, 163, 74, 0.6); }
        }
        .mode-badge-arrow { font-size: 10px; transition: transform 0.2s; }
        .mode-badge.menu-open .mode-badge-arrow { transform: rotate(180deg); }
        
        /* Mode Menu */
        .mode-menu {
            position: fixed;
            top: 130px;
            left: 16px;
            z-index: 199;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            padding: 8px 0;
            min-width: 180px;
            opacity: 0;
            transform: translateY(-10px) scale(0.95);
            transition: all 0.2s;
            pointer-events: none;
        }
        .mode-menu.visible { opacity: 1; transform: translateY(0) scale(1); pointer-events: auto; }
        .mode-menu-item { padding: 14px 20px; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.15s; }
        .mode-menu-item:hover { background: #F0FDF4; }
        .mode-menu-item.active { color: #16A34A; font-weight: 600; }
        
        /* Glass Bottom Bar - above bottom nav with clear spacing (Bug 4) */
        .scanner-bottom-bar {
            position: fixed;
            bottom: calc(72px + env(safe-area-inset-bottom, 0px));
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            border-radius: 40px;
            padding: 12px 24px;
            display: none;
            align-items: center;
            gap: 20px;
        }
        .scanner-bottom-bar.visible { display: flex; }
        .bar-btn {
            border: none;
            background: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            transition: transform 0.2s;
        }
        .bar-btn:hover:not(:disabled) { transform: scale(1.05); }
        .bar-btn-icon {
            position: relative;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: #F0FDF4;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .bar-btn:hover:not(:disabled) .bar-btn-icon { background: #DCFCE7; }
        .bar-btn svg { width: 24px; height: 24px; display: block; }
        .bar-btn-gallery svg { color: #475569; }
        .bar-btn.capture .bar-btn-icon {
            width: 68px;
            height: 68px;
            background: #16A34A;
            box-shadow: 0 4px 16px rgba(22,163,74,0.4);
        }
        .bar-btn.capture:hover:not(:disabled) .bar-btn-icon { background: #15803D; }
        .bar-btn.capture svg { width: 32px; height: 32px; color: white; }
        .bar-btn .badge { position: absolute; top: -4px; right: -4px; background: #EF4444; color: white; font-size: 11px; font-weight: 700; min-width: 20px; height: 20px; border-radius: 10px; display: flex; align-items: center; justify-content: center; }
        .bar-btn .bar-btn-icon { font-size: 22px; font-weight: 700; color: #16A34A; }
        .bar-btn:disabled .bar-btn-icon { color: #94A3B8; }
        .bar-btn-label { font-size: 11px; font-weight: 600; color: #475569; }
        .bar-btn.capture .bar-btn-label { color: white; }
        .bar-btn:disabled .bar-btn-label { color: #94A3B8; }
        
        /* Toast */
        .toast-container { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); z-index: 9999; pointer-events: none; }
        .toast { background: rgba(30,41,59,0.95); color: white; padding: 14px 24px; border-radius: 28px; font-size: 14px; font-weight: 500; opacity: 0; transform: translateY(20px); transition: all 0.3s; pointer-events: auto; margin-bottom: 8px; }
        .toast.visible { opacity: 1; transform: translateY(0); }
        .toast.success { background: rgba(16,185,129,0.95); }
        .toast.warning { background: rgba(245,158,11,0.95); color: #1E293B; }
        .toast.error { background: rgba(239,68,68,0.95); }
        
        /* Quality Indicator */
        .quality-indicator { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.75); color: white; padding: 8px 16px; border-radius: 24px; font-size: 12px; font-weight: 600; display: none; align-items: center; gap: 8px; }
        .quality-indicator.visible { display: flex; }
        .quality-dot { width: 8px; height: 8px; border-radius: 50%; }
        .quality-dot.good { background: #10B981; }
        .quality-dot.fair { background: #F59E0B; }
        .quality-dot.poor { background: #EF4444; }
        
        /* Auto-analyze Badge */
        .auto-analyze-badge { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(22,163,74,0.95); color: white; padding: 16px 24px; border-radius: 28px; font-size: 15px; font-weight: 600; display: none; align-items: center; gap: 10px; z-index: 20; }
        .auto-analyze-badge.visible { display: flex; animation: modePulse 1.5s infinite; }
        
        /* Confidence Badge */
        .confidence-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; margin-top: 12px; }
        .confidence-badge.high { background: rgba(16,185,129,0.15); color: #059669; }
        .confidence-badge.medium { background: rgba(245,158,11,0.15); color: #D97706; }
        .confidence-badge.low { background: rgba(239,68,68,0.15); color: #DC2626; }
        
        /* Safety Levels */
        .safety-level { display: inline-flex; align-items: center; gap: 4px; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; }
        .safety-level.safe { background: rgba(16,185,129,0.15); color: #059669; }
        .safety-level.moderate { background: rgba(245,158,11,0.15); color: #D97706; }
        .safety-level.limit { background: rgba(249,115,22,0.15); color: #EA580C; }
        .safety-level.avoid { background: rgba(239,68,68,0.15); color: #DC2626; }
        
        /* Score Explainer */
        .score-explainer { margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(0,0,0,0.1); }
        .explainer-toggle { background: none; border: none; color: #16A34A; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 4px; padding: 0; }
        .explainer-content { margin-top: 16px; padding: 16px; background: white; border-radius: 8px; display: none; }
        .explainer-content.visible { display: block; }
        .pillar-item { display: flex; align-items: center; gap: 16px; margin-bottom: 12px; }
        .pillar-weight { width: 40px; height: 40px; border-radius: 8px; background: #F0FDF4; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 700; color: #16A34A; flex-shrink: 0; }
        .pillar-name { font-size: 14px; font-weight: 600; color: #1E293B; }
        .pillar-desc { font-size: 12px; color: #64748B; }
        
        /* v1.2.2: Crop Modal */
        .crop-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            flex-direction: column;
        }
        .crop-modal.active { display: flex; }
        .crop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: rgba(0,0,0,0.5);
        }
        .crop-header h3 { color: white; margin: 0; font-size: 18px; }
        .crop-header button {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 8px;
        }
        .crop-header button:hover { background: rgba(255,255,255,0.1); }
        .crop-header .crop-done { background: #16A34A; font-weight: 600; }
        .crop-header .crop-done:hover { background: #15803D; }
        .crop-container {
            flex: 1;
            min-height: 50vh;
            overflow: hidden;
            position: relative;
            background: #000;
        }
        .crop-container img {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
        .crop-instructions {
            padding: 12px;
            text-align: center;
            color: #94A3B8;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
        }
        /* Crop preview overlay: show cropped image + Close before returning to scanner */
        .crop-preview-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1001;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .crop-preview-overlay.active { display: flex; }
        .crop-preview-card {
            background: #fff;
            border-radius: 16px;
            padding: 20px;
            max-width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }
        .crop-preview-title {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #1E293B;
        }
        .crop-preview-img {
            max-width: 100%;
            max-height: 60vh;
            object-fit: contain;
            border-radius: 12px;
        }
        /* v1.3: Confirmation popup progress ring (1500ms) */
        .progress-ring-fill {
            transition: stroke-dashoffset 1.5s linear;
        }
        #view-confirmation-popup.active .progress-ring-fill {
            stroke-dashoffset: 0;
        }
        .skeleton-cell { animation: skeleton-pulse 1.5s ease-in-out infinite; }
        @keyframes skeleton-pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }

        .crop-preview-close {
            width: 100%;
            max-width: 280px;
        }
        
        /* v1.2.2: Mini Recent Scans on Scanner Page */
        .scanner-mini-history {
            position: fixed;
            bottom: 100px;
            left: 16px;
            right: 16px;
            z-index: 140;
            display: none;
        }
        .scanner-mini-history.visible { display: block; }
        .mini-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px 12px 0 0;
        }
        .mini-history-header span { color: white; font-size: 12px; font-weight: 600; }
        .mini-history-toggle {
            background: none;
            border: none;
            color: #16A34A;
            font-size: 12px;
            cursor: pointer;
        }
        .mini-history-list {
            display: flex;
            gap: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border-radius: 0 0 12px 12px;
            overflow-x: auto;
        }
        .mini-history-item {
            flex-shrink: 0;
            width: 80px;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
        }
        .mini-history-item:hover { background: rgba(255,255,255,0.2); }
        .mini-history-score {
            font-size: 18px;
            font-weight: 700;
            color: white;
        }
        .mini-history-name {
            font-size: 10px;
            color: #94A3B8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    
    </style>
    
    <!-- BUG-001 FIX: Add Tesseract.js for OCR (ingredient scanning) -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    
    <!-- BUG-002 FIX: Add QuaggaJS for barcode scanning -->
    <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2/dist/quagga.min.js"></script>
    <!-- Cropper.js for iPhone-style crop (crop thumbnail fix) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.6.1/dist/cropper.min.css">
    <script src="https://cdn.jsdelivr.net/npm/cropperjs@1.6.1/dist/cropper.min.js"></script>
</head>
<body>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-name">üå± Eitaki</div>
                    <div class="logo-subtitle">Decode Every Ingredient</div>
                </div>
            </div>
        </header>

        <!-- Onboarding - v1.2.1: Single screen -->
        <div id="view-onboarding" class="view active">
            <div class="onboarding-container">
                <div class="onboarding-screen active" id="onboarding-1">
                    <div class="onboarding-icon">üå±</div>
                    <h1 class="onboarding-title">See Beyond the Label</h1>
                    <p class="onboarding-text">
                        Hidden sugars. Confusing labels. Not anymore.
                    </p>
                    
                    <div class="onboarding-features">
                        <div class="onboarding-feature-item">
                            <span class="onboarding-feature-icon">üì∏</span>
                            <span>Scan any product to see what it's really made of</span>
                        </div>
                        <div class="onboarding-feature-item">
                            <span class="onboarding-feature-icon">üî¨</span>
                            <span>Understand what each ingredient actually does to your body</span>
                        </div>
                        <div class="onboarding-feature-item">
                            <span class="onboarding-feature-icon">üíö</span>
                            <span>Shop smarter for you and your family</span>
                        </div>
                    </div>
                    
                    <button class="btn btn-primary onboarding-cta" onclick="app.completeOnboarding(); app.showView('scanner');">
                        Scan Your First Product ‚Üí
                    </button>
                </div>
            </div>
        </div>

        <!-- Scanner View -->
        <div id="view-scanner" class="view">
            <!-- v1.2.1: X close button -->
            <button onclick="app.showView('settings')" style="position: fixed; top: 16px; right: 16px; z-index: 200; width: 40px; height: 40px; border-radius: 50%; border: none; background: rgba(0,0,0,0.5); color: white; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center;" aria-label="Close to Preferences">
                ‚úï
            </button>
            
            <!-- Floating Mode Badge (v1.2.0) -->
            <button class="mode-badge visible" id="mode-badge" onclick="app.toggleModeMenu()" aria-label="Toggle scan mode menu" aria-expanded="false">
                <span id="mode-badge-icon">üìã</span>
                <span id="mode-badge-text">Ingredients</span>
                <span class="mode-badge-arrow">‚ñº</span>
            </button>
            <div class="mode-menu" id="mode-menu">
                <div class="mode-menu-item active" id="menu-ingredients" onclick="app.selectMode('ingredients')">üìã Ingredients</div>
                <div class="mode-menu-item" id="menu-barcode" onclick="app.selectMode('barcode')">üìä Barcode</div>
            </div>

            <div class="scanner-container">
                <div class="scanner-header">
                    <h2 class="scanner-title">Scan Product</h2>
                    <p class="scanner-subtitle" id="scanner-subtitle">Point at ingredients or barcode</p>
                </div>

                <!-- v1.2.1: Old tabs removed - using floating badge only -->

                <div class="camera-preview">
                    <video id="camera-video" class="camera-video" autoplay playsinline style="display:none;" aria-label="Camera preview"></video>
                    <div id="camera-placeholder" class="camera-placeholder">
                        <div class="placeholder-icon">üì∏</div>
                        <div class="placeholder-text">Camera will start automatically</div>
                        <div class="placeholder-subtext">Or tap Gallery below to upload</div>
                    </div>
                    
                    <div class="quality-indicator" id="quality-indicator">
                        <span class="quality-dot" id="quality-dot"></span>
                        <span id="quality-text">Checking...</span>
                    </div>
                    <div class="auto-analyze-badge" id="auto-analyze-badge">‚ú® Auto-analyzing...</div>
                    <div class="camera-overlay" style="display:none;" id="camera-overlay">
                        <div class="scan-guide" role="status" aria-live="polite" id="scan-guide-text">
                            Point at ingredients or barcode
                        </div>
                        <div class="capture-area" aria-hidden="true"></div>
                    </div>
                </div>

                <div class="captured-images" id="captured-images" role="list" aria-label="Captured images"></div>

                <!-- Hidden file input for "Upload from Gallery" on camera error card (opens crop ‚Üí analyze) -->
                <input type="file" id="file-input-fallback" accept="image/*" style="display: none;" onchange="app.handleGalleryUpload(event)">

                <!-- Scanner result area: quality feedback and error cards -->
                <div id="scanner-result" style="display: none;"></div>

                <!-- v1.2.0: Old action buttons removed - using glass morphism bottom bar instead -->
            </div>
        
            <!-- Glass Morphism Bottom Bar (v1.2.0). Patterns: tap = photo, long-press reserved for video/burst; gallery = camera + uploads. -->
            <div class="scanner-bottom-bar" id="scanner-bottom-bar">
                <button type="button" class="bar-btn bar-btn-gallery" onclick="app.openGallery()" aria-label="Gallery">
                    <span class="bar-btn-icon">
                        <svg class="icon-gallery" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/>
                            <rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/>
                        </svg>
                        <span class="badge" id="photo-count-badge" style="display:none;">0</span>
                    </span>
                    <span class="bar-btn-label">Gallery</span>
                </button>
                <button type="button" class="bar-btn capture" id="capture-btn-main" onclick="app.capturePhoto()" oncontextmenu="return false;" aria-label="Capture photo (hold for video in future)">
                    <span class="bar-btn-icon">
                        <svg class="icon-capture" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/>
                        </svg>
                    </span>
                    <span class="bar-btn-label">Capture</span>
                </button>
                <button type="button" class="bar-btn" id="analyze-btn-bar" onclick="app.analyzeProduct()" aria-label="Analyze" disabled>
                    <span class="bar-btn-icon">‚úì</span>
                    <span class="bar-btn-label">Analyze</span>
                </button>
            </div>
            
            <!-- v1.2.2: Mini Recent Scans -->
            <div class="scanner-mini-history" id="scanner-mini-history">
                <div class="mini-history-header">
                    <span>üìú Recent Scans</span>
                    <button class="mini-history-toggle" onclick="app.toggleMiniHistory()">Hide</button>
                </div>
                <div class="mini-history-list" id="mini-history-list">
                    <!-- Populated dynamically -->
                </div>
            </div>

        </div>
        
        <!-- v1.2.2: Crop Modal (Cropper.js - iPhone-style crop frame + move/zoom) -->
        <div class="crop-modal" id="crop-modal">
            <div class="crop-header">
                <button onclick="app.cancelCrop()">Cancel</button>
                <h3>Crop Image</h3>
                <button class="crop-done" onclick="app.applyCrop()">Done</button>
            </div>
            <div class="crop-container" id="crop-container">
                <img id="crop-image" src="" alt="Image to crop">
            </div>
            <div class="crop-instructions">
                Adjust crop area ‚Ä¢ Zoom or move the photo ‚Ä¢ Tap Done when ready
            </div>
        </div>

        <!-- Crop preview: show cropped image + Close before returning to scanner -->
        <div class="crop-preview-overlay" id="crop-preview-overlay">
            <div class="crop-preview-card">
                <p class="crop-preview-title">Cropped image</p>
                <img id="crop-preview-image" src="" alt="Cropped result" class="crop-preview-img">
                <button type="button" class="btn btn-primary crop-preview-close" onclick="app.closeCropPreview()">Close</button>
            </div>
        </div>

        <!-- Analysis View -->
        <!-- v1.3: Empty state (0 results) -->
        <div id="view-empty-state" class="view">
            <div class="analysis-container">
                <div style="text-align: center; padding: 40px 24px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">üì¶</div>
                    <h2 style="font-size: 22px; font-weight: 700; color: #1A2E35; margin-bottom: 12px;">Product not found.</h2>
                    <p style="color: #64748B; margin-bottom: 28px;">We couldn't find this product in our database.</p>
                    <button type="button" class="btn btn-primary" onclick="app.showToast('Coming soon', 'info')" style="width: 100%; margin-bottom: 12px;">Add Missing Product</button>
                    <button type="button" class="btn btn-secondary" onclick="app.showToast('Coming soon', 'info')" style="width: 100%; margin-bottom: 24px;">Report Missing</button>
                    <button type="button" class="btn btn-secondary" onclick="app.showView('scanner')" style="width: 100%;">‚Üê Back to Scanner</button>
                </div>
            </div>
        </div>

        <!-- v1.3: Confirmation popup (1 result ‚Äì 1.5s then analysis) -->
        <div id="view-confirmation-popup" class="view">
            <div class="analysis-container">
                <div class="confirmation-card" style="text-align: center; padding: 48px 24px;">
                    <div class="progress-ring-wrap" style="margin: 0 auto 24px;">
                        <svg class="progress-ring" width="80" height="80" viewBox="0 0 80 80" aria-hidden="true">
                            <circle class="progress-ring-bg" cx="40" cy="40" r="36" fill="none" stroke="#E5E7EB" stroke-width="6"/>
                            <circle class="progress-ring-fill" cx="40" cy="40" r="36" fill="none" stroke="#16A34A" stroke-width="6" stroke-dasharray="226" stroke-dashoffset="226" stroke-linecap="round" transform="rotate(-90 40 40)"/>
                        </svg>
                    </div>
                    <h2 style="font-size: 22px; font-weight: 700; color: #1A2E35; margin-bottom: 8px;">Found it!</h2>
                    <p style="color: #64748B; margin-bottom: 0;">Analyzing ingredients...</p>
                </div>
            </div>
        </div>

        <!-- v1.3: Product list (2+ results ‚Äì tap to open analysis) -->
        <div id="view-product-list" class="view">
            <div class="analysis-container">
                <h2 style="font-size: 20px; font-weight: 700; color: #1A2E35; margin-bottom: 16px;">Select Product</h2>
                <div id="product-results-container" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- Cards rendered by JS when 2+ results -->
                </div>
                <button type="button" class="btn btn-secondary" onclick="app.showView('scanner')" style="width: 100%; margin-top: 20px;">‚Üê Back to Scanner</button>
            </div>
        </div>

        <!-- Analysis View -->
        <div id="view-analysis" class="view">
            <div class="analysis-container" id="analysis-content" role="main">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Settings View - BUG #11: Simplified Profile -->
        <div id="view-settings" class="view">
            <div class="analysis-container">
                <h2 class="section-title">‚öôÔ∏è Settings</h2>
                
                <!-- BUG #11: Simplified Profile Section -->
                <div class="settings-section">
                    <h3 style="margin-bottom: 16px;">üì∏ Profile</h3>
                    <div class="settings-item">
                        <div class="settings-label">Name</div>
                        <input type="text" class="settings-input" id="setting-name" placeholder="Your name">
                    </div>
                    <div class="settings-item">
                        <div class="settings-label">Food Allergies</div>
                        <input type="text" class="settings-input" id="setting-allergies" placeholder="e.g., peanuts, dairy, gluten">
                        <p style="font-size: 12px; color: var(--light-slate); margin-top: 4px;">
                            Separate multiple allergies with commas
                        </p>
                    </div>
                    <button class="btn btn-primary" onclick="app.saveSettings()" style="margin-top: 16px; width: 100%;">
                        Save Settings
                    </button>
                </div>

                <!-- Scan History (Simplified) -->
                <div class="settings-section">
                    <h3 style="margin-bottom: 16px;">üìú Scan History</h3>
                    <div id="scan-history-list" style="max-height: 200px; overflow-y: auto;">
                        <p style="color: var(--light-slate); font-size: 14px;">Your recent scans will appear here.</p>
                    </div>
                </div>

                <!-- BUG #13: About & Legal Section -->
                <div class="settings-section">
                    <h3 style="margin-bottom: 16px;">‚ÑπÔ∏è About & Legal</h3>
                    <div style="background: #F0FDF4; padding: 12px; border-radius: 8px; margin-bottom: 16px; border-left: 4px solid #16A34A;">
                        <strong>üß™ Beta Version</strong><br>
                        Testing with early users. Community features launching soon!
                    </div>
                    <p style="line-height: 1.8; color: var(--slate); margin-bottom: 16px;">
                        Eitaki helps you decode what's really inside the products you use every day. From Delhi to Dubai, Mumbai to Manhattan‚Äîwe believe everyone deserves food transparency.
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <a href="#" onclick="app.showAbout(); return false;" style="color: #16A34A;">üå± About Eitaki</a>
                        <a href="#" onclick="app.showMethodology(); return false;" style="color: #16A34A;">üî¨ How We Calculate Scores</a>
                        <a href="#" onclick="app.showPrivacyPolicy(); return false;" style="color: #16A34A;">üîí Privacy Policy</a>
                        <a href="#" onclick="app.showTerms(); return false;" style="color: #16A34A;">üìã Terms of Service</a>
                    </div>
                </div>

                <div class="settings-section">
                    <h3 style="margin-bottom: 16px;">üîí Data & Privacy</h3>
                    <p style="line-height: 1.8; color: var(--slate); margin-bottom: 16px;">
                        ‚Ä¢ Your personal information is never sold or shared<br>
                        ‚Ä¢ We use industry-standard security practices<br>
                        ‚Ä¢ Analytics are anonymous and used only to improve the app<br>
                        ‚Ä¢ You control your data‚Äîdelete anytime below
                    </p>
                    <button class="btn btn-secondary" onclick="app.clearAllData()" style="width: 100%;">
                        Clear My Data
                    </button>
                </div>
            </div>
        </div>

        <!-- BUG #13: About Us Page -->
        <div id="view-about" class="view">
            <div class="analysis-container">
                <div style="max-width: 600px; margin: 0 auto; line-height: 1.8;">
                    <h1 style="font-size: 28px; font-weight: 700; margin-bottom: 24px; color: #111827;">
                        About Eitaki
                    </h1>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            üå± Our Mission
                        </h2>
                        <p style="color: #374151; margin-bottom: 12px;">
                            Everyone who consumes packaged products deserves to understand what's inside them.
                        </p>
                        <p style="color: #374151; margin-bottom: 12px;">
                            Ingredient lists can be confusing‚Äîlong chemical names, unfamiliar codes, and tiny print make it hard to know what you're really eating.
                        </p>
                        <p style="color: #374151;">
                            From Delhi to Dubai, Mumbai to Manhattan, Bangalore to Boston‚ÄîEitaki helps you decode ingredients, make intelligent choices, and keep your family safe.
                        </p>
                    </section>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            üíö Why We Exist
                        </h2>
                        <p style="color: #374151;">
                            Reading ingredient labels shouldn't require a chemistry degree. We believe transparency should be accessible to everyone‚Äîwhether you're shopping at a local store or browsing online from your couch.
                        </p>
                    </section>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            üî¨ How It Works
                        </h2>
                        <ol style="padding-left: 20px; color: #374151;">
                            <li style="margin-bottom: 8px;"><strong>Scan</strong>: Point your camera at any ingredient list</li>
                            <li style="margin-bottom: 8px;"><strong>Learn</strong>: Get instant analysis of what's inside</li>
                            <li style="margin-bottom: 8px;"><strong>Decide</strong>: Make informed choices for your family</li>
                            <li><strong>Contribute</strong>: (Optional) Help others by adding products</li>
                        </ol>
                    </section>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            ü§ù Our Values
                        </h2>
                        <div style="margin-bottom: 12px;">
                            <strong style="color: #111827;">üå± Built for Everyone, Everywhere</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">Free ingredient transparency for all</span>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <strong style="color: #111827;">üíö Honest & Transparent</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">We share sources, admit limitations, and never hide our methods</span>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <strong style="color: #111827;">ü§ù Community-Powered</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">Built by people who care, for people who care</span>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <strong style="color: #111827;">üìö Educational, Not Judgmental</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">We provide facts, you make choices</span>
                        </div>
                        <div>
                            <strong style="color: #111827;">üî¨ Evidence-Based</strong><br>
                            <span style="color: #6B7280; font-size: 14px;">Every rating backed by WHO, FSSAI, and peer-reviewed research</span>
                        </div>
                    </section>
                    
                    <section style="margin-bottom: 32px;">
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            ‚öôÔ∏è The Technology
                        </h2>
                        <p style="color: #374151; margin-bottom: 12px;">
                            Eitaki uses AI technology to read ingredient lists and cross-reference them with health and safety databases.
                        </p>
                        <p style="color: #374151; font-style: italic; font-size: 14px;">
                            Remember: AI accuracy depends on photo quality. Clear photos help us deliver reliable results.
                        </p>
                    </section>
                    
                    <section>
                        <h2 style="font-size: 20px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                            üì¨ Get in Touch
                        </h2>
                        <p style="color: #374151; margin-bottom: 12px;">
                            Questions? Feedback? We'd love to hear from you!
                        </p>
                        <a href="https://forms.gle/vnhGDgAVUUeid1SY8" style="color: #16A34A; text-decoration: underline;">
                            Share Feedback
                        </a>
                    </section>
                </div>
                
                <div style="text-align: center; margin-top: 32px;">
                    <button class="btn btn-secondary" onclick="app.showView('scanner')">‚Üê Back</button>
                </div>
            </div>
        </div>

        <!-- BUG #19: Footer with Legal Disclaimer (shown in analysis view) -->
        <footer id="app-footer" style="display: none; background: #F9FAFB; padding: 24px; text-align: center; border-top: 1px solid #E5E7EB; margin-bottom: 70px;">
            <div style="max-width: 600px; margin: 0 auto;">
                <div style="background: #FEF3C7; border-left: 4px solid #F59E0B; padding: 16px; border-radius: 8px; text-align: left; margin-bottom: 20px;">
                    <strong style="color: #92400E; display: block; margin-bottom: 8px;">
                        ‚ö†Ô∏è IMPORTANT DISCLAIMER
                    </strong>
                    <p style="font-size: 13px; color: #78350F; margin: 0; line-height: 1.6;">
                        Eitaki provides educational information about food ingredients based on publicly available research and regulatory data. This information is NOT medical advice and should not replace consultation with a qualified healthcare professional. By using Eitaki, you acknowledge that you use this information at your own risk.
                    </p>
                </div>
                
                <div style="font-size: 13px; color: #6B7280; margin-bottom: 16px;">
                    <a href="#" onclick="app.showAbout(); return false;" style="color: #16A34A; margin: 0 12px;">About</a>
                    <a href="#" onclick="app.showPrivacyPolicy(); return false;" style="color: #16A34A; margin: 0 12px;">Privacy</a>
                    <a href="#" onclick="app.showTerms(); return false;" style="color: #16A34A; margin: 0 12px;">Terms</a>
                </div>
                
                <div style="font-size: 12px; color: #9CA3AF;">
                    Made with üíö by people who believe you deserve to know what you're consuming
                </div>
            </div>
        </footer>

        <!-- Bottom Navigation (hidden on onboarding): Scan + Preferences only. v1.3: inline SVG icons -->
        <nav id="bottom-nav" class="bottom-nav" role="navigation" aria-label="Main navigation">
            <button class="nav-item" onclick="app.showView('scanner')" aria-label="Scan product">
                <span class="nav-icon" aria-hidden="true">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
                </span>
                <span>Scan</span>
            </button>
            <button class="nav-item" onclick="app.showView('settings')" aria-label="Preferences">
                <span class="nav-icon" aria-hidden="true">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                </span>
                <span>Preferences</span>
            </button>
        </nav>

        
        <!-- Toast Container (v1.2.0) -->
        <div class="toast-container" id="toast-container"></div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loading-overlay" role="alert" aria-live="assertive">
            <div class="loading-content">
                <div class="spinner" aria-hidden="true"></div>
                <div class="loading-text" id="loading-message">Analyzing product...</div>
            </div>
        </div>

        <!-- v1.2.1: Email Verification Modal removed - Phase 1.5 feature -->
    </div>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Error Codes System: actionable error messages (UX #2: analysis-type errors show no CTAs on card)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const ERROR_CODES = {
            CAMERA_DENIED: {
                code: 'ERR_001',
                title: 'üì∑ Camera Access Needed',
                message: 'Eitaki needs camera access to scan products. Camera permission was previously denied.',
                // Additional Fix #4: Instructions set dynamically in showError() via getCameraPermissionInstructions()
                actions: [],
                fallback: 'Or upload a photo from your gallery instead',
                showSettingsButton: true
            },
            CAMERA_UNAVAILABLE: {
                code: 'ERR_002',
                title: 'üì∑ Camera Not Available',
                message: 'Your device camera couldn\'t be accessed.',
                actions: [
                    'Check if another app is using the camera',
                    'Try closing other camera apps',
                    'Restart your browser'
                ],
                fallback: 'You can upload a photo from gallery'
            },
            // No fallback/CTA on card ‚Äî user uses scanner bar (Gallery, Capture, Analyze)
            ANALYSIS_FAILED: {
                code: 'ERR_005',
                title: 'üî¨ Analysis Failed',
                message: 'We couldn\'t analyze this image.',
                actions: [
                    'Check your internet connection',
                    'Try taking a clearer photo',
                    'Make sure the ingredient list is visible'
                ]
            },
            BARCODE_NOT_FOUND: {
                code: 'ERR_003',
                title: 'üìä Product Not Found',
                message: 'This barcode isn\'t in our database yet.',
                actions: [
                    'Try scanning the ingredient list instead',
                    'Help by adding this product later'
                ]
            },
            OCR_NOT_LOADED: {
                code: 'ERR_OCR_INIT',
                title: '‚ö†Ô∏è Scanner Not Ready',
                message: 'The text recognition system is still loading. Please wait a moment and try again.',
                actions: [
                    'Wait 10 seconds for scanner to initialize',
                    'Refresh the page if problem persists',
                    'Check your internet connection (scanner needs to download first time)'
                ]
            },
            NETWORK_ERROR: {
                code: 'ERR_NETWORK',
                title: 'üì° Connection Lost',
                message: 'We couldn\'t reach our servers. Check your internet connection.',
                actions: [
                    'Verify you\'re connected to WiFi or mobile data',
                    'Try switching networks',
                    'Restart your browser'
                ]
            }
        };

        const app = {
            currentView: 'onboarding',
            onboardingStep: 1,
            cameraActive: false,
            cameraPermissionDenied: false, // C2: Cache permission denial
            capturedImages: [],
            stream: null,
            scanCount: 0,
            recentScans: [],
            scanMode: 'ingredients',  // v1.2.0: Default to ingredients mode (our differentiator)
            userSettings: {},
            lastAnalysisConfidence: 100,  // BUG #5: Track confidence for display
            // v1.2.2: Crop state
            cropImageData: null,
            cropperInstance: null,
            pendingCroppedImage: null,
            pendingCropEditIndex: null,
            miniHistoryVisible: true,
            debugMode: true, // DEBUG MODE: Always enabled for troubleshooting
            // Fix #1: Operation guards to prevent concurrent async operations
            isAnalyzing: false,
            isInitializingBarcode: false,
            // Fix #2: Quagga handler cleanup to prevent duplicate event listeners
            quaggaInitialized: false,
            quaggaDetectedHandler: null,
            // Fix #3: Timer tracking to cancel pending operations on navigation
            autoAnalyzeTimer: null,
            cameraStartTimer: null,
            // Additional fixes: Request cancellation
            currentAbortController: null, // For API request cancellation
            ocrCancelled: false, // For OCR cancellation
            // v1.3: Three-gate flow ‚Äì pending analysis for confirmation popup
            pendingAnalysisData: null,
            pendingAnalysisCallback: null,
            confirmationTimer: null,
            productListResults: [], // 2+ results for product-list view

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // ANALYTICS MODULE - Phase 1 Anonymous Tracking
            // Implemented: 2024-12-19 (Auth Strategy v1.1)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            /**
             * Generates a UUID v4 for anonymous user identification
             * @returns {string} UUID in format xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
             */
            generateUserId() {
                // Use crypto API if available (more secure), fallback to Math.random
                if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                    return crypto.randomUUID();
                }
                // Fallback for older browsers
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            },

            /**
             * Gets or creates the anonymous user profile
             * @returns {Object} User profile with eitaki_uid and metadata
             */
            getUserProfile() {
                try {
                    const stored = localStorage.getItem('eitaki_user_profile');
                    if (stored) {
                        const profile = JSON.parse(stored);
                        // Update last_active on each access
                        profile.last_active = new Date().toISOString();
                        this.safeLocalStorageSet('eitaki_user_profile', JSON.stringify(profile));
                        return profile;
                    }
                    
                    // Create new profile for first-time users
                    const newProfile = {
                        eitaki_uid: this.generateUserId(),
                        created_at: new Date().toISOString(),
                        last_active: new Date().toISOString(),
                        app_version: '1.0.0',  // Update with each release
                        device_category: this.detectDeviceCategory(),
                        scan_count: 0,
                        onboarding_completed: false,
                        // Migration preparation
                        migrated_to_firebase: false,
                        firebase_uid: null
                    };
                    
                    this.safeLocalStorageSet('eitaki_user_profile', JSON.stringify(newProfile));
                    console.log('Created new anonymous user:', newProfile.eitaki_uid);
                    return newProfile;
                    
                } catch (e) {
                    console.error('Failed to get/create user profile:', e);
                    this.logError('ERR_PROFILE', { error: e.message });
                    // Return minimal profile to prevent app crashes
                    return {
                        eitaki_uid: 'error-' + Date.now(),
                        created_at: new Date().toISOString(),
                        last_active: new Date().toISOString(),
                        app_version: '1.0.0',
                        device_category: 'unknown',
                        scan_count: 0,
                        onboarding_completed: false
                    };
                }
            },

            /**
             * Detects device category for analytics
             * @returns {string} 'mobile' | 'tablet' | 'desktop'
             */
            detectDeviceCategory() {
                const ua = navigator.userAgent.toLowerCase();
                if (/mobile|android|iphone|ipod|blackberry|windows phone/i.test(ua)) {
                    return 'mobile';
                }
                if (/ipad|tablet/i.test(ua)) {
                    return 'tablet';
                }
                return 'desktop';
            },

            /**
             * Updates user profile with new data
             * @param {Object} updates - Key-value pairs to update
             */
            updateUserProfile(updates) {
                try {
                    const profile = this.getUserProfile();
                    Object.assign(profile, updates, { last_active: new Date().toISOString() });
                    this.safeLocalStorageSet('eitaki_user_profile', JSON.stringify(profile));
                } catch (e) {
                    console.error('Failed to update user profile:', e);
                    this.logError('ERR_PROFILE_UPDATE', { error: e.message });
                }
            },

            /**
             * Tracks user events for analytics and retention insights
             * Events are stored in FIFO queue (max 100 events)
             * @param {string} eventName - Event identifier
             * @param {Object} metadata - Optional event-specific data
             */
            trackEvent(eventName, metadata = {}) {
                try {
                    const events = this.getEvents();
                    
                    const event = {
                        event: eventName,
                        timestamp: new Date().toISOString(),
                        session_id: this.getSessionId(),
                        metadata: metadata
                    };
                    
                    events.push(event);
                    
                    // FIFO: Keep only last 100 events to manage storage
                    const trimmedEvents = events.slice(-100);
                    
                    this.safeLocalStorageSet('eitaki_events', JSON.stringify(trimmedEvents));
                    
                    // Debug logging (remove in production)
                    if (this.debugMode) {
                        console.log('Event tracked:', eventName, metadata);
                    }
                    
                } catch (e) {
                    console.error('Failed to track event:', e);
                    // Don't call logError here to avoid infinite loop if logError uses trackEvent
                }
            },

            /**
             * Gets all stored events
             * @returns {Array} Array of event objects
             */
            getEvents() {
                try {
                    const stored = localStorage.getItem('eitaki_events');
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    console.error('Failed to get events:', e);
                    return [];
                }
            },

            /**
             * Gets or creates session ID for grouping events
             * Session expires after 30 minutes of inactivity
             * @returns {string} Session identifier
             */
            getSessionId() {
                const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
                
                try {
                    const stored = sessionStorage.getItem('eitaki_session');
                    if (stored) {
                        const session = JSON.parse(stored);
                        const now = Date.now();
                        
                        // Check if session is still valid
                        if (now - session.last_activity < SESSION_TIMEOUT) {
                            session.last_activity = now;
                            sessionStorage.setItem('eitaki_session', JSON.stringify(session));
                            return session.id;
                        }
                    }
                    
                    // Create new session
                    const newSession = {
                        id: 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        started_at: Date.now(),
                        last_activity: Date.now()
                    };
                    sessionStorage.setItem('eitaki_session', JSON.stringify(newSession));
                    
                    // Track session start
                    this.safeLocalStorageSet('eitaki_last_session', new Date().toISOString());
                    
                    return newSession.id;
                    
                } catch (e) {
                    // Fallback if sessionStorage fails
                    return 'sess_' + Date.now();
                }
            },

            /**
             * Predefined event types for consistency
             * Use these constants when calling trackEvent()
             */
            ANALYTICS_EVENTS: {
                // Onboarding
                ONBOARDING_START: 'onboarding_start',
                ONBOARDING_COMPLETE: 'onboarding_complete',
                ONBOARDING_SKIP: 'onboarding_skip',
                
                // Scanning
                SCAN_START: 'scan_start',
                SCAN_COMPLETE: 'scan_complete',
                SCAN_ERROR: 'scan_error',
                SCAN_MODE_CHANGE: 'scan_mode_change',
                
                // Features
                VIEW_CHANGE: 'view_change',
                SETTINGS_SAVE: 'settings_save',
                HISTORY_VIEW: 'history_view',
                METHODOLOGY_VIEW: 'methodology_view',
                
                // Engagement
                APP_OPEN: 'app_open',
                APP_BACKGROUND: 'app_background',
                SHARE_ATTEMPT: 'share_attempt',
                
                // Errors
                ERROR_CAMERA: 'error_camera',
                ERROR_NETWORK: 'error_network',
                ERROR_ANALYSIS: 'error_analysis'
            },

            async init() {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 1: Initialize Analytics (NEW - Auth Strategy v1.1)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // Get or create anonymous user profile
                const profile = this.getUserProfile();
                console.log('Eitaki initialized for user:', profile.eitaki_uid);
                
                // Track app open event
                this.trackEvent(this.ANALYTICS_EVENTS.APP_OPEN, {
                    returning_user: profile.scan_count > 0,
                    device: profile.device_category
                });
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // EXISTING INIT CODE (preserved)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // BUG-008 FIX: Wait for libraries to load
                await this.checkLibrariesReady();
                
                // Check if onboarding already completed
                const onboardingComplete = localStorage.getItem('onboarding_complete');
                if (onboardingComplete === 'true') {
                    this.showView('scanner');
                    if (!profile.onboarding_completed) {
                        this.updateUserProfile({ onboarding_completed: true });
                    }
                } else {
                    // Track onboarding start for new users
                    this.trackEvent(this.ANALYTICS_EVENTS.ONBOARDING_START);
                    // Hide bottom nav on onboarding screen
                    document.getElementById('bottom-nav')?.style.setProperty('display', 'none');
                }
                
                this.scanCount = parseInt(localStorage.getItem('scan_count') || '0');
                this.loadRecentScans();
                this.loadSettings();
                this.setupEventListeners();
                this.updateScanHistoryDisplay();  // BUG #11: Show scan history
                this.miniHistoryVisible = localStorage.getItem('miniHistoryVisible') !== 'false';
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PHASE 1: Load enhanced scan history (NEW)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // Migrate legacy scan history if needed
                this.migrateLegacyScanHistory();
                
                // Generate initial insights (for debugging)
                if (this.debugMode) {
                    const insights = this.getInsights();
                    console.log('User insights:', insights);
                }
                
                // Release camera when user leaves the app (avoids holding permission across tabs)
                window.addEventListener('pagehide', () => this.stopCamera());
                window.addEventListener('beforeunload', () => this.stopCamera());
            },

            setupEventListeners() {
                // BUG-012 FIX: Use capturePhoto() directly instead of legacy alias
                document.getElementById('capture-btn')?.addEventListener('click', () => this.capturePhoto());
            },

            loadSettings() {
                try {
                    const saved = localStorage.getItem('user_settings');
                    if (saved) {
                        this.userSettings = JSON.parse(saved);
                        // Populate form fields - BUG #11: Removed email and dietary preferences
                        if (document.getElementById('setting-name')) {
                            document.getElementById('setting-name').value = this.userSettings.name || '';
                            document.getElementById('setting-allergies').value = this.userSettings.allergies || '';
                        }
                    }
                } catch (e) {
                    console.error('Failed to load settings:', e);
                    this.userSettings = {};
                }
            },


            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // V1.2.0 NEW FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            QUALITY_THRESHOLDS: { AUTO_ANALYZE: 95, GOOD: 85, ACCEPTABLE: 80, MARGINAL: 75 },
            photoAttempts: 0,
            maxPhotos: 3,
            
            // BUG-008 FIX: Check if scanning libraries are loaded
            async checkLibrariesReady() {
                const maxWait = 10000; // 10 seconds timeout
                const startTime = Date.now();
                
                // Show loading indicator
                this.showToast('Loading scanning tools...', 'info', 10000);
                
                while (Date.now() - startTime < maxWait) {
                    if (typeof Tesseract !== 'undefined' && typeof Quagga !== 'undefined') {
                        this.showToast('Scanner ready! üì∏', 'success');
                        return true;
                    }
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Timeout - libraries didn't load
                // Additional Fix #3: Improved timeout message with clear action
                this.showToast('Scanner tools are taking longer than expected. Please refresh the page to try again.', 'warning', 8000);
                this.logError('ERR_LIB_TIMEOUT', { tesseract: typeof Tesseract, quagga: typeof Quagga });
                
                // Show more detailed error to help user
                setTimeout(() => {
                    this.showError('OCR_NOT_LOADED', {
                        message: 'Scanner libraries failed to load within 10 seconds. This usually means a slow internet connection.',
                        action: 'Please refresh the page (pull down to refresh on mobile) and wait for libraries to load.'
                    });
                }, 2000);
                
                return false;
            },
            
            toggleModeMenu() {
                const menu = document.getElementById('mode-menu');
                const badge = document.getElementById('mode-badge');
                const isVisible = menu?.classList.toggle('visible');
                badge?.classList.toggle('menu-open');
                
                // BUG-015 FIX: Update ARIA state for accessibility
                badge?.setAttribute('aria-expanded', isVisible);
                
                if (!localStorage.getItem('mode_badge_discovered')) {
                    this.safeLocalStorageSet('mode_badge_discovered', 'true');
                    badge?.classList.remove('pulsing');
                }
            },
            
            selectMode(mode) {
                this.scanMode = mode;
                this.safeLocalStorageSet('scan_mode', mode);
                this.updateModeUI();
                document.getElementById('mode-menu')?.classList.remove('visible');
                document.getElementById('mode-badge')?.classList.remove('menu-open');
                this.showToast(`Switched to ${mode === 'barcode' ? 'Barcode' : 'Ingredients'} mode`);
            },
            
            updateModeUI() {
                const icon = document.getElementById('mode-badge-icon');
                const text = document.getElementById('mode-badge-text');
                if (this.scanMode === 'ingredients') {
                    if (icon) icon.textContent = 'üìã';
                    if (text) text.textContent = 'Ingredients';
                    document.getElementById('menu-ingredients')?.classList.add('active');
                    document.getElementById('menu-barcode')?.classList.remove('active');
                } else {
                    if (icon) icon.textContent = 'üìä';
                    if (text) text.textContent = 'Barcode';
                    document.getElementById('menu-barcode')?.classList.add('active');
                    document.getElementById('menu-ingredients')?.classList.remove('active');
                }
            },
            
            showToast(message, type = 'info', duration = 3000) {
                const container = document.getElementById('toast-container');
                if (!container) return;
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                container.appendChild(toast);
                requestAnimationFrame(() => toast.classList.add('visible'));
                setTimeout(() => { toast.classList.remove('visible'); setTimeout(() => toast.remove(), 300); }, duration);
            },
            
            async checkPhotoQuality(imageData) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const scale = Math.min(200 / img.width, 200 / img.height);
                        canvas.width = img.width * scale;
                        canvas.height = img.height * scale;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                        let totalBrightness = 0;
                        for (let i = 0; i < data.length; i += 4) totalBrightness += (0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2]);
                        const avgBrightness = totalBrightness / (data.length / 4);
                        const brightnessScore = Math.min(100, (avgBrightness / 128) * 100);
                        let sumSquares = 0;
                        for (let i = 0; i < data.length; i += 4) { const lum = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2]; sumSquares += Math.pow(lum - avgBrightness, 2); }
                        const contrastScore = Math.min(100, (Math.sqrt(sumSquares / (data.length / 4)) / 50) * 100);
                        let laplacianSum = 0;
                        for (let y = 1; y < canvas.height - 1; y++) for (let x = 1; x < canvas.width - 1; x++) { const idx = (y * canvas.width + x) * 4; laplacianSum += Math.abs(4*data[idx] - data[idx-4] - data[idx+4] - data[idx-canvas.width*4] - data[idx+canvas.width*4]); }
                        const sharpnessScore = Math.min(100, (laplacianSum / ((canvas.width-2) * (canvas.height-2))) * 2);
                        resolve({ score: Math.round(0.4*sharpnessScore + 0.3*brightnessScore + 0.3*contrastScore) });
                    };
                    img.src = imageData;
                });
            },
            
            async handleQualityResult(quality, imageData) {
                this.photoAttempts++;
                const T = this.QUALITY_THRESHOLDS;
                if (quality.score >= T.AUTO_ANALYZE) { 
                    this.capturedImages.push(imageData); 
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    this.autoAnalyze(); 
                }
                else if (quality.score >= T.GOOD) { 
                    this.capturedImages.push(imageData); 
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    this.showToast('Great photo! üì∏', 'success'); 
                }
                else if (quality.score >= T.ACCEPTABLE) { 
                    this.capturedImages.push(imageData); 
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                }
                else if (quality.score >= T.MARGINAL && this.photoAttempts > 1) { 
                    if (confirm('Photo quality is marginal. Continue anyway?')) { 
                        this.capturedImages.push(imageData); 
                        this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                        this.showToast('Photo added with warning', 'warning'); 
                    } 
                }
                else { 
                    this.showToast('Photo too blurry. Please retake.', 'error'); 
                }
            },
            
            autoAnalyze() {
                // Fix #1: Prevent concurrent analysis operations
                if (this.isAnalyzing) {
                    console.log('Analysis already in progress, skipping auto-analyze');
                    return;
                }
                // Fix #3: Clear any existing auto-analyze timer before setting new one
                if (this.autoAnalyzeTimer) {
                    clearTimeout(this.autoAnalyzeTimer);
                    this.autoAnalyzeTimer = null;
                }
                const badge = document.getElementById('auto-analyze-badge');
                badge?.classList.add('visible');
                // Fix #3: Store timer ID so we can cancel it if user navigates away
                this.autoAnalyzeTimer = setTimeout(() => {
                    badge?.classList.remove('visible');
                    this.autoAnalyzeTimer = null; // Clear reference after execution
                    this.analyzeProduct();
                }, 800);
            },
            
            updatePhotoCountBadge() {
                const badge = document.getElementById('photo-count-badge');
                if (badge) { badge.textContent = this.capturedImages.length; badge.style.display = this.capturedImages.length > 0 ? 'flex' : 'none'; }
            },
            
            // Fix #4: Centralized function to update capturedImages state and sync all UI elements
            updateCapturedImagesState() {
                // Update the visual display of images
                this.renderCapturedImages();
                
                // Update photo count badge
                this.updatePhotoCountBadge();
                
                // Update analyze button state - enabled if photos exist, disabled if empty
                const analyzeBtn = document.getElementById('analyze-btn-bar');
                if (analyzeBtn) {
                    analyzeBtn.disabled = this.capturedImages.length === 0;
                }
            },
            
            openGallery() {
                const input = document.createElement('input');
                input.type = 'file'; input.accept = 'image/*';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            if (this.capturedImages.length < this.maxPhotos) {
                                this.capturedImages.push(ev.target.result);
                                this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                                this.showToast('Photo added', 'success');
                            } else { this.showToast('Maximum 3 photos', 'warning'); }
                        };
                        reader.readAsDataURL(file);
                    }
                };
                input.click();
            },
            
            toggleExplainer() { document.getElementById('score-explainer')?.classList.toggle('visible'); },
            
            saveSettings() {
                // BUG #11: Simplified profile - removed email and dietary preferences
                this.userSettings = {
                    name: document.getElementById('setting-name').value,
                    allergies: document.getElementById('setting-allergies').value
                };
                this.safeLocalStorageSet('user_settings', JSON.stringify(this.userSettings));
                this.showToast('Settings saved! ‚úì', 'success');
            },

            clearAllData() {
                if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                    localStorage.clear();
                    this.showToast('All data cleared. Reloading...', 'success');
                    setTimeout(() => location.reload(), 1500);
                }
            },

            // Onboarding Flow
            nextOnboarding() {
                const currentScreen = document.getElementById(`onboarding-${this.onboardingStep}`);
                currentScreen.classList.remove('active');
                
                this.onboardingStep++;
                const nextScreen = document.getElementById(`onboarding-${this.onboardingStep}`);
                nextScreen.classList.add('active');
            },

            completeOnboarding() {
                this.safeLocalStorageSet('onboarding_complete', 'true');
                this.trackEvent(this.ANALYTICS_EVENTS.ONBOARDING_COMPLETE);
                this.updateUserProfile({ onboarding_completed: true });
                // View is chosen by caller: CTA ‚Üí scanner; init (returning user) ‚Üí scanner
            },

            // View Management
            showView(viewName) {
                // Fix #3: Cancel pending timers before switching views
                if (this.autoAnalyzeTimer) {
                    clearTimeout(this.autoAnalyzeTimer);
                    this.autoAnalyzeTimer = null;
                }
                if (this.cameraStartTimer) {
                    clearTimeout(this.cameraStartTimer);
                    this.cameraStartTimer = null;
                }
                
                // Additional Fix #1: Cancel in-flight API requests if user navigates away
                if (this.currentAbortController) {
                    this.currentAbortController.abort();
                    this.currentAbortController = null;
                }
                
                // Additional Fix #2: Cancel OCR processing if user navigates away
                if (this.isAnalyzing) {
                    this.ocrCancelled = true;
                }
                
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                
                const view = document.getElementById(`view-${viewName}`);
                if (view) {
                    view.classList.add('active');
                }
                
                const navItem = document.querySelector(`.nav-item[onclick*="${viewName}"]`);
                if (navItem) {
                    navItem.classList.add('active');
                }
                
                // Hide bottom nav on onboarding and confirmation-popup; show on all other views
                const bottomNav = document.getElementById('bottom-nav');
                if (bottomNav) {
                    const hideNav = viewName === 'onboarding' || viewName === 'confirmation-popup';
                    bottomNav.style.display = hideNav ? 'none' : 'flex';
                }
                // v1.3: When leaving confirmation-popup, clear the transition timer
                if (this.currentView === 'confirmation-popup' && viewName !== 'confirmation-popup' && this.confirmationTimer) {
                    clearTimeout(this.confirmationTimer);
                    this.confirmationTimer = null;
                }
                // v1.3: When entering confirmation-popup, reset progress ring so it animates again, then start 1500ms timer
                if (viewName === 'confirmation-popup') {
                    const ringFill = document.querySelector('#view-confirmation-popup .progress-ring-fill');
                    if (ringFill) {
                        ringFill.style.strokeDashoffset = '226';
                        void ringFill.offsetHeight; // force reflow
                        ringFill.style.strokeDashoffset = '';
                    }
                    if (this.pendingAnalysisData) {
                        if (this.confirmationTimer) clearTimeout(this.confirmationTimer);
                        this.confirmationTimer = setTimeout(() => this.runConfirmationTransition(), 1500);
                    }
                }
                
                this.currentView = viewName;
                
                // Scanner view specific logic (v1.2.0)
                if (viewName === 'scanner') {
                    // UX #2: Dismiss error card when (re-)entering scanner (e.g. user taps Scanner tab)
                    this.hideError();
                    // Bug 4 / DEC-011: Mode dropdown hidden until full "unified scan" (auto-detect) is built; app uses ingredients mode only for now
                    // document.getElementById('mode-badge')?.classList.add('visible');
                    document.getElementById('scanner-bottom-bar')?.classList.add('visible');
                    this.updateModeUI();
                    this.photoAttempts = 0;
                    this.capturedImages = []; // Reset captured images
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    // Reuse existing camera stream if still live (avoids permission popup on every return)
                    const streamStillLive = this.stream && this.stream.getTracks().length > 0 &&
                        this.stream.getTracks().every(t => t.readyState === 'live');
                    if (streamStillLive) {
                        const video = document.getElementById('camera-video');
                        const placeholder = document.getElementById('camera-placeholder');
                        const overlay = document.getElementById('camera-overlay');
                        if (video) { video.srcObject = this.stream; video.style.display = 'block'; }
                        if (placeholder) placeholder.style.display = 'none';
                        if (overlay) overlay.style.display = 'flex';
                        this.cameraActive = true;
                    } else {
                        // Fix #3: Store timer ID so we can cancel it if user navigates away quickly
                        this.cameraStartTimer = setTimeout(() => {
                            this.cameraStartTimer = null;
                            this.startCamera();
                        }, 300);
                    }
                    // v1.2.2: Show mini history on scanner page
                    this.updateMiniHistory();
                } else {
                    document.getElementById('mode-badge')?.classList.remove('visible');
                    document.getElementById('mode-menu')?.classList.remove('visible');
                    document.getElementById('scanner-bottom-bar')?.classList.remove('visible');
                    document.getElementById('scanner-mini-history')?.classList.remove('visible');
                    // Do NOT stop camera when leaving scanner ‚Äî reuse stream on return to avoid permission popup
                    // stopCamera() is called on page unload (see init)
                }
                
                // Load settings when viewing settings page
                if (viewName === 'settings') {
                    this.loadSettings();
                }
                // v1.3: Render product list when entering product-list view
                if (viewName === 'product-list') {
                    this.renderProductList();
                }
                
                // Track view change event (NEW - Auth Strategy v1.1)
                this.trackEvent(this.ANALYTICS_EVENTS.VIEW_CHANGE, {
                    from: this.currentView,
                    to: viewName
                });
            },

            // v1.3: After 1500ms on confirmation-popup, show analysis and clear pending state
            runConfirmationTransition() {
                if (this.confirmationTimer) {
                    clearTimeout(this.confirmationTimer);
                    this.confirmationTimer = null;
                }
                if (!this.pendingAnalysisData) return;
                const data = this.pendingAnalysisData;
                const callback = this.pendingAnalysisCallback;
                this.pendingAnalysisData = null;
                this.pendingAnalysisCallback = null;
                this.showAnalysis(data);
                this.addToRecentScans(data);
                if (callback && typeof callback === 'function') callback();
                this.showView('analysis');
            },

            // v1.3: Product list (2+ results) ‚Äì render cards; tap ‚Üí showAnalysis(item)
            renderProductList() {
                const container = document.getElementById('product-results-container');
                if (!container) return;
                if (!this.productListResults || this.productListResults.length === 0) {
                    container.innerHTML = '<p style="color: #64748B; font-size: 14px;">No products to show. Scan a barcode to see matches here.</p>';
                    return;
                }
                container.innerHTML = this.productListResults.map((item, idx) => `
                    <button type="button" class="product-list-card" onclick="app.showAnalysisFromProductList(${idx})" style="display: flex; align-items: center; gap: 12px; width: 100%; padding: 12px; background: #F8FAFC; border: 1px solid #E2E8F0; border-radius: 12px; cursor: pointer; text-align: left;">
                        <img src="${item.image || 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'48\' height=\'48\' viewBox=\'0 0 48 48\'%3E%3Crect fill=\'%23E2E8F0\' width=\'48\' height=\'48\' rx=\'8\'/%3E%3Ctext x=\'50%25\' y=\'50%25\' dominant-baseline=\'middle\' text-anchor=\'middle\' fill=\'%2394A3B8\' font-size=\'10\'%3E?%3C/text%3E%3C/svg%3E'}" alt="" style="width: 48px; height: 48px; object-fit: cover; border-radius: 8px; flex-shrink: 0;">
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; color: #1A2E35; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${(item.productName || item.name || 'Product').substring(0, 40)}</div>
                            <div style="font-size: 12px; color: #64748B;">${(item.brand || '‚Äî').substring(0, 30)}</div>
                        </div>
                        <span style="color: #94A3B8;">‚Ä∫</span>
                    </button>
                `).join('');
            },

            showAnalysisFromProductList(index) {
                const item = this.productListResults[index];
                if (item) {
                    this.showAnalysis(item);
                    this.showView('analysis');
                }
            },

            // v1.2.1: setScanMode() removed - using selectMode() only

            // v1.2.0: Camera Functions - Auto-start, no toggle button
            async startCamera() {
                // Fix #5: Check if camera is already active
                if (this.cameraActive) return; // Already running
                
                // Fix #5: Verify we're still in scanner view before starting camera
                // This prevents camera from starting if user navigated away during the setTimeout delay
                if (this.currentView !== 'scanner') {
                    console.log('Not in scanner view, cancelling camera start');
                    return;
                }
                
                // C2: Check if permission was previously denied
                if (this.cameraPermissionDenied) {
                    this.showError('CAMERA_DENIED');
                    return;
                }
                
                const video = document.getElementById('camera-video');
                const placeholder = document.getElementById('camera-placeholder');
                const overlay = document.getElementById('camera-overlay');

                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } } 
                    });
                    
                    // Fix #5: Double-check we're still in scanner view after async getUserMedia completes
                    // User might have navigated away during the permission prompt or camera initialization
                    if (this.currentView !== 'scanner') {
                        console.log('User navigated away during camera start, cleaning up');
                        // Clean up the stream we just got
                        if (this.stream) {
                            this.stream.getTracks().forEach(track => track.stop());
                            this.stream = null;
                        }
                        return;
                    }
                    
                    video.srcObject = this.stream;
                    video.style.display = 'block';
                    placeholder.style.display = 'none';
                    overlay.style.display = 'flex';
                    
                    // Fix #5: Only set cameraActive if we're still in scanner view
                    this.cameraActive = true;
                    this.hideError();  // Clear any previous errors
                    
                    // Start barcode detection if in barcode mode
                    if (this.scanMode === 'barcode') {
                        this.startBarcodeDetection();
                    }
                    
                    // Update scan guide (unified: one message; mode dropdown hidden)
                    const guideText = document.getElementById('scan-guide-text');
                    if (guideText) {
                        guideText.textContent = 'Point at ingredients or barcode';
                    }
                } catch (err) {
                    // Fix #5: Ensure cameraActive is explicitly false on error
                    this.cameraActive = false;
                    
                    // BUG #2: Show actionable error instead of generic alert
                    this.logError('CAMERA_ERROR', { name: err.name, message: err.message });
                    if (err.name === 'NotAllowedError') {
                        this.cameraPermissionDenied = true; // C2: Cache denial
                        this.showError('CAMERA_DENIED');
                    } else if (err.name === 'NotFoundError') {
                        this.showError('CAMERA_UNAVAILABLE');
                    } else {
                        this.showError('CAMERA_UNAVAILABLE');
                    }
                    console.error('Camera error:', err);
                }
            },

            // Additional Fix #4: Detect device and get camera permission instructions
            getCameraPermissionInstructions() {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                
                if (isIOS) {
                    return [
                        '1. Open iPhone Settings app',
                        '2. Scroll down and tap "Safari" (or your browser)',
                        '3. Tap "Camera" under Permissions',
                        '4. Enable camera access for Eitaki',
                        '5. Return to Eitaki and try again'
                    ];
                } else if (isAndroid) {
                    return [
                        '1. Open your phone Settings app',
                        '2. Go to "Apps" or "App permissions"',
                        '3. Find your browser (Chrome, etc.)',
                        '4. Tap "Permissions" ‚Üí "Camera"',
                        '5. Enable camera access',
                        '6. Return to Eitaki and try again'
                    ];
                } else {
                    // Desktop/other browsers
                    return [
                        '1. Tap your browser settings (‚ãÆ)',
                        '2. Find "Site settings" or "Permissions"',
                        '3. Enable Camera for this site',
                        '4. Refresh and try again'
                    ];
                }
            },
            
            // Additional Fix #4: Open device settings (works on some mobile browsers)
            openDeviceSettings() {
                // Try to open settings - this works on some mobile browsers
                // iOS Safari: Can't programmatically open Settings, but we show instructions
                // Android Chrome: May work in some cases
                if (/Android/.test(navigator.userAgent)) {
                    // Android - try to open app settings
                    try {
                        // Some Android browsers support this
                        window.location.href = 'intent://settings#Intent;scheme=android-app;end';
                    } catch(e) {
                        // Fallback: Show instructions
                        this.showToast('Please open Settings manually and enable camera permission for your browser', 'info', 6000);
                    }
                } else {
                    // iOS or desktop - show instructions
                    this.showToast('Please open Settings manually using the instructions above', 'info', 6000);
                }
            },
            
            // BUG #2: Error display function
            // v1.2.0: Enhanced error display with auto-switch support
            // DEBUG MODE: Shows detailed error info
            showError(errorType, debugInfo = null) {
                const error = ERROR_CODES[errorType];
                if (!error) {
                    console.error('Unknown error type:', errorType);
                    return;
                }
                
                // Additional Fix #4: Get device-specific instructions for camera permission
                const errorWithActions = { ...error };
                if (errorType === 'CAMERA_DENIED') {
                    errorWithActions.actions = this.getCameraPermissionInstructions();
                }
                
                // Log error
                this.logError(error.code, { type: errorType, debugInfo });
                
                // DEBUG INFO: Build debug section if available (escape for HTML so API error bodies don't break the DOM)
                let debugSection = '';
                if (debugInfo) {
                    const debugDetails = typeof debugInfo === 'string' ? debugInfo : JSON.stringify(debugInfo, null, 2);
                    const escapeHtml = (s) => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                    const debugDetailsEscaped = escapeHtml(debugDetails);
                    window._lastDebugInfo = debugDetails;
                    debugSection = `
                        <details style="text-align: left; margin: 16px 0; padding: 12px; background: #FEF3C7; border-radius: 8px; border: 1px solid #FCD34D;">
                            <summary style="cursor: pointer; font-weight: 600; color: #92400E; margin-bottom: 8px;">
                                üîç Debug Info (Tap to expand)
                            </summary>
                            <pre style="font-size: 11px; color: #78350F; white-space: pre-wrap; word-wrap: break-word; margin: 8px 0 0 0; font-family: monospace; background: white; padding: 8px; border-radius: 4px; overflow-x: auto; max-height: 60vh; overflow-y: auto;">${debugDetailsEscaped}</pre>
                            <button type="button" onclick="app.copyDebugInfo(window._lastDebugInfo || ''); event.stopPropagation();" style="margin-top: 8px; padding: 6px 12px; background: #F59E0B; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                                üìã Copy Debug Info
                            </button>
                        </details>
                    `;
                }
                
                // UX #2: Analysis-type errors (AI/analysis failed, OCR, network, barcode not found) show NO
                // fallback text, NO "Upload from Gallery", NO "Try Again" ‚Äî user uses scanner bar instead.
                const ANALYSIS_TYPE_ERRORS = ['ANALYSIS_FAILED', 'OCR_NOT_LOADED', 'NETWORK_ERROR', 'BARCODE_NOT_FOUND'];
                const isAnalysisTypeError = ANALYSIS_TYPE_ERRORS.includes(String(errorType));
                let fallbackBlock = '';
                let tryAgainBlock = '';
                if (isAnalysisTypeError) {
                    fallbackBlock = '';
                    tryAgainBlock = '';
                } else {
                    if (errorWithActions.fallback) {
                        fallbackBlock = `
                        <p style="font-size: 14px; color: #64748B; margin-bottom: 16px;">
                            ${errorWithActions.fallback}
                        </p>
                        <button class="btn btn-secondary" onclick="app.useGalleryFallback()" style="margin-bottom: 12px; width: 100%;">
                            üìÅ Upload from Gallery
                        </button>`;
                    }
                    tryAgainBlock = `
                        <button class="btn btn-primary" onclick="app.retryCamera()" style="width: 100%;">
                            üîÑ Try Again
                        </button>`;
                }
                
                const html = `
                    <div style="padding: 24px; text-align: center; max-width: 400px; margin: 20px auto;">
                        <div style="font-size: 48px; margin-bottom: 16px;">${errorWithActions.title.split(' ')[0]}</div>
                        <h3 style="font-size: 20px; font-weight: 700; color: #1E293B; margin-bottom: 12px;">
                            ${errorWithActions.title.substring(errorWithActions.title.indexOf(' ') + 1)}
                        </h3>
                        <p style="color: #64748B; margin-bottom: 24px; line-height: 1.6;">
                            ${errorWithActions.message}
                        </p>
                        
                        <div style="background: #F0FDF4; padding: 16px; border-radius: 12px; margin-bottom: 20px; text-align: left;">
                            <strong style="color: #16A34A; display: block; margin-bottom: 8px;">How to fix:</strong>
                            <ul style="margin: 0; padding-left: 20px; color: #475569;">
                                ${errorWithActions.actions.map(action => `<li style="margin: 6px 0;">${action}</li>`).join('')}
                            </ul>
                        </div>
                        
                        ${debugSection}
                        
                        ${fallbackBlock}
                        
                        ${errorType === 'CAMERA_DENIED' ? `
                        <button class="btn btn-primary" onclick="app.openDeviceSettings()" style="width: 100%; margin-bottom: 12px; background: #16A34A;">
                            ‚öôÔ∏è Open Settings
                        </button>
                        ` : ''}
                        
                        ${tryAgainBlock}
                        
                        <p style="font-size: 12px; color: #94A3B8; margin-top: 16px;">
                            Error Code: ${errorWithActions.code}
                        </p>
                    </div>
                `;
                
                const resultContainer = document.getElementById('scanner-result');
                resultContainer.innerHTML = html;
                resultContainer.style.display = 'block';
            },

            hideError() {
                const resultContainer = document.getElementById('scanner-result');
                if (resultContainer) {
                    resultContainer.style.display = 'none';
                    resultContainer.innerHTML = '';
                }
            },

            retryCamera() {
                this.hideError();
                
                // Additional Fix #4: On iOS, once permission is denied, OS won't allow asking again
                // On Android, browser may allow asking again, but for consistency, we'll try once more
                // If it fails again, user must go to Settings
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                
                if (isIOS && this.cameraPermissionDenied) {
                    // iOS: Can't ask again, must go to Settings
                    this.showError('CAMERA_DENIED');
                    this.showToast('On iOS, you must enable camera in Settings. Tap "Open Settings" above.', 'info', 6000);
                } else {
                    // Android or first attempt: Try asking again
                    this.cameraPermissionDenied = false;
                    this.startCamera();
                }
            },

            // "Upload from Gallery" from error card (camera errors only; analysis errors use bar)
            useGalleryFallback() {
                this.hideError();
                document.getElementById('file-input-fallback').click();
            },
            
            // DEBUG MODE: Copy debug info to clipboard
            copyDebugInfo(debugText) {
                try {
                    // Try modern clipboard API
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(debugText).then(() => {
                            this.showToast('Debug info copied! üìã', 'success', 2000);
                        }).catch(() => {
                            // Fallback for iOS Safari
                            this.fallbackCopy(debugText);
                        });
                    } else {
                        this.fallbackCopy(debugText);
                    }
                } catch (e) {
                    console.error('Copy failed:', e);
                    this.showToast('Could not copy. Please screenshot instead.', 'warning', 3000);
                }
            },
            
            // Fallback copy method for iOS
            fallbackCopy(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    this.showToast('Debug info copied! üìã', 'success', 2000);
                } catch (err) {
                    this.showToast('Could not copy. Please screenshot instead.', 'warning', 3000);
                }
                document.body.removeChild(textArea);
            },

            handleGalleryUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Check max photos limit
                if (this.capturedImages.length >= 3) {
                    this.showToast('Maximum 3 photos allowed', 'warning');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    // v1.2.2: Open crop modal instead of adding directly
                    this.openCropModal(e.target.result);
                };
                reader.onerror = () => {
                    this.showToast('Failed to load image', 'error');
                };
                reader.readAsDataURL(file);
            },
            
            // v1.2.2: Crop Modal (Cropper.js - iPhone-style crop frame + move/zoom)
            openCropModal(imageData) {
                this.cropImageData = imageData;
                const modal = document.getElementById('crop-modal');
                const img = document.getElementById('crop-image');
                if (this.cropperInstance) {
                    this.cropperInstance.destroy();
                    this.cropperInstance = null;
                }
                img.src = imageData;
                img.style.transform = '';
                modal.classList.add('active');
                img.onload = () => {
                    if (this.cropperInstance) return;
                    if (typeof Cropper === 'undefined') {
                        this.showToast('Crop library loading... Please try again.', 'warning');
                        return;
                    }
                    this.cropperInstance = new Cropper(img, {
                        viewMode: 1,
                        dragMode: 'move',
                        aspectRatio: NaN,
                        autoCropArea: 0.8,
                        restore: false,
                        responsive: true,
                        checkOrientation: true,
                        guides: true,
                        center: true,
                        highlight: false,
                        cropBoxMovable: true,
                        cropBoxResizable: true,
                        toggleDragModeOnDblclick: false
                    });
                };
            },
            
            cancelCrop() {
                if (this.cropperInstance) {
                    this.cropperInstance.destroy();
                    this.cropperInstance = null;
                }
                document.getElementById('crop-modal').classList.remove('active');
                this.cropImageData = null;
            },
            
            applyCrop() {
                if (!this.cropperInstance) return;
                try {
                    const canvas = this.cropperInstance.getCroppedCanvas({ maxWidth: 2048, maxHeight: 2048, imageSmoothingQuality: 'high' });
                    if (!canvas) {
                        this.showToast('Could not crop image. Please try again.', 'error');
                        return;
                    }
                    const croppedData = canvas.toDataURL('image/jpeg', 0.9);
                    this.pendingCroppedImage = croppedData;
                    this.pendingCropEditIndex = this.cropEditIndex;
                    this.cropperInstance.destroy();
                    this.cropperInstance = null;
                    this.cropEditIndex = undefined;
                    document.getElementById('crop-modal').classList.remove('active');
                    this.cropImageData = null;
                    const previewOverlay = document.getElementById('crop-preview-overlay');
                    const previewImg = document.getElementById('crop-preview-image');
                    if (previewOverlay && previewImg) {
                        previewImg.src = croppedData;
                        previewOverlay.classList.add('active');
                    } else {
                        this.applyPendingCrop();
                    }
                } catch (e) {
                    console.error('Crop error:', e);
                    this.showToast('Crop failed. Please try again.', 'error');
                }
            },
            
            closeCropPreview() {
                this.applyPendingCrop();
                const previewOverlay = document.getElementById('crop-preview-overlay');
                const previewImg = document.getElementById('crop-preview-image');
                if (previewOverlay) previewOverlay.classList.remove('active');
                if (previewImg) previewImg.src = '';
                this.pendingCroppedImage = null;
                this.pendingCropEditIndex = null;
            },
            
            applyPendingCrop() {
                if (!this.pendingCroppedImage) return;
                if (this.pendingCropEditIndex !== undefined && this.pendingCropEditIndex >= 0) {
                    this.capturedImages[this.pendingCropEditIndex] = this.pendingCroppedImage;
                    this.updateCapturedImagesState();
                    this.showToast('Photo cropped!', 'success');
                } else {
                    this.capturedImages.push(this.pendingCroppedImage);
                    this.updateCapturedImagesState();
                    this.showToast('Photo cropped & added!', 'success');
                }
            },
            
            // v1.2.2: Mini History Functions
            updateMiniHistory() {
                const container = document.getElementById('scanner-mini-history');
                const list = document.getElementById('mini-history-list');
                
                if (!container || !list) return;
                
                // Only show if there are scans and user hasn't hidden it
                if (this.recentScans.length === 0 || !this.miniHistoryVisible) {
                    container.classList.remove('visible');
                    return;
                }
                
                container.classList.add('visible');
                
                // Show last 3 scans
                const recentThree = this.recentScans.slice(0, 3);
                list.innerHTML = recentThree.map((scan, idx) => `
                    <div class="mini-history-item" onclick="app.viewScanFromHistory(${idx})">
                        <div class="mini-history-score">${scan.score || '?'}</div>
                        <div class="mini-history-name">${scan.name || 'Unknown'}</div>
                    </div>
                `).join('');
            },
            
            toggleMiniHistory() {
                this.miniHistoryVisible = !this.miniHistoryVisible;
                this.safeLocalStorageSet('miniHistoryVisible', this.miniHistoryVisible);
                
                const container = document.getElementById('scanner-mini-history');
                const toggle = container?.querySelector('.mini-history-toggle');
                
                if (this.miniHistoryVisible) {
                    container?.classList.add('visible');
                    if (toggle) toggle.textContent = 'Hide';
                } else {
                    container?.classList.remove('visible');
                    if (toggle) toggle.textContent = 'Show';
                }
            },
            
            viewScanFromHistory(index) {
                const scan = this.recentScans[index];
                if (scan && scan.analysis) {
                    this.stopCamera();
                    this.showAnalysis(scan.analysis);
                    this.showView('analysis');
                } else {
                    this.showToast('Scan details not available', 'warning');
                }
            },
            
            // v1.2.2: Crop an already captured image
            cropExistingImage(index) {
                if (index >= 0 && index < this.capturedImages.length) {
                    this.cropEditIndex = index;
                    this.openCropModal(this.capturedImages[index]);
                }
            },
            
            stopCamera() {
                const video = document.getElementById('camera-video');
                const placeholder = document.getElementById('camera-placeholder');
                const overlay = document.getElementById('camera-overlay');
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                if (video) video.style.display = 'none';
                if (placeholder) placeholder.style.display = 'flex';
                if (overlay) overlay.style.display = 'none';
                this.cameraActive = false;
                
                // Fix #2: Cleanup Quagga handlers before stopping
                if (window.Quagga) {
                    // Remove the onDetected handler if it exists
                    if (this.quaggaDetectedHandler) {
                        try {
                            Quagga.offDetected(this.quaggaDetectedHandler);
                        } catch(e) {
                            console.warn('Failed to remove Quagga handler:', e);
                        }
                        this.quaggaDetectedHandler = null;
                    }
                    // Stop Quagga
                    try {
                        Quagga.stop();
                    } catch(e) {
                        console.warn('Failed to stop Quagga:', e);
                    }
                    this.quaggaInitialized = false;
                }
            },

            startBarcodeDetection() {
                if (!window.Quagga) return;
                
                // Fix #1: Prevent concurrent Quagga initialization
                if (this.isInitializingBarcode) {
                    console.log('Barcode detection already initializing, skipping');
                    return;
                }
                
                // Fix #7: Prevent re-initialization if Quagga is already initialized and running
                // This coordinates with Fix #2 - only re-initialize if we need to (e.g., after cleanup)
                if (this.quaggaInitialized) {
                    // Check if Quagga is actually running by verifying handler exists
                    if (this.quaggaDetectedHandler) {
                        console.log('Quagga already initialized and running, skipping re-initialization');
                        return;
                    }
                    // If initialized but no handler, something went wrong - cleanup and re-init
                    try {
                        Quagga.stop();
                    } catch(e) {
                        console.warn('Failed to stop Quagga during cleanup:', e);
                    }
                    this.quaggaInitialized = false;
                }
                
                // Fix #2: Cleanup existing handlers before re-initializing (if we get here, we need to re-init)
                if (this.quaggaDetectedHandler) {
                    try {
                        Quagga.offDetected(this.quaggaDetectedHandler);
                        Quagga.stop();
                    } catch(e) {
                        console.warn('Failed to cleanup existing Quagga instance:', e);
                    }
                    this.quaggaDetectedHandler = null;
                    this.quaggaInitialized = false;
                }
                
                this.isInitializingBarcode = true;
                
                Quagga.init({
                    inputStream: {
                        type: "LiveStream",
                        target: document.querySelector('#camera-video'),
                        constraints: {
                            facingMode: "environment"
                        }
                    },
                    decoder: {
                        readers: ["ean_reader", "ean_8_reader", "upc_reader"]
                    },
                    locate: true
                }, (err) => {
                    if (!err) {
                        Quagga.start();
                        this.isInitializingBarcode = false; // Fix #1: Reset flag after successful init
                        this.quaggaInitialized = true; // Fix #2: Mark as initialized
                    } else {
                        this.isInitializingBarcode = false; // Fix #1: Reset flag on error
                        this.quaggaInitialized = false; // Fix #2: Ensure flag is false on error
                    }
                });

                // Fix #2: Store handler reference so we can remove it later
                this.quaggaDetectedHandler = async (result) => {
                    const barcode = result.codeResult.code;
                    console.log("Barcode detected:", barcode);
                    
                    // Stop camera and barcode detection
                    this.stopCamera();
                    
                    // Try Open Food Facts first
                    this.showLoading('Looking up product...');
                    
                    try {
                        // Additional Fix #1: Create AbortController for barcode lookup
                        this.currentAbortController = new AbortController();
                        const offData = await this.queryOpenFoodFacts(barcode, this.currentAbortController.signal);
                        this.currentAbortController = null; // Clear after request completes
                        
                        if (offData && offData.found) {
                            this.hideLoading();
                            const analysis = this.convertOFFToAnalysis(offData);
                            // v1.3: Three-gate flow ‚Äì 1 result ‚Üí confirmation popup then analysis
                            this.pendingAnalysisData = analysis;
                            this.pendingAnalysisCallback = null;
                            this.showView('confirmation-popup');
                        } else {
                            this.hideLoading();
                            // v1.3: 0 results ‚Üí empty-state view
                            this.showView('empty-state');
                        }
                    } catch (error) {
                        // Additional Fix #1: Handle cancellation silently
                        if (error.name === 'AbortError') {
                            console.log('Barcode lookup cancelled - user navigated away');
                            this.hideLoading();
                            this.currentAbortController = null;
                            return;
                        }
                        // Re-throw other errors
                        this.hideLoading();
                        throw error;
                    }
                };
                
                // Fix #2: Register the stored handler
                Quagga.onDetected(this.quaggaDetectedHandler);
            },

            // v1.2.1: New capturePhoto() function with quality check and max limit
            capturePhoto() {
                // D3: Enforce 3-photo max
                if (this.capturedImages.length >= 3) {
                    this.showToast('Maximum 3 photos allowed', 'warning');
                    return;
                }
                
                const video = document.getElementById('camera-video');
                
                // Check video is fully ready
                if (!video || !this.cameraActive) {
                    this.showToast('Camera not ready. Please wait...', 'error');
                    return;
                }
                
                // Check video has actual content (not just a black frame)
                if (video.videoWidth === 0 || video.videoHeight === 0) {
                    this.showToast('Camera still loading...', 'warning');
                    return;
                }
                
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    
                    const imageData = canvas.toDataURL('image/jpeg', 0.9);
                    
                    // Verify we got actual image data (not empty)
                    if (imageData.length < 1000) {
                        this.showToast('Capture failed. Please try again.', 'error');
                        return;
                    }
                    
                    this.capturedImages.push(imageData);
                    this.updateCapturedImagesState(); // Fix #4: Use centralized state update
                    this.showToast(`Photo ${this.capturedImages.length} captured! üì∏`, 'success');
                } catch (e) {
                    console.error('Capture error:', e);
                    this.showToast('Capture failed. Please try again.', 'error');
                }
            },

            // BUG-012 FIX: Removed legacy captureImage() alias - use capturePhoto() directly

            renderCapturedImages() {
                const container = document.getElementById('captured-images');
                container.innerHTML = this.capturedImages.map((img, idx) => {
                    // BUG-009 FIX: Add quality indicator
                    const quality = this.checkPhotoQuality(img);
                    const qualityColor = quality.score >= 85 ? '#10B981' : quality.score >= 75 ? '#F59E0B' : '#EF4444';
                    const qualityIcon = quality.score >= 85 ? '‚úì' : quality.score >= 75 ? '‚ö†' : '‚úó';
                    const qualityLabel = quality.score >= 85 ? 'Good quality' : quality.score >= 75 ? 'Acceptable' : 'Poor quality';
                    
                    return `
                        <div class="captured-image" role="listitem">
                            <img src="${img}" alt="Captured image ${idx + 1}">
                            
                            <!-- Quality indicator dot -->
                            <div title="${qualityLabel} (${quality.score}%)" style="position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; border-radius: 50%; background: ${qualityColor}; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2); cursor: help;">
                                ${qualityIcon}
                            </div>
                            
                            <button class="crop-image" onclick="app.cropExistingImage(${idx})" aria-label="Crop image ${idx + 1}" style="position:absolute; bottom:4px; left:4px; border-radius:50%; border:none; background:rgba(22,163,74,0.9); color:white; font-size:12px; cursor:pointer;">‚úÇÔ∏è</button>
                            <button class="remove-image" onclick="app.removeImage(${idx})" aria-label="Remove image ${idx + 1}">√ó</button>
                        </div>
                    `;
                }).join('');
                
                // Update badge
                const badge = document.getElementById('photo-count-badge');
                if (badge) {
                    badge.textContent = this.capturedImages.length;
                    badge.style.display = this.capturedImages.length > 0 ? 'flex' : 'none';
                }
            },

            removeImage(index) {
                this.capturedImages.splice(index, 1);
                this.updateCapturedImagesState(); // Fix #4: Use centralized state update
            },

            // Analysis Functions
            async analyzeProduct() {
                // Fix #1: Prevent concurrent analysis operations
                if (this.isAnalyzing) {
                    this.showToast('Analysis already in progress. Please wait...', 'warning');
                    return;
                }
                
                // A3: Validate photos exist
                if (this.capturedImages.length === 0) {
                    this.showToast('Please capture at least one photo first', 'error');
                    return;
                }
                
                // Fix #1: Set flag and disable button to prevent concurrent operations
                this.isAnalyzing = true;
                const analyzeBtn = document.getElementById('analyze-btn-bar');
                if (analyzeBtn) {
                    analyzeBtn.disabled = true;
                }
                
                this.showLoading('Extracting text from images...');
                
                // Additional Fix #2: Reset OCR cancellation flag
                this.ocrCancelled = false;

                let failurePhase = 'start';
                let extractedText = '';

                try {
                    failurePhase = 'ocr';
                    for (let i = 0; i < this.capturedImages.length; i++) {
                        // Additional Fix #2: Check if OCR was cancelled (user navigated away)
                        if (this.ocrCancelled || this.currentView !== 'scanner') {
                            console.log('OCR cancelled - user navigated away');
                            this.hideLoading();
                            this.isAnalyzing = false;
                            return;
                        }
                        
                        this.updateLoadingMessage(`Processing image ${i + 1} of ${this.capturedImages.length}...`);
                        const result = await Tesseract.recognize(
                            this.capturedImages[i],
                            'eng',
                            {
                                logger: m => console.log(m),
                                workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/worker.min.js',
                                langPath: 'https://tessdata.projectnaptha.com/4.0.0',
                                corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@4/tesseract-core.wasm.js'
                            }
                        );
                        extractedText += result.data.text + '\n\n';
                    }
                    
                    failurePhase = 'after_ocr';
                    // Additional Fix #2: Check again after OCR loop
                    if (this.ocrCancelled || this.currentView !== 'scanner') {
                        console.log('OCR cancelled after processing - user navigated away');
                        this.hideLoading();
                        this.isAnalyzing = false;
                        return;
                    }
                    
                    // A4: Validate text was extracted
                    if (!extractedText || extractedText.trim().length < 10) {
                        this.hideLoading();
                        this.isAnalyzing = false; // Fix #1: Reset flag on early return
                        const analyzeBtn = document.getElementById('analyze-btn-bar');
                        if (analyzeBtn && this.capturedImages.length > 0) {
                            analyzeBtn.disabled = false; // Re-enable if images still exist
                        }
                        // Fix #6: Preserve capturedImages array on early return (don't clear) so user can retry
                        // Show full debug block (not just a toast) so empty-OCR failures are diagnosable
                        const firstImageLen = this.capturedImages.length > 0 && typeof this.capturedImages[0] === 'string'
                            ? this.capturedImages[0].length : 0;
                        this.showError('ANALYSIS_FAILED', {
                            failurePhase: 'ocr_empty',
                            errorMessage: 'Tesseract returned no text (extractedTextLength: 0). Language pack may not have loaded, or image has no readable text.',
                            capturedImagesCount: this.capturedImages.length,
                            firstImageDataLength: firstImageLen,
                            scanMode: this.scanMode,
                            extractedTextLength: 0,
                            extractedTextPreview: '(none)',
                            timestamp: new Date().toISOString(),
                            userAgent: navigator.userAgent
                        });
                        return;
                    }

                    failurePhase = 'gemini_api';
                    this.updateLoadingMessage('Analyzing with AI...');
                    
                    // Additional Fix #1: Create AbortController for API request cancellation
                    this.currentAbortController = new AbortController();
                    const analysis = await this.analyzeWithGemini(extractedText, this.scanMode, this.currentAbortController.signal);
                    
                    // Additional Fix #1: Clear abort controller after successful request
                    this.currentAbortController = null;
                    
                    this.hideLoading();
                    // v1.3: Three-gate flow ‚Äì 1 result ‚Üí confirmation popup then analysis
                    this.pendingAnalysisData = analysis;
                    this.pendingAnalysisCallback = () => {
                        this.incrementScanCount();
                        this.capturedImages = [];
                        this.updateCapturedImagesState();
                        this.stopCamera();
                    };
                    this.isAnalyzing = false;
                    this.showView('confirmation-popup');

                } catch (error) {
                    // Additional Fix #1: Don't show error if request was cancelled (user navigated away)
                    if (error.name === 'AbortError') {
                        console.log('Analysis cancelled - user navigated away');
                        this.currentAbortController = null;
                        return; // Silently exit, user already navigated away
                    }
                    
                    // Additional Fix #2: Don't show error if OCR was cancelled
                    if (this.ocrCancelled) {
                        console.log('Analysis cancelled - OCR was cancelled');
                        this.hideLoading();
                        this.isAnalyzing = false;
                        this.ocrCancelled = false;
                        return;
                    }
                    
                    // Fix #6: Error recovery - ensure all state is reset properly
                    this.hideLoading();
                    
                    // Fix #1: Reset flag and re-enable button on error
                    this.isAnalyzing = false;
                    const analyzeBtn = document.getElementById('analyze-btn-bar');
                    if (analyzeBtn && this.capturedImages.length > 0) {
                        analyzeBtn.disabled = false; // Re-enable if images still exist
                    }
                    
                    // Additional Fix #1: Clear abort controller on error
                    this.currentAbortController = null;
                    
                    // Fix #6: Preserve capturedImages array on error (don't clear) so user can retry
                    // Fix #6: Don't stop camera on error - allow user to retry with same camera session
                    
                    // Enriched debug info for every AI analysis failure (testing / troubleshooting)
                    const extractedPreview = extractedText && extractedText.length > 0
                        ? extractedText.trim().substring(0, 400).replace(/\s+/g, ' ') + (extractedText.length > 400 ? '‚Ä¶' : '')
                        : '(none)';
                    const firstImageLen = this.capturedImages.length > 0 && typeof this.capturedImages[0] === 'string'
                        ? this.capturedImages[0].length
                        : 0;
                    const debugInfo = {
                        failurePhase,
                        errorName: error.name || '(unknown)',
                        errorMessage: error.message || '(no message)',
                        errorStack: error.stack ? error.stack.substring(0, 800) : 'No stack trace',
                        timestamp: new Date().toISOString(),
                        userAgent: navigator.userAgent,
                        capturedImagesCount: this.capturedImages.length,
                        firstImageDataLength: firstImageLen,
                        scanMode: this.scanMode,
                        extractedTextLength: extractedText ? extractedText.length : 0,
                        extractedTextPreview: extractedPreview,
                        ...(error.apiStatus != null && { apiStatus: error.apiStatus }),
                        ...(error.apiBodyPreview != null && { apiBodyPreview: error.apiBodyPreview })
                    };
                    
                    // BUG-006 FIX: Better error detection; always show enriched debug for analysis failures (testing)
                    if (error.message && error.message.includes('Tesseract')) {
                        this.showError('OCR_NOT_LOADED', debugInfo);
                    } else if (error.message && (error.message.includes('network') || error.message.includes('fetch'))) {
                        this.showError('NETWORK_ERROR', debugInfo);
                    } else {
                        this.showError('ANALYSIS_FAILED', debugInfo);
                    }
                    
                    console.error('Analysis error:', error);
                    this.logError('ERR_ANALYSIS', { message: error.message, stack: error.stack });
                }
            },

            async queryOpenFoodFacts(barcode, signal = null) {
                try {
                    // Additional Fix #1: Support request cancellation
                    const response = await fetch(
                        `https://world.openfoodfacts.org/api/v0/product/${barcode}.json`,
                        { signal }
                    );
                    const data = await response.json();
                    
                    if (data.status === 1) {
                        return {
                            found: true,
                            name: data.product.product_name,
                            brand: data.product.brands,
                            ingredients: data.product.ingredients_text,
                            nutriScore: data.product.nutriscore_grade,
                            nutrition: data.product.nutriments,
                            category: data.product.categories,
                            image: data.product.image_url
                        };
                    }
                } catch (error) {
                    // Additional Fix #1: Don't log error if request was cancelled
                    if (error.name === 'AbortError') {
                        throw error; // Re-throw so caller knows request was cancelled
                    }
                    console.error('Open Food Facts error:', error);
                }
                
                return { found: false };
            },

            convertOFFToAnalysis(offData) {
                const scoreMap = { 'a': 85, 'b': 70, 'c': 55, 'd': 40, 'e': 25 };
                const score = scoreMap[offData.nutriScore?.toLowerCase()] || 50;
                
                return {
                    productName: offData.name || 'Unknown Product',
                    brand: offData.brand || 'Unknown Brand',
                    healthScore: score,
                    scoreCategory: this.getScoreCategory(score),
                    scoreReason: `Based on Nutri-Score ${offData.nutriScore?.toUpperCase() || 'Unknown'}`,
                    allergyWarnings: this.checkAllergies(offData.ingredients),
                    macros: {
                        calories: `${offData.nutrition?.['energy-kcal_100g'] || 0} kcal`,
                        protein: `${offData.nutrition?.proteins_100g || 0}g`,
                        carbs: `${offData.nutrition?.carbohydrates_100g || 0}g`,
                        fat: `${offData.nutrition?.fat_100g || 0}g`,
                        fiber: `${offData.nutrition?.fiber_100g || 0}g`,
                        sugar: `${offData.nutrition?.sugars_100g || 0}g`
                    },
                    ingredients: this.parseIngredientsFromOFF(offData.ingredients),
                    certifications: ['Open Food Facts Verified'],
                    alternatives: [],
                    image: offData.image
                };
            },

            parseIngredientsFromOFF(ingredientsText) {
                if (!ingredientsText) return [];
                
                const ingredients = ingredientsText.split(',').slice(0, 5).map(ing => ({
                    name: ing.trim(),
                    purpose: 'Main ingredient',
                    healthImpact: 'neutral',
                    details: 'Part of product formulation',
                    source: 'Product label'
                }));
                
                return ingredients;
            },

            checkAllergies(ingredientsText) {
                if (!this.userSettings.allergies || !ingredientsText) return [];
                
                const allergyList = this.userSettings.allergies.toLowerCase().split(',').map(a => a.trim());
                const foundAllergens = [];
                
                allergyList.forEach(allergen => {
                    if (ingredientsText.toLowerCase().includes(allergen)) {
                        foundAllergens.push(allergen);
                    }
                });
                
                return foundAllergens;
            },

            // v1.2.0: Improved Gemini prompt with compound ingredient handling
            async analyzeWithGemini(extractedText, mode, signal = null) {
                const basePrompt = mode === 'ingredients' 
                    ? `Analyze this food ingredient list for Indian consumers. Only use the "Ingredients:" section. Keep compound names intact (e.g. "Sodium Benzoate", "Palm Oil", "Citric Acid"). Ignore nutrition values, dates, brand names, and serving sizes.

Ingredient text:
${extractedText}

Respond ONLY with valid JSON:
{
  "detectedLanguage": "English/Hindi/Tamil/Telugu/Other",
  "productName": "Unknown (Ingredient Scan)",
  "category": "food",
  "healthScore": 0-100,
  "scoreCategory": "excellent/good/fair/poor/bad",
  "scoreReason": "1-2 sentence explanation",
  "confidence": "high/medium/low",
  "allergyWarnings": ["common allergens detected"],
  "ingredients": [
    {
      "name": "Ingredient name",
      "purpose": "What it does",
      "healthImpact": "positive/neutral/negative",
      "safetyLevel": "generally-safe/use-sparingly/limit-intake/avoid-if-sensitive",
      "details": "2-3 sentence explanation in simple language",
      "source": "Natural/Synthetic/Processed"
    }
  ],
  "trustBadges": [
    {"type": "verified/caution/warning", "text": "Badge text", "standard": "WHO/FSSAI/FDA/EFSA"}
  ],
  "overallVerdict": "Brief recommendation"
}`
                    : `Analyze this food product label for Indian consumers. Keep compound ingredient names intact.

Label text:
${extractedText}

Respond ONLY with valid JSON:
{
  "productName": "Product name",
  "brand": "Brand name",
  "category": "food",
  "healthScore": 0-100,
  "scoreCategory": "excellent/good/fair/poor/bad",
  "scoreReason": "Brief explanation",
  "confidence": "high/medium/low",
  "allergyWarnings": ["allergens found"],
  "macros": {
    "calories": "value per 100g or null",
    "protein": "value or null",
    "carbs": "value or null",
    "fat": "value or null",
    "fiber": "value or null",
    "sugar": "value or null"
  },
  "ingredients": [
    {
      "name": "ingredient name",
      "purpose": "what it does",
      "healthImpact": "positive/neutral/negative",
      "safetyLevel": "generally-safe/use-sparingly/limit-intake/avoid-if-sensitive",
      "details": "explanation in simple language",
      "source": "Natural/Synthetic/Processed"
    }
  ],
  "certifications": ["FSSAI", "organic", etc],
  "trustBadges": [
    {"type": "verified/caution/warning", "text": "badge text", "standard": "WHO/FSSAI/FDA"}
  ]
}`;

                try {
                    const response = await fetch('/.netlify/functions/analyze-ingredient', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: basePrompt }),
                        signal: signal
                    });
                    
                    // Check for network/API errors
                    if (!response.ok) {
                        const errorText = await response.text().catch(() => 'Could not read error response');
                        let errorDetails;
                        try {
                            errorDetails = JSON.parse(errorText);
                        } catch {
                            errorDetails = errorText;
                        }
                        
                        console.error('API response not ok:', response.status, errorDetails);
                        
                        const err = new Error(`API_ERROR_${response.status}: ${JSON.stringify(errorDetails).substring(0, 300)}`);
                        err.apiStatus = response.status;
                        err.apiBodyPreview = typeof errorText === 'string' ? errorText.substring(0, 600).replace(/\s+/g, ' ') : String(errorDetails).substring(0, 600);
                        if (response.status === 429) {
                            err.message = `API_QUOTA_EXCEEDED: Rate limit or quota exceeded. Status: ${response.status}. Details: ${JSON.stringify(errorDetails).substring(0, 200)}`;
                        } else if (response.status === 403) {
                            err.message = `API_AUTH_FAILED: Invalid API key or permission denied. Status: ${response.status}. Details: ${JSON.stringify(errorDetails).substring(0, 200)}`;
                        } else if (response.status === 400) {
                            err.message = `API_BAD_REQUEST: Invalid request format. Status: ${response.status}. Details: ${JSON.stringify(errorDetails).substring(0, 200)}`;
                        }
                        throw err;
                    }
                    
                    const data = await response.json();
                    
                    // Check for valid response structure
                    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                        console.error('Invalid API response structure:', data);
                        throw new Error(`INVALID_API_RESPONSE: ${JSON.stringify(data).substring(0, 300)}`);
                    }
                    
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    
                    if (jsonMatch) {
                        const rawAnalysis = JSON.parse(jsonMatch[0]);
                        // v1.2.0: Post-processing validation
                        return this.validateAndCleanAnalysis(rawAnalysis);
                    }
                    
                    throw new Error('Could not parse response');
                } catch (error) {
                    console.error('Gemini API error:', error);
                    this.logError('ERR_API', { message: error.message });
                    // v1.2.1: Throw detailed error for debugging
                    throw error; // Preserve the detailed error message
                }
            },

            // v1.2.0: Post-processing validation for AI results
            validateAndCleanAnalysis(analysis) {
                // Clean ingredients
                if (analysis.ingredients && Array.isArray(analysis.ingredients)) {
                    analysis.ingredients = this.cleanIngredients(analysis.ingredients);
                }
                
                // Validate health score
                if (typeof analysis.healthScore === 'number') {
                    analysis.healthScore = Math.max(0, Math.min(100, Math.round(analysis.healthScore)));
                } else {
                    analysis.healthScore = 50; // Default if missing
                }
                
                // Ensure score category matches score
                analysis.scoreCategory = this.getScoreCategory(analysis.healthScore);
                
                // Validate confidence
                if (!['high', 'medium', 'low'].includes(analysis.confidence)) {
                    analysis.confidence = 'medium';
                }
                
                // Validate macros (all-or-nothing)
                if (analysis.macros) {
                    if (!this.hasCompleteNutrition(analysis.macros)) {
                        analysis.macros = null; // Remove incomplete nutrition
                    }
                }
                
                // Ensure arrays exist
                analysis.allergyWarnings = analysis.allergyWarnings || [];
                analysis.trustBadges = analysis.trustBadges || [];
                
                return analysis;
            },

            // v1.2.0: Clean and validate ingredients list
            cleanIngredients(ingredients) {
                // Patterns to exclude (non-ingredients)
                const excludePatterns = [
                    /^net\s*(weight|wt|contents?)/i,
                    /^best\s*before/i,
                    /^(mfg|exp|use\s*by)\s*date/i,
                    /^batch/i,
                    /^lot/i,
                    /^\d+\s*(g|ml|kg|l|kcal|cal)$/i,
                    /^\d+%$/,
                    /^contains?:?$/i,
                    /^allergen/i,
                    /^ingredients?:?$/i,
                    /^nutrition/i,
                    /^storage/i,
                    /^directions?/i,
                    /^manufactured/i,
                    /^packed\s*by/i,
                    /^marketed\s*by/i
                ];
                
                return ingredients
                    .filter(ing => {
                        if (!ing || !ing.name) return false;
                        const name = ing.name.trim();
                        if (name.length < 2) return false;
                        // Check against exclude patterns
                        return !excludePatterns.some(pattern => pattern.test(name));
                    })
                    .map(ing => ({
                        name: this.mergeCompoundIngredient(ing.name.trim()),
                        purpose: ing.purpose || 'Ingredient',
                        healthImpact: ing.healthImpact || 'neutral',
                        safetyLevel: ing.safetyLevel || 'generally-safe',
                        details: ing.details || 'Part of product formulation',
                        source: ing.source || 'Unknown'
                    }));
            },

            // v1.2.0: Merge compound ingredients that may have been split
            mergeCompoundIngredient(name) {
                // Known compound prefixes and their common pairs
                const compounds = {
                    'sodium': ['benzoate', 'chloride', 'bicarbonate', 'citrate', 'lactate', 'phosphate'],
                    'potassium': ['sorbate', 'chloride', 'citrate', 'benzoate'],
                    'calcium': ['carbonate', 'chloride', 'phosphate', 'propionate', 'sulfate'],
                    'citric': ['acid'],
                    'ascorbic': ['acid'],
                    'lactic': ['acid'],
                    'malic': ['acid'],
                    'tartaric': ['acid'],
                    'palm': ['oil'],
                    'sunflower': ['oil'],
                    'coconut': ['oil'],
                    'vegetable': ['oil'],
                    'soybean': ['oil'],
                    'rice': ['bran oil', 'flour'],
                    'corn': ['starch', 'syrup', 'flour'],
                    'modified': ['starch', 'corn starch', 'tapioca starch'],
                    'wheat': ['flour', 'gluten'],
                    'natural': ['flavors', 'flavours', 'color', 'colours'],
                    'artificial': ['flavors', 'flavours', 'color', 'colours']
                };
                
                // Already looks compound, return as-is
                if (name.includes(' ')) return name;
                
                // Check if this is a prefix that needs a suffix
                const lower = name.toLowerCase();
                if (compounds[lower]) {
                    // This is incomplete - but we can't fix without context
                    // Just return as-is
                }
                
                return name;
            },

            // v1.2.0: Check if nutrition data is complete (all-or-nothing)
            hasCompleteNutrition(macros) {
                if (!macros) return false;
                
                // Require all 4 core macros to display nutrition section
                const required = ['calories', 'protein', 'carbs', 'fat'];
                return required.every(key => {
                    const value = macros[key];
                    if (!value) return false;
                    if (value === 'null' || value === 'N/A' || value === '-') return false;
                    // Must have a number
                    return /\d/.test(value);
                });
            },

            // v1.2.0: Get score category from numeric score
            getScoreCategory(score) {
                if (score >= 80) return 'excellent';
                if (score >= 60) return 'good';
                if (score >= 40) return 'fair';
                if (score >= 20) return 'poor';
                return 'bad';
            },

            // v1.2.0: Error logging to localStorage
            logError(code, details = {}) {
                try {
                    const errors = JSON.parse(localStorage.getItem('eitaki_error_log') || '[]');
                    errors.push({
                        code,
                        details,
                        timestamp: Date.now(),
                        url: window.location.href
                    });
                    // Keep only last 50 errors
                    this.safeLocalStorageSet('eitaki_error_log', JSON.stringify(errors.slice(-50)));
                } catch (e) {
                    console.error('Failed to log error:', e);
                }
            },

            // v1.2.1: getDemoAnalysis() removed - no fake results

            showAnalysis(analysis) {
                const container = document.getElementById('analysis-content');
                const scoreClass = `score-${analysis.scoreCategory || 'fair'}`;

                // BUG #5: Calculate and display confidence
                // AI returns "high/medium/low", convert to numeric for display
                let confidenceValue = analysis.confidence;
                let confidencePercent, confidenceColor, confidenceLabel;
                
                if (typeof confidenceValue === 'string') {
                    // Convert string to percent
                    if (confidenceValue === 'high') {
                        confidencePercent = 90;
                        confidenceColor = '#10B981';
                        confidenceLabel = 'High';
                    } else if (confidenceValue === 'medium') {
                        confidencePercent = 75;
                        confidenceColor = '#F59E0B';
                        confidenceLabel = 'Medium';
                    } else {
                        confidencePercent = 60;
                        confidenceColor = '#EF4444';
                        confidenceLabel = 'Low';
                    }
                } else if (typeof confidenceValue === 'number') {
                    confidencePercent = confidenceValue;
                    confidenceColor = confidenceValue >= 85 ? '#10B981' : confidenceValue >= 75 ? '#F59E0B' : '#EF4444';
                    confidenceLabel = confidenceValue >= 85 ? 'High' : confidenceValue >= 75 ? 'Medium' : 'Low';
                } else {
                    // Default
                    confidencePercent = 75;
                    confidenceColor = '#F59E0B';
                    confidenceLabel = 'Medium';
                }

                let trustBadgesHTML = '';
                if (analysis.trustBadges && analysis.trustBadges.length > 0) {
                    trustBadgesHTML = `
                        <div class="trust-badges" style="margin-top: 16px;">
                            ${analysis.trustBadges.map(badge => `
                                <span class="trust-badge ${badge.type}">
                                    ${badge.type === 'verified' ? '‚úì' : badge.type === 'caution' ? '‚ö†' : '‚ö†'}
                                    ${badge.text}
                                </span>
                            `).join('')}
                        </div>
                    `;
                }

                let allergiesHTML = '';
                if (analysis.allergyWarnings && analysis.allergyWarnings.length > 0) {
                    allergiesHTML = `
                        <div class="alert-box" role="alert">
                            <strong>‚ö†Ô∏è Allergy Alert:</strong> Contains ${analysis.allergyWarnings.join(', ')}
                        </div>
                    `;
                }

                // BUG #5: Confidence badge HTML
                const confidenceBadgeHTML = `
                    <div style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: white; border-radius: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); margin-top: 12px;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: ${confidenceColor};"></div>
                        <span style="font-size: 13px; font-weight: 600; color: #1E293B;">
                            ${confidenceLabel} Confidence (${confidencePercent}%)
                        </span>
                    </div>
                `;

                // BUG #5: Low confidence disclaimer
                const confidenceDisclaimerHTML = confidencePercent < 80 ? `
                    <div style="background: #FEF3C7; border-left: 4px solid #F59E0B; padding: 12px; border-radius: 8px; margin-top: 16px;">
                        <strong style="color: #92400E;">‚ö†Ô∏è Note:</strong>
                        <span style="color: #78350F; font-size: 14px;">
                            Some ingredients may not have been detected clearly. Double-check the packaging.
                        </span>
                    </div>
                ` : '';

                let macrosHTML = '';
                if (analysis.macros) {
                    macrosHTML = `
                        <div class="analysis-section">
                            <h2 class="section-title">üìä Nutrition Facts</h2>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                                ${Object.entries(analysis.macros).map(([key, value]) => `
                                    <div style="background: var(--ice-blue); padding: 12px; border-radius: 8px; text-align: center;">
                                        <div style="font-size: 18px; font-weight: 700; color: var(--slate);">${value}</div>
                                        <div style="font-size: 12px; color: var(--light-slate); text-transform: capitalize;">${key}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                let verdictHTML = '';
                if (analysis.overallVerdict) {
                    verdictHTML = `
                        <div style="background: var(--ice-blue); padding: 20px; border-radius: 12px; text-align: center; font-size: 18px; font-weight: 700; margin-bottom: 20px;">
                            ${analysis.overallVerdict}
                        </div>
                    `;
                }

                // BUG #6: Score explanation section
                const scoreExplanationHTML = `
                    <div style="margin-top: 16px;">
                        <button class="btn btn-secondary" onclick="app.toggleScoreDetails()" style="width: 100%; font-size: 14px;">
                            üìä Why this score? (Tap to expand)
                        </button>
                        
                        <div id="score-details" style="display: none; margin-top: 16px; background: #F0FDF4; padding: 16px; border-radius: 12px;">
                            <h4 style="font-size: 16px; font-weight: 700; margin-bottom: 12px; color: #16A34A;">
                                Score Breakdown
                            </h4>
                            
                            <div style="margin-bottom: 16px;">
                                <strong style="color: #16A34A; display: block; margin-bottom: 8px;">üìä How we calculate:</strong>
                                <ul style="margin: 0; padding-left: 20px; color: #475569; font-size: 14px;">
                                    <li>Processing Level (20%)</li>
                                    <li>Nutrient Quality (35%)</li>
                                    <li>Ingredient Quality (30%)</li>
                                    <li>Transparency (15%)</li>
                                </ul>
                            </div>
                            
                            <div style="background: white; padding: 12px; border-radius: 8px; font-size: 13px; color: #64748B;">
                                <strong style="color: #1E293B;">Sources:</strong> WHO, FSSAI, FDA, peer-reviewed research.
                                <a href="#" onclick="app.showMethodology(); return false;" style="color: #16A34A; text-decoration: underline;">
                                    View full methodology
                                </a>
                            </div>
                        </div>
                    </div>
                `;

                // v1.2.1: Save to My Scans prompt (localStorage, no Firebase)
                const savePromptHTML = `
                    <div style="background: linear-gradient(135deg, #16A34A, #14B8A6); padding: 24px; border-radius: 16px; margin-top: 20px; color: white; text-align: center;">
                        <h3 style="font-size: 18px; font-weight: 700; margin-bottom: 12px;">
                            üíæ Save This Scan?
                        </h3>
                        <p style="font-size: 14px; margin-bottom: 20px; opacity: 0.9;">
                            Keep this analysis in your personal scan history for quick access later.
                        </p>
                        
                        <div style="display: flex; gap: 12px; justify-content: center;">
                            <button class="btn" onclick="app.saveToMyScans()" style="background: white; color: #16A34A; flex: 1; max-width: 150px;">
                                üíæ Save
                            </button>
                            <button class="btn" onclick="app.skipSave()" style="background: rgba(255,255,255,0.2); color: white; flex: 1; max-width: 150px;">
                                Skip
                            </button>
                        </div>
                    </div>
                `;

                // BUG #9: Healthier alternatives (only if score < 50)
                const alternativesHTML = analysis.healthScore < 50 ? `
                    <div style="background: linear-gradient(135deg, #F0FDF4, #DCFCE7); padding: 20px; border-radius: 16px; margin-top: 24px;">
                        <h3 style="font-size: 18px; font-weight: 700; color: #166534; margin-bottom: 16px;">
                            üíö Looking for Healthier Options?
                        </h3>
                        <p style="font-size: 14px; color: #15803D; margin-bottom: 16px;">
                            Consider products with fewer processed ingredients and lower sodium/sugar content.
                        </p>
                        <p style="font-size: 12px; color: #15803D; font-style: italic;">
                            Feature coming soon: We'll suggest specific alternatives based on community data.
                        </p>
                    </div>
                ` : '';

                // Bug 4 UI: 1‚Äì2 short plain-language insights for above-fold (no full list on this screen)
                const shortInsights = [];
                if (analysis.scoreReason && analysis.scoreReason.trim()) {
                    shortInsights.push(analysis.scoreReason.trim().substring(0, 100) + (analysis.scoreReason.length > 100 ? '‚Ä¶' : ''));
                }
                const firstNegative = (analysis.ingredients || []).find(i => i.healthImpact === 'negative');
                if (firstNegative && shortInsights.length < 2) {
                    shortInsights.push('Contains ' + (firstNegative.name || 'ingredients of concern'));
                }
                const shortInsightsHTML = shortInsights.length > 0 ? `
                    <ul style="margin: 12px 0 0 0; padding-left: 20px; font-size: 14px; color: #475569; line-height: 1.5;">
                        ${shortInsights.slice(0, 2).map(s => `<li>${s}</li>`).join('')}
                    </ul>
                ` : '';

                // v1.3: 2√ó2 Health Score grid (Sugar, Additives, Processing, Nutrients); null ‚Üí skeleton
                const healthCell = (label, value) => {
                    const val = value != null && value !== '' ? value : null;
                    const display = val !== null ? val : '‚Äî';
                    const skeleton = val === null ? ' skeleton-cell' : '';
                    return `<div class="health-grid-cell${skeleton}" style="background: var(--ice-blue); padding: 16px; border-radius: 12px; text-align: center;"><div style="font-size: 24px; font-weight: 700; color: #1A2E35;">${display}</div><div style="font-size: 12px; color: #64748B; margin-top: 4px;">${label}</div></div>`;
                };
                const healthGridHTML = `
                    <div class="health-score-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 20px;">
                        ${healthCell('Sugar', analysis.sugar)}
                        ${healthCell('Additives', analysis.additives)}
                        ${healthCell('Processing', analysis.processing)}
                        ${healthCell('Nutrients', analysis.nutrients)}
                    </div>
                `;

                // v1.3: Badge carousel (horizontal scroll, gradient on right); placeholder badges
                const badgeList = (analysis.trustBadges && analysis.trustBadges.length > 0)
                    ? analysis.trustBadges.map(b => b.text)
                    : ['Quality Check', 'Ingredient Scanned', 'Educational'];
                const badgeCarouselHTML = `
                    <div class="badge-carousel-wrap" style="margin-top: 16px; position: relative;">
                        <div class="badge-carousel" style="display: flex; gap: 8px; overflow-x: auto; padding-bottom: 8px; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch;">
                            ${badgeList.map(t => `<span class="badge-pill" style="flex-shrink: 0; padding: 8px 16px; border-radius: 20px; background: var(--ice-blue); font-size: 13px; font-weight: 600; color: #16A34A; scroll-snap-align: start;">${t}</span>`).join('')}
                        </div>
                        <div class="badge-carousel-fade" style="position: absolute; top: 0; right: 0; bottom: 8px; width: 32px; background: linear-gradient(to left, #F8F9FA, transparent); pointer-events: none;"></div>
                    </div>
                `;

                // v1.3: Sources accordion (one open at a time); placeholder links
                const sourcesAccordionHTML = `
                    <div class="sources-accordion" style="margin-top: 20px;">
                        <h3 style="font-size: 16px; font-weight: 700; color: #1A2E35; margin-bottom: 12px;">Sources &amp; Standards</h3>
                        <div class="accordion-item">
                            <button type="button" class="accordion-head" onclick="app.toggleAccordion(this)" style="width: 100%; text-align: left; padding: 14px 16px; background: #F1F5F9; border: none; border-radius: 8px; font-weight: 600; color: #1A2E35; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">USDA FoodData Central <span class="accordion-arrow">‚ñº</span></button>
                            <div class="accordion-content" style="display: none; padding: 12px 16px; background: #F8FAFC; border-radius: 0 0 8px 8px;"><a href="#" onclick="alert('Link coming soon.'); return false;" style="color: #16A34A;">View source</a></div>
                        </div>
                        <div class="accordion-item">
                            <button type="button" class="accordion-head" onclick="app.toggleAccordion(this)" style="width: 100%; text-align: left; padding: 14px 16px; background: #F1F5F9; border: none; border-radius: 8px; font-weight: 600; color: #1A2E35; cursor: pointer; display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">Open Food Facts <span class="accordion-arrow">‚ñº</span></button>
                            <div class="accordion-content" style="display: none; padding: 12px 16px; background: #F8FAFC; border-radius: 0 0 8px 8px;"><a href="#" onclick="alert('Link coming soon.'); return false;" style="color: #16A34A;">View source</a></div>
                        </div>
                        <div class="accordion-item">
                            <button type="button" class="accordion-head" onclick="app.toggleAccordion(this)" style="width: 100%; text-align: left; padding: 14px 16px; background: #F1F5F9; border: none; border-radius: 8px; font-weight: 600; color: #1A2E35; cursor: pointer; display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">FSSAI Standards <span class="accordion-arrow">‚ñº</span></button>
                            <div class="accordion-content" style="display: none; padding: 12px 16px; background: #F8FAFC; border-radius: 0 0 8px 8px;"><a href="#" onclick="alert('Link coming soon.'); return false;" style="color: #16A34A;">View source</a></div>
                        </div>
                    </div>
                `;

                // Defensive: ensure display values never undefined (history/edge cases)
                const displayName = analysis.productName || analysis.name || 'Unknown Product';
                const displayScore = analysis.healthScore != null && analysis.healthScore !== '' ? analysis.healthScore : '‚Äî';
                const displayCategory = analysis.scoreCategory || 'fair';
                const displayReason = analysis.scoreReason || '';

                container.innerHTML = `
                    <div class="product-header" style="margin-bottom: 20px;">
                        <h2 class="product-name" style="font-size: 1.1rem; font-weight: 600; color: #1E293B; margin-bottom: 12px;">${displayName}</h2>
                        <div class="health-score-card" style="display: flex; flex-direction: column; align-items: center; text-align: center;">
                            <div class="score-circle ${scoreClass}" style="width: 120px; height: 120px; font-size: 32px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                                ${displayScore}
                                <div class="score-label" style="font-size: 14px; margin-top: 4px;">${displayCategory}</div>
                            </div>
                            <p style="font-size: 13px; color: #64748B; margin-top: 12px;">Based on ingredient quality and additives</p>
                            ${shortInsightsHTML}
                            ${healthGridHTML}
                            <button type="button" class="btn btn-secondary" onclick="app.toggleAnalysisDetails()" id="analysis-details-toggle" style="margin-top: 16px; font-size: 14px;">
                                See details ‚Üí
                            </button>
                        </div>
                    </div>

                    <div id="analysis-details-section" style="display: none;">
                        ${analysis.image ? `<img src="${analysis.image}" alt="${displayName}" style="width: 100%; max-height: 200px; object-fit: contain; margin-bottom: 16px; border-radius: 8px;">` : ''}
                        ${analysis.brand ? `<p class="product-brand">${analysis.brand}</p>` : ''}
                        ${analysis.detectedLanguage ? `<p class="product-brand">Detected language: ${analysis.detectedLanguage}</p>` : ''}
                        ${confidenceDisclaimerHTML}
                        <div class="score-details" style="margin-top: 12px;">
                            <p class="score-desc">${displayReason}</p>
                        </div>
                        ${confidenceBadgeHTML}
                        ${trustBadgesHTML}
                        ${badgeCarouselHTML}
                        ${scoreExplanationHTML}
                        ${allergiesHTML}
                        ${verdictHTML}
                        ${macrosHTML}
                        <div class="analysis-section">
                            <h2 class="section-title">üî¨ Ingredients Deep Dive</h2>
                            <div class="ingredient-list">
                                ${(analysis.ingredients || []).map(ing => `
                                    <div class="ingredient-item">
                                        <div class="ingredient-header">
                                            <span class="ingredient-name">${ing.name}</span>
                                            <span class="impact-badge impact-${ing.healthImpact}">
                                                ${ing.healthImpact === 'positive' ? '‚úì Good' : ing.healthImpact === 'negative' ? '‚ö† Caution' : 'Neutral'}
                                            </span>
                                        </div>
                                        ${ing.readabilityIssue ? `<div class="alert-box" style="margin: 8px 0; font-size: 12px; padding: 8px;">‚ö†Ô∏è ${ing.readabilityIssue}</div>` : ''}
                                        <div class="ingredient-purpose"><strong>Purpose:</strong> ${ing.purpose}</div>
                                        <div class="ingredient-detail">${ing.details}</div>
                                        <div style="font-size: 12px; color: var(--light-slate); margin-top: 8px;">
                                            <strong>Source:</strong> ${ing.source}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ${analysis.certifications && analysis.certifications.length > 0 ? `
                            <div class="analysis-section">
                                <h2 class="section-title">‚úì Certifications & Standards</h2>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    ${analysis.certifications.map(cert => `
                                        <span style="background: var(--ice-blue); padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 600;">
                                            ${cert}
                                        </span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                        ${sourcesAccordionHTML}
                        ${alternativesHTML}
                        ${savePromptHTML}
                        <div class="disclaimer" style="margin-top: 24px;">
                            <strong>‚ö†Ô∏è Important Disclaimer:</strong> This analysis is for educational purposes only and should not be considered medical advice.
                            Information is based on detected ${this.scanMode === 'ingredients' ? 'ingredients' : 'product data'} and may not be 100% accurate.
                            Always verify ingredients on the actual product packaging. May miss allergens if not clearly visible in scan.
                            We are not liable for errors in detection or analysis. Consult healthcare professionals for specific dietary needs.
                            <br><br>
                            <strong>Data Sources:</strong> ${analysis.image ? 'Open Food Facts, ' : ''}AI analysis (Gemini), WHO, FSSAI, peer-reviewed research.
                            Last analyzed: ${new Date().toLocaleDateString()}
                        </div>
                    </div>

                    <div style="text-align: center; margin-top: 24px;">
                        <button class="btn btn-primary" onclick="app.showView('scanner')" style="width: 100%; max-width: 280px;">
                            üì∏ Scan Another
                        </button>
                    </div>
                `;

                window.scrollTo(0, 0);
                this.showView('analysis');
                document.getElementById('app-footer').style.display = 'block';
            },

            toggleAnalysisDetails() {
                const section = document.getElementById('analysis-details-section');
                const btn = document.getElementById('analysis-details-toggle');
                if (section && btn) {
                    const isHidden = section.style.display === 'none';
                    section.style.display = isHidden ? 'block' : 'none';
                    btn.textContent = isHidden ? 'Hide details ‚Üë' : 'See details ‚Üí';
                }
            },

            // v1.3: Sources accordion ‚Äì one open at a time
            toggleAccordion(btn) {
                const content = btn.nextElementSibling;
                const wasOpen = content && content.style.display === 'block';
                document.querySelectorAll('.sources-accordion .accordion-content').forEach(el => { el.style.display = 'none'; });
                document.querySelectorAll('.sources-accordion .accordion-arrow').forEach(el => { el.textContent = '‚ñº'; });
                if (content) {
                    content.style.display = wasOpen ? 'none' : 'block';
                    const arrow = btn.querySelector('.accordion-arrow');
                    if (arrow) arrow.textContent = wasOpen ? '‚ñº' : '‚ñ≤';
                }
            },

            // BUG #6: Toggle score details
            toggleScoreDetails() {
                const details = document.getElementById('score-details');
                if (details) {
                    details.style.display = details.style.display === 'none' ? 'block' : 'none';
                }
            },

            // BUG #8: Contribution handlers
            // v1.2.1: Save to My Scans (localStorage only, no Firebase)
            saveToMyScans() {
                try {
                    // Get the current analysis from the displayed content
                    const productName = document.querySelector('.product-name')?.textContent || 'Unknown Product';
                    const healthScore = document.querySelector('.score-circle')?.textContent?.trim() || '??';
                    const scoreCategory = document.querySelector('.score-label')?.textContent || 'unknown';
                    
                    const scan = {
                        id: Date.now(),
                        name: productName,
                        score: parseInt(healthScore) || 0,
                        category: scoreCategory,
                        date: new Date().toISOString(),
                        mode: this.scanMode
                    };
                    
                    // Save to localStorage
                    let savedScans = JSON.parse(localStorage.getItem('my_saved_scans') || '[]');
                    savedScans.unshift(scan);
                    savedScans = savedScans.slice(0, 20); // Keep last 20
                    this.safeLocalStorageSet('my_saved_scans', JSON.stringify(savedScans));
                    
                    this.showToast('Saved to My Scans! üíæ', 'success');
                    
                    // Navigate to scanner after brief delay
                    setTimeout(() => this.showView('scanner'), 1500);
                } catch (e) {
                    console.error('Failed to save scan:', e);
                    this.showToast('Failed to save. Please try again.', 'error');
                }
            },

            skipSave() {
                // Go back to scanner - no guilt
                this.showView('scanner');
            },

            // v1.2.1: promptSignupIfContributing removed - not needed without Firebase

            // BUG #11: Update scan history display
            updateScanHistoryDisplay() {
                const historyContainer = document.getElementById('scan-history-list');
                if (!historyContainer) return;
                
                if (this.recentScans.length === 0) {
                    // BUG-013 FIX: Encouraging empty state with CTA button
                    historyContainer.innerHTML = `
                        <div style="text-align: center; padding: 24px;">
                            <div style="font-size: 48px; margin-bottom: 12px;">üì∏</div>
                            <h3 style="font-size: 18px; font-weight: 700; color: #1E293B; margin-bottom: 8px;">
                                No Scans Yet
                            </h3>
                            <p style="color: #64748B; font-size: 14px; margin-bottom: 20px;">
                                Scan your first product to see what's really inside!
                            </p>
                            <button class="btn btn-primary" onclick="app.showView('scanner')" style="width: 100%;">
                                üì∏ Start Scanning
                            </button>
                        </div>
                    `;
                    return;
                }
                
                historyContainer.innerHTML = this.recentScans.map(scan => `
                    <div style="background: var(--ice-blue); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: var(--slate);">${scan.name}</div>
                        <div style="font-size: 12px; color: var(--light-slate);">
                            Score: ${scan.score} ‚Ä¢ ${new Date(scan.timestamp).toLocaleDateString()}
                        </div>
                    </div>
                `).join('');
            },

            // BUG #13: Show About page
            showAbout() {
                this.showView('about');
            },

            // BUG #6: Show methodology modal
            showMethodology() {
                const modal = `
                    <div class="modal active" id="methodology-modal" onclick="if(event.target === this) app.closeMethodologyModal()">
                        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                            <h3 class="modal-title">üî¨ How We Calculate Health Scores</h3>
                            <div style="font-size: 14px; line-height: 1.8; color: #374151;">
                                <p style="margin-bottom: 16px;">
                                    Our health scores are based on a <strong>4-pillar framework</strong> developed using WHO, FSSAI, and peer-reviewed research:
                                </p>
                                
                                <div style="background: #F0FDF4; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
                                    <strong style="color: #16A34A;">üìä Score Breakdown:</strong>
                                    <ul style="margin: 12px 0 0 20px;">
                                        <li><strong>Processing Level (20%)</strong>: How processed is the food?</li>
                                        <li><strong>Nutrient Quality (35%)</strong>: Good vs bad nutrients</li>
                                        <li><strong>Ingredient Quality (30%)</strong>: Safety of individual ingredients</li>
                                        <li><strong>Transparency (15%)</strong>: Label clarity and certifications</li>
                                    </ul>
                                </div>
                                
                                <div style="background: #FEF3C7; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
                                    <strong style="color: #92400E;">‚ö†Ô∏è Important Notes:</strong>
                                    <ul style="margin: 12px 0 0 20px;">
                                        <li>Scores are educational, not medical advice</li>
                                        <li>Individual health needs vary</li>
                                        <li>Always consult healthcare professionals</li>
                                    </ul>
                                </div>
                                
                                <p style="font-size: 13px; color: #6B7280;">
                                    <strong>Sources:</strong> WHO guidelines, FSSAI standards, FDA regulations, EFSA opinions, peer-reviewed research (PubMed)
                                </p>
                            </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <button class="btn btn-primary" onclick="app.closeMethodologyModal()">Got it!</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modal);
            },

            closeMethodologyModal() {
                const modal = document.getElementById('methodology-modal');
                if (modal) modal.remove();
            },

            // Legal page placeholders
            showPrivacyPolicy() {
                const modal = `
                    <div class="modal active" id="privacy-modal" onclick="if(event.target === this) app.closePrivacyModal()">
                        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                            <h3 class="modal-title">üîí Privacy Policy</h3>
                            <div style="font-size: 14px; line-height: 1.8; color: #374151;">
                                <ul style="margin: 16px 0 0 20px;">
                                    <li style="margin-bottom: 12px;">We respect your privacy</li>
                                    <li style="margin-bottom: 12px;">No personal data collection</li>
                                    <li style="margin-bottom: 12px;">No data sharing with third parties</li>
                                    <li style="margin-bottom: 12px;">Anonymous analytics only</li>
                                </ul>
                                <p style="font-size: 13px; color: #6B7280; margin-top: 20px;">
                                    Full privacy policy coming soon!
                                </p>
                            </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <button class="btn btn-primary" onclick="app.closePrivacyModal()">Got it!</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modal);
            },

            closePrivacyModal() {
                const modal = document.getElementById('privacy-modal');
                if (modal) modal.remove();
            },

            showTerms() {
                const modal = `
                    <div class="modal active" id="terms-modal" onclick="if(event.target === this) app.closeTermsModal()">
                        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                            <h3 class="modal-title">üìã Terms of Service</h3>
                            <div style="font-size: 14px; line-height: 1.8; color: #374151;">
                                <ul style="margin: 16px 0 0 20px;">
                                    <li style="margin-bottom: 12px;">Eitaki is for educational purposes only</li>
                                    <li style="margin-bottom: 12px;">Not medical advice</li>
                                    <li style="margin-bottom: 12px;">Use at your own risk</li>
                                    <li style="margin-bottom: 12px;">Always verify with product packaging</li>
                                </ul>
                                <p style="font-size: 13px; color: #6B7280; margin-top: 20px;">
                                    Full terms coming soon!
                                </p>
                            </div>
                            <div style="margin-top: 20px; text-align: center;">
                                <button class="btn btn-primary" onclick="app.closeTermsModal()">Got it!</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modal);
            },

            closeTermsModal() {
                const modal = document.getElementById('terms-modal');
                if (modal) modal.remove();
            },

            // Utility Functions
            
            // BUG-018 FIX: Safe localStorage wrapper with quota handling
            safeLocalStorageSet(key, value) {
                try {
                    localStorage.setItem(key, value);
                    return true;
                } catch (e) {
                    if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                        this.showToast('Storage full. Please clear old scans in Settings.', 'warning', 5000);
                        this.logError('ERR_STORAGE_FULL', { key, size: value.length });
                        return false;
                    } else {
                        console.error('localStorage error:', e);
                        this.logError('ERR_STORAGE', { error: e.message });
                        return false;
                    }
                }
            },
            
            incrementScanCount() {
                this.scanCount++;
                this.safeLocalStorageSet('scan_count', this.scanCount.toString());
                
                // Check if should prompt for email verification (after 5 scans)
                if (this.scanCount === 5 && !this.emailVerified) {
                    // Could show email modal here, but keeping it progressive for now
                }
            },

            /**
             * Migrates legacy scan history to enhanced format
             * Run once per user - handles users who upgrade
             */
            migrateLegacyScanHistory() {
                try {
                    // Check if migration already done
                    if (localStorage.getItem('eitaki_history_migrated') === 'true') {
                        return;
                    }
                    
                    // Check for legacy data
                    const legacyScans = localStorage.getItem('recent_scans');
                    if (!legacyScans) {
                        localStorage.setItem('eitaki_history_migrated', 'true');
                        return;
                    }
                    
                    // Check if new format already exists
                    const newHistory = localStorage.getItem('eitaki_scan_history');
                    if (newHistory) {
                        localStorage.setItem('eitaki_history_migrated', 'true');
                        return;
                    }
                    
                    // Migrate legacy scans
                    const legacy = JSON.parse(legacyScans);
                    const migrated = legacy.map((scan, index) => ({
                        id: 'migrated_' + index + '_' + Date.now(),
                        timestamp: new Date(scan.timestamp).toISOString(),
                        name: scan.name || 'Unknown Product',
                        brand: scan.brand || null,
                        barcode: null,
                        health_score: scan.score || null,
                        score_category: this.getScoreCategory(scan.score),
                        scan_mode: 'unknown',
                        categories: [],
                        flagged_ingredients: [],
                        product_hash: 'legacy_' + index,
                        scan_count: 1,
                        last_scanned: new Date(scan.timestamp).toISOString()
                    }));
                    
                    this.safeLocalStorageSet('eitaki_scan_history', JSON.stringify(migrated));
                    this.updateScanAggregates(migrated);
                    localStorage.setItem('eitaki_history_migrated', 'true');
                    
                    console.log('Migrated', migrated.length, 'legacy scans to enhanced format');
                    
                } catch (e) {
                    console.error('Failed to migrate legacy scan history:', e);
                    // Don't block app if migration fails
                    localStorage.setItem('eitaki_history_migrated', 'true');
                }
            },

            /**
             * Gets full scan history (enhanced format)
             * @returns {Array} Array of scan records
             */
            getFullScanHistory() {
                try {
                    const stored = localStorage.getItem('eitaki_scan_history');
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    console.error('Failed to get scan history:', e);
                    return [];
                }
            },

            /**
             * Categorizes health score for aggregation
             * @param {number} score - Health score 0-100
             * @returns {string} Category name
             */
            getScoreCategory(score) {
                if (score === null || score === undefined) return 'unknown';
                if (score >= 85) return 'excellent';
                if (score >= 70) return 'good';
                if (score >= 50) return 'fair';
                if (score >= 35) return 'poor';
                return 'very_poor';
            },

            /**
             * Extracts concerning ingredients for tracking
             * @param {Object} analysis - Analysis result
             * @returns {Array} Array of flagged ingredient names
             */
            extractFlaggedIngredients(analysis) {
                const flagged = [];
                if (analysis.ingredients) {
                    analysis.ingredients.forEach(ing => {
                        if (ing.concern === 'high' || ing.concern === 'moderate') {
                            flagged.push(ing.name);
                        }
                    });
                }
                return flagged.slice(0, 10); // Limit to top 10
            },

            /**
             * Generates hash for product deduplication
             * @param {Object} analysis - Analysis result
             * @returns {string} Hash string
             */
            generateProductHash(analysis) {
                const key = (analysis.barcode || '') + '|' + 
                            (analysis.productName || '').toLowerCase().trim() + '|' +
                            (analysis.brand || '').toLowerCase().trim();
                // Simple hash function
                let hash = 0;
                for (let i = 0; i < key.length; i++) {
                    const char = key.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return 'ph_' + Math.abs(hash).toString(36);
            },

            /**
             * Updates aggregate statistics from scan history
             * @param {Array} history - Full scan history
             */
            updateScanAggregates(history) {
                try {
                    const now = new Date();
                    const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
                    
                    const aggregates = {
                        total_scans: history.length,
                        unique_products: new Set(history.map(h => h.product_hash)).size,
                        
                        // Score distribution
                        score_distribution: {
                            excellent: 0,
                            good: 0,
                            fair: 0,
                            poor: 0,
                            very_poor: 0,
                            unknown: 0
                        },
                        
                        // Time-based metrics
                        scans_this_week: history.filter(h => new Date(h.timestamp) > weekAgo).length,
                        
                        // Ingredient concerns frequency
                        top_concerns: {},
                        
                        // Average health score
                        avg_health_score: null,
                        
                        // Last updated
                        updated_at: now.toISOString()
                    };
                    
                    // Calculate distributions
                    let scoreSum = 0;
                    let scoreCount = 0;
                    
                    history.forEach(scan => {
                        // Score distribution
                        if (scan.score_category) {
                            aggregates.score_distribution[scan.score_category]++;
                        }
                        
                        // Average score
                        if (scan.health_score !== null) {
                            scoreSum += scan.health_score;
                            scoreCount++;
                        }
                        
                        // Concern frequency
                        if (scan.flagged_ingredients) {
                            scan.flagged_ingredients.forEach(ing => {
                                aggregates.top_concerns[ing] = (aggregates.top_concerns[ing] || 0) + 1;
                            });
                        }
                    });
                    
                    // Calculate average
                    aggregates.avg_health_score = scoreCount > 0 ? Math.round(scoreSum / scoreCount) : null;
                    
                    // Sort and limit concerns
                    const sortedConcerns = Object.entries(aggregates.top_concerns)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10);
                    aggregates.top_concerns = Object.fromEntries(sortedConcerns);
                    
                    this.safeLocalStorageSet('eitaki_scan_aggregates', JSON.stringify(aggregates));
                    
                } catch (e) {
                    console.error('Failed to update scan aggregates:', e);
                }
            },

            /**
             * Gets user insights based on scan history and behavior
             * This is the foundation of the "Continuous Value Engine"
             * @returns {Object} Insights object with recommendations
             */
            getInsights() {
                try {
                    const profile = this.getUserProfile();
                    const history = this.getFullScanHistory();
                    const aggregates = JSON.parse(localStorage.getItem('eitaki_scan_aggregates') || '{}');
                    const events = this.getEvents();
                    
                    const insights = {
                        // User engagement tier
                        engagement_tier: this.calculateEngagementTier(profile, history, events),
                        
                        // Inferred health concerns
                        inferred_concerns: this.inferHealthConcerns(history, aggregates),
                        
                        // Usage patterns
                        usage_patterns: this.analyzeUsagePatterns(events),
                        
                        // Retention signals
                        retention_signals: this.calculateRetentionSignals(profile, history, events),
                        
                        // Recommendations
                        recommendations: [],
                        
                        // Generated timestamp
                        generated_at: new Date().toISOString()
                    };
                    
                    // Generate recommendations based on insights
                    insights.recommendations = this.generateRecommendations(insights, profile, history);
                    
                    return insights;
                    
                } catch (e) {
                    console.error('Failed to generate insights:', e);
                    return { error: e.message };
                }
            },

            /**
             * Calculates user engagement tier
             * @returns {string} 'new' | 'casual' | 'regular' | 'power'
             */
            calculateEngagementTier(profile, history, events) {
                const daysSinceCreation = (Date.now() - new Date(profile.created_at).getTime()) / (1000 * 60 * 60 * 24);
                const totalScans = history.length;
                const scansPerDay = daysSinceCreation > 0 ? totalScans / daysSinceCreation : totalScans;
                
                if (daysSinceCreation < 7) return 'new';
                if (scansPerDay >= 1) return 'power';
                if (scansPerDay >= 0.3) return 'regular';  // ~2 scans/week
                return 'casual';
            },

            /**
             * Infers health concerns from scan patterns
             * @returns {Array} Array of concern objects
             */
            inferHealthConcerns(history, aggregates) {
                const concerns = [];
                
                // Analyze top flagged ingredients
                if (aggregates.top_concerns) {
                    const topConcerns = Object.entries(aggregates.top_concerns)
                        .slice(0, 3)
                        .map(([ingredient, count]) => ({
                            ingredient,
                            frequency: count,
                            inferred_concern: this.mapIngredientToConcern(ingredient)
                        }));
                    concerns.push(...topConcerns);
                }
                
                // Analyze score patterns
                if (aggregates.avg_health_score !== null) {
                    if (aggregates.avg_health_score < 50) {
                        concerns.push({
                            type: 'score_pattern',
                            message: 'Many scanned products have low health scores',
                            inferred_concern: 'general_health'
                        });
                    }
                }
                
                return concerns;
            },

            /**
             * Maps ingredient to health concern category
             */
            mapIngredientToConcern(ingredient) {
                const lowerIng = ingredient.toLowerCase();
                
                if (/sugar|glucose|fructose|sucrose/i.test(lowerIng)) return 'sugar_intake';
                if (/sodium|salt/i.test(lowerIng)) return 'sodium_intake';
                if (/msg|monosodium/i.test(lowerIng)) return 'additives';
                if (/artificial|color|dye/i.test(lowerIng)) return 'artificial_additives';
                if (/palm oil|trans fat|hydrogenated/i.test(lowerIng)) return 'unhealthy_fats';
                if (/preservative|bha|bht|nitrate/i.test(lowerIng)) return 'preservatives';
                
                return 'general';
            },

            /**
             * Analyzes usage patterns from events
             */
            analyzeUsagePatterns(events) {
                const patterns = {
                    preferred_scan_mode: 'unknown',
                    active_hours: [],
                    feature_usage: {}
                };
                
                if (events.length === 0) return patterns;
                
                // Analyze scan mode preference
                const modeEvents = events.filter(e => e.event === 'scan_complete');
                const modeCounts = { barcode: 0, ingredients: 0 };
                modeEvents.forEach(e => {
                    if (e.metadata?.mode) {
                        modeCounts[e.metadata.mode]++;
                    }
                });
                patterns.preferred_scan_mode = modeCounts.barcode > modeCounts.ingredients ? 'barcode' : 'ingredients';
                
                // Analyze active hours
                const hourCounts = new Array(24).fill(0);
                events.forEach(e => {
                    const hour = new Date(e.timestamp).getHours();
                    hourCounts[hour]++;
                });
                
                // Get top 3 active hours
                const sortedHours = hourCounts
                    .map((count, hour) => ({ hour, count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3)
                    .filter(h => h.count > 0)
                    .map(h => h.hour);
                
                patterns.active_hours = sortedHours;
                
                return patterns;
            },

            /**
             * Calculates retention signals
             */
            calculateRetentionSignals(profile, history, events) {
                const now = Date.now();
                const daysSinceLastActive = (now - new Date(profile.last_active).getTime()) / (1000 * 60 * 60 * 24);
                const daysSinceLastScan = history.length > 0 
                    ? (now - new Date(history[0].timestamp).getTime()) / (1000 * 60 * 60 * 24)
                    : null;
                
                return {
                    days_since_last_active: Math.round(daysSinceLastActive * 10) / 10,
                    days_since_last_scan: daysSinceLastScan !== null ? Math.round(daysSinceLastScan * 10) / 10 : null,
                    total_sessions: events.filter(e => e.event === 'app_open').length,
                    churn_risk: daysSinceLastActive > 14 ? 'high' : daysSinceLastActive > 7 ? 'medium' : 'low'
                };
            },

            /**
             * Generates actionable recommendations
             */
            generateRecommendations(insights, profile, history) {
                const recommendations = [];
                
                // For new users
                if (insights.engagement_tier === 'new') {
                    recommendations.push({
                        type: 'onboarding',
                        message: 'Try scanning a product you regularly buy',
                        priority: 'high'
                    });
                }
                
                // For users with health concerns
                if (insights.inferred_concerns.length > 0) {
                    const topConcern = insights.inferred_concerns[0];
                    if (topConcern.inferred_concern === 'sugar_intake') {
                        recommendations.push({
                            type: 'health_tip',
                            message: 'Looking for lower sugar alternatives? Try scanning similar products to compare.',
                            priority: 'medium'
                        });
                    }
                }
                
                // For at-risk users
                if (insights.retention_signals.churn_risk === 'high') {
                    recommendations.push({
                        type: 'engagement',
                        message: 'We miss you! Scan a product today to stay on top of your health goals.',
                        priority: 'high'
                    });
                }
                
                // For power users (premium candidates)
                if (insights.engagement_tier === 'power' && history.length > 30) {
                    recommendations.push({
                        type: 'premium_signal',
                        message: 'Power user identified - candidate for premium features',
                        priority: 'low',
                        internal_only: true
                    });
                }
                
                return recommendations;
            },

            addToRecentScans(analysis) {
                // C1: Don't save ingredients-only scans to history
                if (this.scanMode === 'ingredients' || 
                    analysis.productName?.includes('Unknown') ||
                    analysis.productName?.includes('ingredients only')) {
                    console.log('Ingredients-only scan - not saving to history');
                    
                    // Still track the event for analytics (NEW - Auth Strategy v1.1)
                    this.trackEvent(this.ANALYTICS_EVENTS.SCAN_COMPLETE, {
                        mode: 'ingredients',
                        saved_to_history: false
                    });
                    return;
                }
                
                // Enhanced scan record with analytics metadata (NEW - Auth Strategy v1.1)
                const scanRecord = {
                    id: 'scan_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6),
                    timestamp: new Date().toISOString(),
                    
                    // Product info
                    name: analysis.productName || 'Unknown Product',
                    brand: analysis.brand || null,
                    barcode: analysis.barcode || null,
                    
                    // Health data
                    health_score: analysis.healthScore || null,
                    score_category: this.getScoreCategory(analysis.healthScore),
                    
                    // Scan context
                    scan_mode: this.scanMode,
                    
                    // Extracted insights (for future recommendations)
                    categories: analysis.categories || [],
                    flagged_ingredients: this.extractFlaggedIngredients(analysis),
                    
                    // For deduplication and repeat tracking
                    product_hash: this.generateProductHash(analysis)
                };
                
                // Load existing history
                let scanHistory = this.getFullScanHistory();
                
                // Check for duplicate (same product scanned again)
                const existingIndex = scanHistory.findIndex(s => s.product_hash === scanRecord.product_hash);
                if (existingIndex !== -1) {
                    // Update existing record instead of adding duplicate
                    scanHistory[existingIndex].last_scanned = scanRecord.timestamp;
                    scanHistory[existingIndex].scan_count = (scanHistory[existingIndex].scan_count || 1) + 1;
                    // Move to top of list
                    const existing = scanHistory.splice(existingIndex, 1)[0];
                    scanHistory.unshift(existing);
                } else {
                    scanRecord.scan_count = 1;
                    scanRecord.last_scanned = scanRecord.timestamp;
                    scanHistory.unshift(scanRecord);
                }
                
                // Limit to 100 scans for storage efficiency
                scanHistory = scanHistory.slice(0, 100);
                
                // Save enhanced history
                this.safeLocalStorageSet('eitaki_scan_history', JSON.stringify(scanHistory));
                
                // Update legacy format for backward compatibility
                this.recentScans = scanHistory.slice(0, 5).map(s => ({
                    name: s.name,
                    brand: s.brand,
                    score: s.health_score,
                    timestamp: new Date(s.timestamp).getTime()
                }));
                this.safeLocalStorageSet('recent_scans', JSON.stringify(this.recentScans));
                
                // Update user profile scan count (NEW - Auth Strategy v1.1)
                this.updateUserProfile({ scan_count: scanHistory.length });
                
                // Update aggregate stats (NEW - Auth Strategy v1.1)
                this.updateScanAggregates(scanHistory);
                
                // Track event (NEW - Auth Strategy v1.1)
                this.trackEvent(this.ANALYTICS_EVENTS.SCAN_COMPLETE, {
                    mode: this.scanMode,
                    health_score: scanRecord.health_score,
                    is_repeat_scan: existingIndex !== -1,
                    saved_to_history: true
                });
                
                // Update UI
                this.renderRecentScans();
                this.updateScanHistoryDisplay();
            },

            loadRecentScans() {
                try {
                    const saved = localStorage.getItem('recent_scans');
                    if (saved) {
                        this.recentScans = JSON.parse(saved);
                        this.renderRecentScans();
                    }
                } catch (e) {
                    console.error('Failed to load recent scans:', e);
                    this.recentScans = [];
                }
            },

            renderRecentScans() {
                if (this.recentScans.length === 0) return;
                
                const container = document.getElementById('recent-scans-container');
                const itemsContainer = document.getElementById('recent-items');
                
                if (!container || !itemsContainer) return; // Null check
                
                container.style.display = 'block';
                itemsContainer.innerHTML = this.recentScans.map(scan => `
                    <div class="recent-item">
                        ${scan.name || 'Unknown Product'}
                    </div>
                `).join('');
            },

            // Donation Functions
            donate(amount) {
                this.showToast(`Thank you for your support! ‚Çπ${amount} donation feature coming soon. For now, you can support us by sharing Eitaki with friends! üíö`, 'success', 5000);
            },

            donateCustom() {
                const amount = prompt('Enter donation amount (‚Çπ):');
                if (amount && !isNaN(amount)) {
                    this.donate(amount);
                }
            },

            // Modal Functions
            closeModal() {
                document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
            },

            // v1.2.1: showSearchModal(), showEmailModal(), sendVerificationCode() removed - Phase 1.5 features

            // Loading Functions
            showLoading(message) {
                document.getElementById('loading-message').textContent = message;
                document.getElementById('loading-overlay').classList.add('active');
            },

            updateLoadingMessage(message) {
                document.getElementById('loading-message').textContent = message;
            },

            hideLoading() {
                document.getElementById('loading-overlay').classList.remove('active');
            }
        };

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });

        // Service worker registration removed - will be implemented in Phase 1.5 with Firebase
    </script>
</body>
</html>
